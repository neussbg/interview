# Вопросы о браузере и веб на собеседовании фронтенд-разработчика

## Основы работы браузера

### Опишите процесс отрисовки веб-страницы в браузере

Когда браузер загружает веб-страницу, происходит следующая последовательность:

1. **Загрузка HTML**: Браузер запрашивает HTML-документ с сервера
2. **Парсинг HTML**: Создается DOM-дерево (Document Object Model)
3. **Загрузка и парсинг CSS**: Формируется CSSOM (CSS Object Model)
4. **Построение Render Tree**: Объединение DOM и CSSOM в одно дерево рендеринга
5. **Layout (Reflow)**: Вычисление размеров и позиций элементов
6. **Paint**: Отрисовка пикселей на экране
7. **Композитинг**: Объединение слоёв для финальной отрисовки

### Что такое critical rendering path?

Critical Rendering Path (CRP, Критический путь рендеринга) — это последовательность шагов, которые браузер выполняет для первоначального отображения страницы:

#### Основные этапы CRP:

1. **Построение DOM (Document Object Model)**:

   - Парсинг HTML-документа
   - Создание древовидной структуры элементов
   - Блокируется из-за синхронных скриптов без атрибутов `async/defer`

2. **Построение CSSOM (CSS Object Model)**:

   - Парсинг CSS-файлов и стилей
   - Создание древовидной структуры стилей
   - CSS является блокирующим ресурсом для рендеринга

3. **Построение Render Tree**:

   - Объединение DOM и CSSOM
   - Содержит только видимые элементы (исключаются `display: none`)
   - Учитывает вычисленные стили для каждого видимого узла

4. **Layout (Reflow)**:

   - Вычисление точных размеров и позиций элементов
   - Определение геометрии каждого элемента в пикселях
   - Зависит от размера экрана устройства

5. **Paint**:

   - Отрисовка пикселей на экране
   - Заполнение элементов цветами, текстурами, тенями и т.д.
   - Может выполняться на нескольких слоях

6. **Композитинг**:
   - Объединение слоёв для финальной отрисовки
   - Обработка прозрачности и наложений
   - Может использовать аппаратное ускорение GPU

#### Метрики производительности CRP:

- **FCP (First Contentful Paint)**: первое отображение контента
- **LCP (Largest Contentful Paint)**: отображение основного контента
- **TTI (Time to Interactive)**: время до интерактивности страницы
- **FID (First Input Delay)**: задержка до обработки первого взаимодействия
- **CLS (Cumulative Layout Shift)**: визуальная стабильность страницы

#### Блокирующие ресурсы:

- **JavaScript** блокирует парсинг DOM (решения: `async`, `defer`, `module`)
- **CSS** блокирует построение Render Tree (решения: критический CSS, асинхронная загрузка)
- **Шрифты** могут вызывать FOIT/FOUT (решения: font-display, preload)

#### Инструменты для анализа CRP:

- **Chrome DevTools Performance**: детальный анализ каждого этапа
- **Lighthouse**: комплексная оценка и рекомендации
- **PageSpeed Insights**: анализ с учетом Core Web Vitals
- **WebPageTest**: покадровый анализ процесса загрузки

#### Стратегии оптимизации CRP:

1. **Минимизация количества критических ресурсов**:

   - Сокращение размера HTML, CSS, JavaScript
   - Удаление неиспользуемого кода (code splitting, tree shaking)
   - Объединение файлов для уменьшения количества запросов

2. **Оптимизация порядка загрузки ресурсов**:

   - Приоритетная загрузка критического CSS
   - Отложенная загрузка некритичных скриптов
   - Использование `preload`, `prefetch`, `preconnect`

3. **Сокращение размера ресурсов**:

   - Минификация и компрессия (GZIP, Brotli)
   - Оптимизация изображений (WebP, AVIF, lazy loading)
   - Кеширование с правильными заголовками

4. **Оптимизация JavaScript**:
   - Асинхронная загрузка с `async` и `defer`
   - Разделение кода на критичный и некритичный
   - Использование Web Workers для тяжелых вычислений

#### Влияние на пользовательское восприятие:

- Страницы с оптимизированным CRP загружаются быстрее и отзывчивее
- Снижение показателя отказов (bounce rate) и увеличение конверсии
- Положительное влияние на SEO-рейтинг (Core Web Vitals как фактор ранжирования)
- Улучшение пользовательского опыта, особенно на мобильных устройствах

### Как работает событийная модель в JavaScript?

- Однопоточная модель с циклом событий (Event Loop)
- События помещаются в очередь и обрабатываются последовательно
- Асинхронные операции (таймеры, запросы) обрабатываются через callback-функции
- Фазы распространения событий: capturing (погружение) → target (цель) → bubbling (всплытие)
- Делегирование событий позволяет обрабатывать события на родительских элементах

### В чём разница между localStorage, sessionStorage и cookie?

- **localStorage**: Хранит данные без срока действия, доступ только в рамках одного домена, до 5MB
- **sessionStorage**: Данные существуют только в рамках сессии браузера (до закрытия вкладки), до 5MB
- **Cookies**: Отправляются с каждым HTTP-запросом, имеют срок жизни, ограничены ~4KB, могут иметь флаги HttpOnly, Secure, SameSite

### Что такое Service Workers и как они работают?

- JavaScript-файлы, работающие в фоновом режиме, независимо от веб-страницы
- Позволяют создавать оффлайн-функциональность через перехват сетевых запросов
- Обеспечивают кэширование ресурсов для быстрой загрузки
- Основа для PWA (Progressive Web Apps)
- Имеют собственный жизненный цикл: регистрация → установка → активация

## PWA и оффлайн-функциональность веб-приложений

### Progressive Web Apps (PWA) основы

- **Определение**: Веб-приложения, использующие современные веб-возможности для обеспечения пользовательского опыта, сравнимого с нативными приложениями
- **Ключевые принципы**:
  - **Progressive**: Работа на любом устройстве с постепенным улучшением функциональности
  - **Responsive**: Адаптация к различным устройствам и разрешениям экрана
  - **Connectivity-independent**: Функционирование при слабом соединении или оффлайн
  - **App-like**: Взаимодействие и навигация как в нативных приложениях
  - **Fresh**: Автоматические обновления через Service Workers
  - **Safe**: Работа через HTTPS для обеспечения безопасности
  - **Discoverable**: Индексация поисковыми системами как обычные веб-сайты
  - **Re-engageable**: Возможность взаимодействия через Push-уведомления
  - **Installable**: Добавление на главный экран без магазина приложений
  - **Linkable**: Возможность обмена ссылкой без сложной установки

### Service Workers (расширенная информация)

- **Жизненный цикл Service Worker**:

  1. **Регистрация**:
     ```javascript
     if ("serviceWorker" in navigator) {
       navigator.serviceWorker
         .register("/sw.js")
         .then((registration) =>
           console.log("SW registered:", registration.scope)
         )
         .catch((error) => console.log("SW registration failed:", error));
     }
     ```
  2. **Установка**: Событие `install` - подготовка и кеширование ресурсов
     ```javascript
     self.addEventListener("install", (event) => {
       event.waitUntil(
         caches.open("v1").then((cache) => {
           return cache.addAll([
             "/",
             "/styles/main.css",
             "/scripts/main.js",
             "/images/logo.png",
           ]);
         })
       );
     });
     ```
  3. **Активация**: Событие `activate` - очистка старых кешей и подготовка к работе
     ```javascript
     self.addEventListener("activate", (event) => {
       event.waitUntil(
         caches.keys().then((cacheNames) => {
           return Promise.all(
             cacheNames
               .filter((cacheName) => cacheName !== "v1")
               .map((cacheName) => caches.delete(cacheName))
           );
         })
       );
     });
     ```
  4. **Перехват запросов**: Событие `fetch` - обработка сетевых запросов
     ```javascript
     self.addEventListener("fetch", (event) => {
       event.respondWith(
         caches
           .match(event.request)
           .then((response) => response || fetch(event.request))
       );
     });
     ```

- **Стратегии кеширования**:

  - **Cache First**: Сначала проверка в кеше, затем сеть (приоритет скорости)
    ```javascript
    self.addEventListener("fetch", (event) => {
      event.respondWith(
        caches
          .match(event.request)
          .then((response) => response || fetch(event.request))
      );
    });
    ```
  - **Network First**: Сначала запрос в сеть, затем кеш (приоритет актуальности)
    ```javascript
    self.addEventListener("fetch", (event) => {
      event.respondWith(
        fetch(event.request).catch(() => caches.match(event.request))
      );
    });
    ```
  - **Stale-While-Revalidate**: Возврат из кеша с одновременным обновлением
    ```javascript
    self.addEventListener("fetch", (event) => {
      event.respondWith(
        caches.open("v1").then((cache) => {
          return cache.match(event.request).then((response) => {
            const fetchPromise = fetch(event.request).then(
              (networkResponse) => {
                cache.put(event.request, networkResponse.clone());
                return networkResponse;
              }
            );
            return response || fetchPromise;
          });
        })
      );
    });
    ```
  - **Cache Only**: Только кеш (для критических статических ресурсов)
    ```javascript
    self.addEventListener("fetch", (event) => {
      event.respondWith(caches.match(event.request));
    });
    ```
  - **Network Only**: Только сеть (для динамичных данных, требующих актуальности)
    ```javascript
    self.addEventListener("fetch", (event) => {
      event.respondWith(fetch(event.request));
    });
    ```

- **Обновление Service Worker**:
  - Автоматическое обновление при изменении файла service worker
  - Управление через `skipWaiting()` и `clients.claim()`
  - Версионирование кешей для безопасного обновления

### Web App Manifest

- **Определение**: JSON-файл, предоставляющий информацию о веб-приложении для установки
- **Основные свойства**:

  - `name`: Полное название приложения
  - `short_name`: Короткое название для главного экрана
  - `icons`: Массив иконок различных размеров
  - `start_url`: URL для запуска при открытии с главного экрана
  - `display`: Режим отображения (`fullscreen`, `standalone`, `minimal-ui`, `browser`)
  - `theme_color`: Цвет темы для UI браузера
  - `background_color`: Цвет фона загрузочного экрана
  - `description`: Описание приложения
  - `orientation`: Предпочтительная ориентация
  - `scope`: Область URL, относящаяся к приложению

- **Пример manifest.json**:

  ```json
  {
    "name": "Мое PWA Приложение",
    "short_name": "PWA Прил",
    "icons": [
      {
        "src": "/images/icons/icon-128x128.png",
        "sizes": "128x128",
        "type": "image/png"
      },
      {
        "src": "/images/icons/icon-512x512.png",
        "sizes": "512x512",
        "type": "image/png"
      }
    ],
    "start_url": "/index.html",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#2196f3",
    "orientation": "portrait"
  }
  ```

- **Подключение в HTML**:
  ```html
  <link rel="manifest" href="/manifest.json" />
  <meta name="theme-color" content="#2196f3" />
  <link rel="apple-touch-icon" href="/images/icons/icon-152x152.png" />
  ```

### App Shell модель

- **Определение**: Архитектурный подход, при котором минимальный HTML, CSS и JavaScript кешируются для мгновенной загрузки интерфейса приложения

- **Состав App Shell**:

  - **Основной HTML-скелет** (без динамического контента)
  - **Базовые стили CSS** для интерфейса
  - **JavaScript** для управления UI и загрузки данных
  - **Статические ресурсы** (шрифты, иконки, логотип)

- **Преимущества**:

  - Значительное улучшение perceived performance (субъективной производительности)
  - Уменьшение TTI (Time To Interactive)
  - Согласованность UI при различных сетевых условиях
  - Снижение зависимости от сетевых запросов

- **Реализация**:
  1. Определение базовой структуры интерфейса
  2. Кеширование App Shell при установке Service Worker
  3. Динамическая загрузка контента после активации UI

### Push Notifications в веб-приложениях

- **Технологии**:

  - **Push API**: Получение серверных уведомлений
  - **Notifications API**: Отображение уведомлений пользователю
  - **Service Workers**: Обработка push-событий даже когда приложение закрыто

- **Процесс настройки**:

  1. **Запрос разрешения**:

     ```javascript
     Notification.requestPermission().then((permission) => {
       if (permission === "granted") {
         // Разрешение получено
       }
     });
     ```

  2. **Подписка на Push-уведомления**:

     ```javascript
     navigator.serviceWorker.ready
       .then((registration) => {
         return registration.pushManager.subscribe({
           userVisibleOnly: true,
           applicationServerKey: urlBase64ToUint8Array(publicKey),
         });
       })
       .then((subscription) => {
         // Отправка данных подписки на сервер
         return fetch("/api/subscribe", {
           method: "POST",
           body: JSON.stringify(subscription),
           headers: {
             "Content-Type": "application/json",
           },
         });
       });
     ```

  3. **Обработка в Service Worker**:

     ```javascript
     self.addEventListener("push", (event) => {
       const data = event.data.json();
       const options = {
         body: data.body,
         icon: "/images/icon.png",
         badge: "/images/badge.png",
         data: {
           url: data.url,
         },
       };

       event.waitUntil(self.registration.showNotification(data.title, options));
     });

     self.addEventListener("notificationclick", (event) => {
       event.notification.close();
       event.waitUntil(clients.openWindow(event.notification.data.url));
     });
     ```

- **Лучшие практики**:
  - Запрашивать разрешение в подходящий момент (после взаимодействия)
  - Использовать уведомления только для важной и актуальной информации
  - Обеспечить возможность отписки от уведомлений
  - Персонализировать содержание уведомлений
  - Предоставлять четкие действия в уведомлениях

### Оффлайн-функциональность и синхронизация

- **Background Sync API**:

  - Отложенная отправка данных при восстановлении соединения
  - Регистрация через Service Worker:
    ```javascript
    navigator.serviceWorker.ready.then((registration) => {
      return registration.sync.register("data-sync");
    });
    ```
  - Обработка в Service Worker:
    ```javascript
    self.addEventListener("sync", (event) => {
      if (event.tag === "data-sync") {
        event.waitUntil(syncData());
      }
    });
    ```

- **Периодический синхронизация** (Periodic Sync API):

  - Регулярное обновление контента даже когда приложение не открыто
  - Полезно для новостных приложений, почты, или социальных сетей
  - Необходимо разрешение от пользователя

- **IndexedDB для оффлайн-хранения**:

  - Хранение данных пользователя и контента
  - Синхронизация с сервером при восстановлении соединения
  - Организация очередей операций

- **Стратегии оффлайн-работы**:

  - **Оффлайн-первый**: Проектирование функций для работы без сети
  - **Прогрессивное улучшение**: Базовый функционал работает без JS, расширенный с JS и сетью
  - **Оптимистичный UI**: Незамедлительное отображение изменений с последующей синхронизацией
  - **Уведомление о статусе соединения**:

    ```javascript
    window.addEventListener("online", () => {
      // Обработка восстановления соединения
    });

    window.addEventListener("offline", () => {
      // Уведомление пользователя о работе в оффлайн
    });
    ```

### Измерение и оптимизация производительности PWA

- **Ключевые метрики**:

  - **Lighthouse PWA Score**: Комплексная оценка соответствия принципам PWA
  - **Time to Interactive (TTI)**: Время до интерактивности
  - **First Contentful Paint (FCP)**: Первая отрисовка контента
  - **Installation Rate**: Процент установок приложения
  - **Retention Rate**: Возвращаемость пользователей

- **Инструменты аудита**:

  - **Lighthouse**: Встроен в Chrome DevTools
  - **PWA Builder**: Анализ и рекомендации для PWA
  - **Workbox**: Набор библиотек для упрощения разработки PWA от Google

- **Лучшие практики оптимизации**:
  - **Минимальный размер App Shell**
  - **Предварительное кеширование критических ресурсов**
  - **Сжатие и оптимизация изображений** с использованием современных форматов
  - **Стратегии ленивой загрузки** для некритичных ресурсов
  - **Использование indexedDB** вместо localStorage для больших данных
  - **Минимизация обращений к DOM** в JavaScript

## DOM и рендеринг

### Что такое reflow и repaint, чем они отличаются?

- **Reflow (перекомпоновка)**: Процесс пересчета размеров и позиций элементов в DOM-дереве
  - Запускается при изменении структуры DOM, размеров элементов, позиционирования
  - Затратная операция, так как требует пересчета всего макета страницы или его части
  - Примеры триггеров: изменение размера окна, изменение шрифта, добавление/удаление классов с влиянием на геометрию
- **Repaint (перерисовка)**: Процесс обновления визуального стиля элементов без изменения их геометрии
  - Происходит при изменении цвета, прозрачности, фона и т.д.
  - Менее затратный, чем reflow, но все равно влияет на производительность
  - Любой reflow вызывает repaint, но не наоборот

### Как оптимизировать DOM-операции?

- **Минимизация DOM-манипуляций**:
  - Группировать изменения в DOM вместо многократных отдельных операций
  - Использовать DocumentFragment для подготовки элементов перед вставкой
  - Изменять классы вместо инлайн-стилей
- **Предотвращение layout thrashing**:
  - Сначала считывать свойства DOM, потом выполнять изменения
  - Избегать циклов "чтение-запись-чтение-запись"
- **Оптимизация списков**:
  - Использовать виртуализацию для больших списков
  - Применять `key` для оптимизации обновлений (в React и других фреймворках)
- **Техники для предотвращения reflow**:
  - Изменять классы на самом нижнем уровне DOM-дерева
  - Временно скрывать элементы (display: none) перед множественными изменениями
  - Использовать CSS-свойства, которые не вызывают reflow (transform, opacity)

### Объясните, что такое shadow DOM

- Инкапсулированное DOM-дерево, прикрепленное к элементу, но отделенное от основного DOM
- **Ключевые особенности**:
  - Изоляция CSS-стилей (стили внутри shadow DOM не влияют на основной DOM)
  - Инкапсуляция компонентов (внутренняя структура скрыта от внешнего DOM)
  - Предотвращение коллизий имен и стилей
- **Применение**:
  - Основа для веб-компонентов (Custom Elements)
  - Встроенные элементы браузера (video, audio, input type="range") используют shadow DOM
- **Структура**:
  - Shadow Host: Обычный DOM-узел, к которому прикреплен shadow DOM
  - Shadow Root: Корневой узел shadow DOM
  - Shadow Boundary: Граница между обычным и shadow DOM

### Почему инлайн-стили могут быть проблемой для производительности?

- **Увеличение размера HTML**: Каждый инлайновый стиль увеличивает размер HTML-документа
- **Частые reflow и repaint**:
  - Инлайн-стили часто меняются через JavaScript, вызывая reflow/repaint
  - Браузер не может оптимизировать изменения, как с классами
- **Отсутствие кэширования**:
  - Внешние CSS-файлы кэшируются браузером
  - Инлайновые стили приходится загружать каждый раз
- **Неэффективность парсинга**:
  - Браузер должен парсить инлайн-стили при построении DOM
  - Внешние CSS уже предварительно обработаны
- **Разрушение разделения представления и содержимого**:
  - Затрудняет поддержку кода
  - Усложняет адаптивность дизайна

### Как работают CSS-анимации на уровне браузера?

- **Rendering pipeline**:
  - JavaScript → Style → Layout → Paint → Composite
  - Оптимальные анимации затрагивают только этап композитинга
- **Свойства влияющие только на композитинг**:
  - transform: translate(), scale(), rotate()
  - opacity
  - filter
  - will-change (подсказка браузеру)
- **Механизмы анимаций**:
  - **CSS Transitions**: Плавный переход между состояниями, аппаратно-ускоренные
  - **CSS Animations**: Более сложные последовательности с keyframes
  - **requestAnimationFrame**: JavaScript-анимации, синхронизированные с циклом отрисовки
- **Оптимизация анимаций**:
  - Использование свойств, затрагивающих только композитинг (transform вместо left/top)
  - Перемещение анимируемых элементов на отдельный слой с will-change или transform: translateZ(0)
  - Избегание анимаций свойств, вызывающих layout/paint
- **Производительность**:
  - GPU-ускорение для transform и opacity
  - Анимации @keyframes предварительно обрабатываются браузером

## Рендеринг и производительность браузера

### Архитектура современного браузера

- **Основные компоненты**:

  - **UI-слой**: Адресная строка, кнопки навигации, закладки
  - **Browser engine**: Координация между UI и рендеринг-движком
  - **Rendering engine**: Отвечает за отображение запрошенного контента
  - **Networking**: Обрабатывает сетевые запросы
  - **JavaScript engine**: Интерпретирует и выполняет JS-код (V8, SpiderMonkey)
  - **UI Backend**: Рисует базовые виджеты (кнопки, поля ввода)
  - **Storage**: Управляет данными (cookies, localStorage, IndexedDB)

- **Многопроцессная архитектура**:
  - **Browser Process**: Управляет UI, сетевыми запросами, хранилищем
  - **Renderer Process**: Обрабатывает и отображает веб-контент (по одному на вкладку)
  - **Plugin Process**: Изолирует плагины от основного процесса
  - **GPU Process**: Обрабатывает GPU-задачи для всех процессов
  - **Utility Processes**: Различные служебные задачи

### Подробно о Rendering Pipeline

- **Рендеринг поток (Critical Rendering Path)**:
  1. **JavaScript**: Изменение DOM и стилей
  2. **Style calculation**: Вычисление стилей для элементов
  3. **Layout/Reflow**: Вычисление геометрии
  4. **Paint**: Отрисовка пикселей
  5. **Composite**: Объединение слоев
- **Инициаторы перерисовки**:

  - Изменение DOM-структуры
  - Изменение CSS-свойств
  - Анимации и переходы
  - Прокрутка и изменение размеров окна
  - Операции с Web API, влияющие на макет

- **Оптимизация Rendering Pipeline**:
  - **Сокращение задач в JavaScript**: Избегание длительных вычислений в основном потоке
  - **Минимизация Style Recalculation**: Изменение классов вместо инлайн-стилей
  - **Предотвращение Layout Thrashing**: Группировка операций чтения и записи
  - **Снижение Paint Complexity**: Упрощение слоев и эффектов
  - **Оптимизация Composite**: Использование transform и opacity

### Механизмы потоков в браузере

- **Main Thread (UI Thread)**:
  - Обрабатывает ввод пользователя
  - Выполняет JavaScript
  - Управляет DOM и CSSOM
  - Вычисляет стили и макет
  - Подготавливает данные для отрисовки
- **Compositor Thread**:

  - Отвечает за сборку слоев
  - Работает независимо от основного потока
  - Может использовать GPU для аппаратного ускорения
  - Обрабатывает прокрутку без блокировки UI

- **Worker Threads**:

  - **Web Workers**: Для длительных вычислений в JavaScript
  - **Service Workers**: Для перехвата сетевых запросов
  - **Worklets**: Специализированные потоки (Paint Worklet, Audio Worklet)

- **Raster Threads**:
  - Отвечают за растеризацию (преобразование векторов в пиксели)
  - Работают параллельно для повышения производительности

### Layers и композитинг

- **Слои рендеринга**:

  - Браузер разделяет контент на слои для оптимизации отрисовки
  - Изменения внутри одного слоя не затрагивают другие слои
  - Слои могут быть аппаратно-ускоренными (GPU)

- **Свойства, влияющие на создание слоев**:

  - `will-change: transform, opacity, ...`
  - `transform: translateZ(0)` или `transform: translate3d(0,0,0)`
  - `position: fixed/sticky`
  - `opacity` с анимацией
  - Элементы с `overflow` и прокруткой
  - Canvas, Video элементы

- **Преимущества компоновки слоев**:

  - Аппаратное ускорение (GPU)
  - Параллельная обработка
  - Оптимизация перерисовки (только измененные слои)

- **Проблемы избыточной слоистости**:
  - Повышенное потребление памяти
  - Дополнительные вычисления при композитинге
  - "Плоские" элементы эффективнее для простых случаев

### Layout Thrashing и его предотвращение

- **Что такое Layout Thrashing**:

  - Принудительный синхронный reflow из-за частого чередования чтения и записи DOM-свойств
  - Приводит к значительному снижению производительности
  - Также известен как forced synchronous layout/reflow

- **Типичные сценарии**:

  ```javascript
  // Плохо: каждая итерация вызывает reflow
  for (let i = 0; i < elements.length; i++) {
    elements[i].style.width = elements[i].offsetWidth + 10 + "px";
  }
  ```

- **Оптимизированный подход**:

  ```javascript
  // Хорошо: сначала чтение, потом запись
  const widths = [];
  for (let i = 0; i < elements.length; i++) {
    widths[i] = elements[i].offsetWidth;
  }
  for (let i = 0; i < elements.length; i++) {
    elements[i].style.width = widths[i] + 10 + "px";
  }
  ```

- **Используемые техники предотвращения**:
  - **Batching**: Группировка операций чтения и записи
  - **Использование requestAnimationFrame**: Синхронизация с циклом отрисовки
  - **Virtualization**: Отображение только видимых элементов
  - **Measure-Update pattern**: Разделение фаз измерения и обновления
  - **FastDOM, FLIP**: Библиотеки для оптимизации DOM-операций

### Оптимизация рендеринга списков и таблиц

- **Проблемы со списками**:

  - Большое количество DOM-узлов
  - Вложенная структура и сложные стили
  - Частые обновления и перерисовки

- **Методы оптимизации**:

  - **Виртуализация**: Отрисовка только видимых элементов (react-window, react-virtualized)
  - **Оконная пагинация**: Загрузка и отображение данных порциями
  - **Дерегистрация событий**: Удаление обработчиков для невидимых элементов
  - **Кэширование размеров**: Предварительный расчет и сохранение размеров элементов
  - **Скелетон-загрузка**: Отображение плейсхолдера во время загрузки

- **Пример виртуализации**:

  ```javascript
  // Вместо рендера всех элементов
  items.map(item => <ListItem key={item.id} data={item} />)

  // Рендер только видимых с правильным позиционированием
  <VirtualList
    height={500}
    itemCount={items.length}
    itemSize={50}
    renderItem={({index, style}) => (
      <ListItem style={style} key={items[index].id} data={items[index]} />
    )}
  />
  ```

### Инструменты для анализа производительности рендеринга

- **Chrome DevTools**:

  - **Performance panel**: Запись и анализ процессов рендеринга
  - **Rendering tab**: Визуализация перерисовок и FPS-счетчик
  - **Layers panel**: Анализ слоев композитинга
  - **Performance monitor**: Отслеживание в реальном времени

- **Lighthouse**:

  - Комплексный анализ производительности
  - Конкретные рекомендации для оптимизации
  - Метрики CLS, LCP, TBT, TTI

- **WebPageTest**:

  - Покадровый анализ загрузки страницы
  - Визуальная история загрузки (filmstrip)
  - Подробные водопады ресурсов

- **Browser Performance API**:
  - `performance.mark()` и `performance.measure()` для создания пользовательских метрик
  - `PerformanceObserver` для мониторинга специфических метрик
  - Web Vitals JavaScript library для отслеживания Core Web Vitals

## Производительность

### Как измерить производительность веб-страницы?

- **Инструменты браузера**:
  - **Chrome DevTools Performance** - запись и анализ производительности, вкладка Performance
  - **Lighthouse** - комплексный анализ скорости, доступности, SEO, best practices
  - **Network панель** - анализ времени загрузки ресурсов, размеров файлов
  - **Performance Monitor** - отслеживание использования CPU, памяти, DOM-узлов в реальном времени
- **Внешние сервисы**:
  - **PageSpeed Insights** - анализ производительности на мобильных и десктопных устройствах
  - **WebPageTest** - детальное тестирование производительности с разных локаций и устройств
  - **GTmetrix** - анализ скорости загрузки и оптимизации веб-страницы
- **Метрики производительности**:
  - **Время загрузки** (Load Time) - полное время загрузки страницы
  - **Time to First Byte (TTFB)** - время до получения первого байта контента
  - **First Contentful Paint (FCP)** - первый контент на странице
  - **Largest Contentful Paint (LCP)** - когда загружен основной контент
  - **Total Blocking Time (TBT)** - суммарное время блокировки основного потока
  - **Cumulative Layout Shift (CLS)** - метрика визуальной стабильности
  - **First Input Delay (FID)** и **Interaction to Next Paint (INP)** - метрики интерактивности

### Что такое Core Web Vitals и что они измеряют?

- **Определение**: Набор метрик от Google, оценивающих пользовательский опыт взаимодействия с веб-страницей
- **Ключевые метрики**:
  - **Largest Contentful Paint (LCP)** - скорость загрузки
    - Измеряет время отрисовки самого большого элемента контента в области видимости
    - Хороший показатель: до 2.5 секунд
    - Показывает, насколько быстро страница может отображать основной контент
  - **Cumulative Layout Shift (CLS)** - визуальная стабильность
    - Измеряет неожиданные сдвиги элементов страницы во время загрузки
    - Хороший показатель: до 0.1
    - Предотвращает ситуации, когда пользователь нажимает не на тот элемент из-за сдвига
  - **Interaction to Next Paint (INP)** - отзывчивость интерфейса (с 2024 заменила FID)
    - Измеряет время реакции страницы на взаимодействия пользователя
    - Хороший показатель: до 200 мс
    - Учитывает все взаимодействия пользователя на странице, а не только первое
- **Значение**:
  - Влияют на ранжирование в поисковой выдаче Google
  - Отражают реальный пользовательский опыт
  - Ориентированы на мобильные устройства в первую очередь
- **Измерение**:
  - Chrome User Experience Report (CrUX)
  - Chrome DevTools, Lighthouse, PageSpeed Insights
  - Web Vitals JavaScript Library для измерения в реальном пользовательском окружении

### Опишите методы оптимизации загрузки веб-страницы

- **Оптимизация ресурсов**:
  - **Минификация** CSS, JavaScript, HTML-файлов
  - **Сжатие изображений** и использование форматов WebP, AVIF
  - **Адаптивные изображения** с помощью `srcset` и `sizes`
  - **Шрифты**: оптимизация, подгрузка только нужных наборов символов
- **Стратегии загрузки**:
  - **Критический CSS** (инлайн важных стилей для первого экрана)
  - **Прогрессивная загрузка изображений** (blur-up, LQIP)
  - **Асинхронная загрузка JS** с атрибутами `async` и `defer`
  - **Lazy loading** для изображений и iframe с атрибутом `loading="lazy"`
- **Оптимизация доставки**:
  - **Использование CDN** для приближения ресурсов к пользователю
  - **HTTP/2** для параллельных запросов по одному соединению
  - **Правильные заголовки кэширования** (Cache-Control, ETag)
  - **Preload, prefetch, preconnect** для приоритизации ресурсов
- **Архитектурные оптимизации**:
  - **Server-side rendering (SSR)** для быстрой отрисовки первого экрана
  - **Static Site Generation (SSG)** для предварительного рендеринга страниц
  - **Code splitting** для загрузки только необходимого кода
  - **Tree shaking** для удаления неиспользуемого кода
- **Мониторинг и измерение**:
  - **Real User Monitoring (RUM)** для отслеживания реальных пользователей
  - **Performance budget** для контроля размера ресурсов
  - **Lighthouse CI** для автоматического контроля производительности

### Как работает виртуализация списков?

- **Принцип работы**:
  - Рендеринг только тех элементов списка, которые находятся в области видимости
  - Остальные элементы не создаются или заменяются заглушками
  - Создание иллюзии полного списка за счет прокручиваемого контейнера
- **Ключевые компоненты**:
  - **Viewport** - видимая область списка
  - **Overscan** - дополнительные элементы выше и ниже видимой области для плавной прокрутки
  - **Row virtualizer** - для одномерных списков
  - **Grid virtualizer** - для двумерных сеток
- **Техническая реализация**:
  - Отслеживание позиции скролла
  - Расчет видимого диапазона элементов
  - Применение трансформаций (transform: translateY) для позиционирования
  - Динамическое создание/удаление DOM-элементов при прокрутке
- **Преимущества**:
  - Значительное снижение количества DOM-узлов
  - Улучшение производительности рендеринга
  - Уменьшение потребления памяти
  - Плавная прокрутка даже для списков с тысячами элементов
- **Популярные библиотеки**:
  - react-window и react-virtualized для React
  - vue-virtual-scroller для Vue
  - ngx-virtual-scroller для Angular
  - ванильный JavaScript с Intersection Observer API

### Что такое code splitting и lazy loading?

- **Code Splitting**:

  - **Определение**: Разделение кода приложения на множество меньших файлов (чанков)
  - **Цель**: Снижение начального времени загрузки путем загрузки только необходимого кода
  - **Реализация**:
    - **Статический**: через импорты/экспорты ES модулей
    - **Динамический**: через `import()` для загрузки модулей по требованию
    - **На основе маршрутов**: разделение по страницам приложения
    - **На основе компонентов**: выделение редко используемых компонентов
  - **Поддержка**: Webpack, Rollup, Vite, инструменты современных фреймворков

- **Lazy Loading**:

  - **Определение**: Отложенная загрузка ресурсов до момента, когда они действительно понадобятся
  - **Применение**:
    - **Изображения**: Загрузка изображений только при приближении к области видимости
    - **Компоненты**: Загрузка компонентов при необходимости их отображения
    - **Маршруты**: Загрузка кода страницы только при переходе на нее
  - **Реализация**:
    - **Для изображений**: `loading="lazy"` в HTML или Intersection Observer API
    - **Для JS/React**: `React.lazy()` и `Suspense`
    - **Для Vue**: `defineAsyncComponent` или `<Suspense>`
    - **Для Angular**: `loadChildren` с маршрутизацией

- **Связь между ними**:

  - Code splitting создает техническую возможность для lazy loading
  - Lazy loading использует code splitting для загрузки ресурсов по требованию
  - Вместе они значительно улучшают производительность первоначальной загрузки

- **Преимущества**:
  - Ускорение TTI (Time to Interactive)
  - Снижение размера начального бандла
  - Приоритизация критически важного контента
  - Эффективное использование кэширования браузера

## Сетевые аспекты

### Что происходит при вводе URL в адресную строку браузера?

1. **Ввод URL и парсинг**:

   - Пользователь вводит URL в адресную строку
   - Браузер парсит URL на компоненты (протокол, домен, путь, параметры)
   - Если протокол не указан, добавляется http:// или https://
   - Браузер проверяет HSTS (HTTP Strict Transport Security) список для принудительного использования HTTPS

2. **DNS-резолвинг**:

   - Проверка DNS-кэша браузера, операционной системы и файла hosts
   - Запрос к DNS-серверу для преобразования доменного имени в IP-адрес
   - Процесс может включать рекурсивные запросы через несколько DNS-серверов

3. **Установление соединения**:

   - TCP handshake (трёхстороннее рукопожатие): SYN, SYN-ACK, ACK
   - Для HTTPS: дополнительное TLS/SSL рукопожатие (обмен сертификатами, согласование шифрования)

4. **HTTP-запрос**:

   - Формирование HTTP-запроса с заголовками (User-Agent, Accept, Cookie и др.)
   - Отправка запроса на сервер по установленному соединению

5. **Обработка на сервере**:

   - Сервер получает и обрабатывает запрос
   - Генерирует HTTP-ответ с кодом статуса, заголовками и телом ответа

6. **Получение ответа**:

   - Браузер начинает получать данные, часто ещё до завершения загрузки
   - Проверка заголовков ответа (статус, тип контента, инструкции по кэшированию)

7. **Рендеринг страницы**:

   - Парсинг HTML и построение DOM
   - Обнаружение и загрузка дополнительных ресурсов (CSS, JavaScript, изображения)
   - Построение CSSOM, выполнение JavaScript
   - Формирование Render Tree, Layout, Paint, Composite

8. **Пост-загрузочные действия**:
   - Выполнение отложенных скриптов
   - Загрузка ресурсов по требованию (lazy loading)
   - Предварительная загрузка ресурсов для ускорения навигации (prefetching)

### Разница между HTTP/1.1, HTTP/2 и HTTP/3

#### HTTP/1.1

- **Текстовый протокол** с человекочитаемыми заголовками
- **Проблема блокировки head-of-line** (HOL): запросы обрабатываются последовательно
- **Ограничение на количество соединений** к одному домену (обычно 6-8)
- **Оптимизации**:
  - Постоянные соединения (keep-alive)
  - Сжатие заголовков (но неэффективное)
  - Поддержка частичной загрузки (range requests)

#### HTTP/2

- **Бинарный протокол** вместо текстового, более эффективный парсинг
- **Мультиплексирование**: множество запросов/ответов через одно TCP-соединение
- **Server Push**: сервер может отправлять ресурсы клиенту до их запроса
- **Эффективное сжатие заголовков** (HPACK)
- **Приоритизация потоков**: возможность указывать важность запросов
- **Проблемы**:
  - Все еще использует TCP, сохраняется проблема HOL на уровне транспорта
  - Практически требует HTTPS (хотя формально возможен и поверх HTTP)

#### HTTP/3

- **Использует QUIC** вместо TCP (на базе UDP)
- **Встроенное шифрование**: TLS 1.3 встроен в протокол
- **Улучшенная производительность** для нестабильных соединений
- **Независимая доставка потоков**: устраняет проблему HOL на транспортном уровне
- **Быстрое установление соединения** (0-RTT или 1-RTT)
- **Миграция соединений**: сохранение сессии при смене IP или сети
- **Преимущества**:
  - Меньшая задержка при установлении соединения
  - Лучшая работа в мобильных сетях
  - Устойчивость к потере пакетов

### Что такое CORS и как он работает?

- **Определение**: Cross-Origin Resource Sharing (совместное использование ресурсов между разными источниками)
- **Проблема**: Same-Origin Policy (политика одного источника) запрещает веб-страницам делать запросы к другим доменам
- **Решение**: CORS позволяет серверу явно разрешить кросс-доменные запросы

#### Механизм работы CORS:

1. **Простые запросы** (GET, POST с определенными Content-Type):

   - Браузер добавляет заголовок `Origin` с источником запроса
   - Сервер отвечает с заголовком `Access-Control-Allow-Origin`
   - Если Origin отсутствует в разрешенных, браузер блокирует ответ

2. **Предварительные запросы** (preflight, для сложных запросов):

   - Браузер сначала отправляет OPTIONS-запрос для проверки разрешений
   - Содержит заголовки: `Origin`, `Access-Control-Request-Method`, `Access-Control-Request-Headers`
   - Сервер должен ответить с заголовками разрешений:
     - `Access-Control-Allow-Origin`
     - `Access-Control-Allow-Methods`
     - `Access-Control-Allow-Headers`
     - `Access-Control-Max-Age` (время кэширования preflight)
   - Только после успешного preflight отправляется основной запрос

3. **Куки и авторизация**:
   - По умолчанию CORS не отправляет куки и заголовки авторизации
   - Для их отправки требуется:
     - На клиенте: установка `withCredentials: true`
     - На сервере: заголовок `Access-Control-Allow-Credentials: true`
     - `Access-Control-Allow-Origin` не может быть "\*", должен указывать конкретный домен

### Объясните принцип работы кэширования в браузере

- **Цель кэширования**: ускорение загрузки, снижение нагрузки на сервер, работа в офлайн-режиме
- **Типы кэширования**:
  1. **HTTP-кэширование** (через заголовки)
  2. **Service Worker** кэш (программное кэширование)
  3. **Memory cache** (в памяти браузера)
  4. **Disk cache** (на жестком диске)

#### HTTP-кэширование:

- **Контроль через заголовки ответа**:

  - `Cache-Control`: основной механизм управления кэшем
    - `max-age=<seconds>`: время жизни кэша
    - `no-cache`: проверка актуальности при каждом запросе
    - `no-store`: запрет кэширования
    - `public`/`private`: доступ к кэшу
    - `must-revalidate`: обязательная проверка при истечении срока
  - `Expires`: устаревший способ, указывает точную дату истечения
  - `ETag`: уникальный идентификатор версии ресурса
  - `Last-Modified`: дата последнего изменения ресурса

- **Процесс валидации кэша**:
  1. Проверка `Cache-Control` и `Expires`
  2. При необходимости валидации:
     - Отправка запроса с `If-None-Match` (ETag) или `If-Modified-Since`
     - Сервер возвращает 304 Not Modified (без тела) или 200 OK с новыми данными

#### Service Worker кэширование:

- Программный контроль над кэшированием через JavaScript API
- Стратегии кэширования:
  - **Cache First**: сначала кэш, затем сеть
  - **Network First**: сначала сеть, затем кэш (при ошибке)
  - **Stale-While-Revalidate**: кэш + обновление в фоне
  - **Cache Only** / **Network Only**

#### Приватный и общий кэш:

- **Приватный кэш**: только для одного пользователя (браузер)
- **Общий кэш**: для нескольких пользователей (прокси, CDN)
- Управление через директивы `public`, `private` в `Cache-Control`

### Что такое CSP (Content Security Policy)?

- **Определение**: Механизм безопасности, который позволяет сайтам контролировать, откуда могут загружаться ресурсы
- **Цель**: Предотвращение атак типа XSS (межсайтовый скриптинг) и инъекций данных

#### Реализация CSP:

- **Через HTTP-заголовок**: `Content-Security-Policy`
- **Через мета-тег**: `<meta http-equiv="Content-Security-Policy" content="...">`

#### Основные директивы CSP:

- **`default-src`**: Политика по умолчанию для всех типов ресурсов
- **`script-src`**: Ограничения для JavaScript
- **`style-src`**: Ограничения для CSS
- **`img-src`**: Ограничения для изображений
- **`connect-src`**: Ограничения для fetch, XHR, WebSocket
- **`font-src`**: Ограничения для шрифтов
- **`frame-src`**: Ограничения для фреймов
- **`object-src`**: Ограничения для плагинов (Flash, Java)
- **`media-src`**: Ограничения для аудио и видео

#### Значения директив:

- **`'self'`**: Только с того же источника
- **`'none'`**: Запрет загрузки ресурсов
- **`'unsafe-inline'`**: Разрешение инлайн-кода (не рекомендуется)
- **`'unsafe-eval'`**: Разрешение использования eval() (не рекомендуется)
- **`'nonce-<value>'`**: Разрешение для конкретного nonce
- **`'<hash-algorithm>-<hash>'`**: Разрешение по хешу содержимого

#### Отчеты о нарушениях:

- **`report-uri`** или **`report-to`**: URL для отправки отчетов о нарушениях
- **Режим отчетности**: `Content-Security-Policy-Report-Only` для тестирования без блокировки

#### Примеры политик:

- Строгая политика: `default-src 'self'; script-src 'self'; object-src 'none'`
- С CDN: `default-src 'self'; script-src 'self' https://cdn.example.com`
- Только отчеты: `Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-violation-report`

## Безопасность

### Что такое XSS и как от него защититься?

- **Определение**: Cross-Site Scripting (XSS) - уязвимость, позволяющая атакующему внедрить вредоносный код на веб-страницу
- **Типы XSS**:

  - **Отраженный XSS**: Инъекция кода через запрос, который отражается на странице (например, через параметры URL)
  - **Хранимый XSS**: Вредоносный код сохраняется на сервере (например, в базе данных) и выводится при просмотре страницы другими пользователями
  - **DOM-based XSS**: Атака через манипуляцию с DOM-структурой, когда JavaScript-код использует небезопасные источники данных

- **Способы защиты**:
  - **Экранирование вывода**: Преобразование спецсимволов (`<`, `>`, `&`, `"`, `'`) в соответствующие HTML-сущности
  - **Валидация входных данных**: Проверка формата и очистка пользовательского ввода на сервере
  - **Content Security Policy (CSP)**: Ограничение источников, откуда могут загружаться скрипты
  - **HTTP-заголовок X-XSS-Protection**: Активация встроенной в браузер защиты от XSS
  - **Использование современных фреймворков**: React, Angular, Vue автоматически экранируют вывод
  - **HttpOnly cookies**: Предотвращение доступа к куки из JavaScript, защита сессий
  - **Sanitizing HTML**: Очистка HTML от потенциально опасных элементов и атрибутов
  - **DOMPurify**: Специализированная библиотека для очистки HTML от вредоносного кода

### Что такое CSRF и методы защиты?

- **Определение**: Cross-Site Request Forgery (CSRF) - атака, принуждающая аутентифицированного пользователя выполнить нежелательное действие на сайте, где он уже авторизован

- **Механизм атаки**:

  1. Пользователь авторизуется на легитимном сайте (например, банке)
  2. Сессия сохраняется в куки
  3. Пользователь посещает вредоносный сайт, который содержит форму или скрипт
  4. Вредоносный код отправляет запрос на легитимный сайт, куки пользователя отправляются автоматически
  5. Легитимный сайт обрабатывает запрос, считая его действительным

- **Методы защиты**:
  - **CSRF-токены**: Уникальные, одноразовые значения, которые должны присутствовать в каждом запросе
    - Токен генерируется сервером и передается клиенту (часто как скрытое поле формы)
    - Атакующий не может знать токен, что предотвращает подделку запросов
  - **SameSite cookies**: Атрибут куки, ограничивающий отправку куки при кросс-доменных запросах
    - `SameSite=Strict`: Отправка куки только при переходе с того же домена
    - `SameSite=Lax`: Отправка куки при переходе с других доменов, но не при запросах
    - `SameSite=None`: Отправка куки в любых запросах (должен использоваться с Secure)
  - **Проверка заголовка Origin/Referer**: Проверка источника запроса на сервере
  - **Double Submit Cookie**: Отправка токена одновременно в куки и в теле запроса
  - **Custom Headers**: Добавление пользовательских заголовков в AJAX-запросы, которые не могут быть установлены при простом кросс-доменном запросе

### Как работает HTTPS?

- **Определение**: HTTPS (HTTP Secure) - протокол передачи данных, обеспечивающий шифрование HTTP-соединений
- **Технологии**: Использует HTTP поверх TLS (Transport Layer Security) или SSL (устаревший)

- **Механизм работы**:

  1. **Установление соединения и рукопожатие (handshake)**:

     - Клиент инициирует соединение и отправляет список поддерживаемых шифров (cipher suites)
     - Сервер выбирает шифр и отправляет свой сертификат с открытым ключом
     - Клиент проверяет валидность сертификата через центры сертификации (CA)
     - Клиент генерирует симметричный ключ сессии, шифрует его открытым ключом сервера и отправляет серверу
     - Сервер расшифровывает ключ сессии своим закрытым ключом
     - Теперь оба имеют общий симметричный ключ для шифрования сессии

  2. **Шифрованный обмен данными**:
     - Все последующие данные шифруются симметричным ключом сессии
     - При необходимости ключ сессии периодически обновляется

- **Компоненты безопасности**:

  - **Аутентификация**: Проверка подлинности сервера через сертификаты
  - **Конфиденциальность**: Шифрование данных для предотвращения перехвата
  - **Целостность**: Защита от изменения данных при передаче

- **Преимущества HTTPS**:
  - Защита от атак "человек посередине" (MITM)
  - Защита конфиденциальных данных (пароли, личная информация, платежи)
  - Влияние на SEO (Google отдает предпочтение HTTPS-сайтам)
  - Возможность использования современных API (geolocation, push notifications и т.д.)

### Что такое subresource integrity?

- **Определение**: Subresource Integrity (SRI) - механизм, позволяющий проверить, что ресурсы, загружаемые с внешних источников, не были изменены
- **Цель**: Защита от атак через компрометацию CDN или сторонних скриптов

- **Механизм работы**:

  1. Генерация криптографического хеша содержимого файла (обычно SHA-256, SHA-384 или SHA-512)
  2. Добавление атрибута `integrity` к тегу `<script>` или `<link>` с указанием алгоритма и хеша
  3. Браузер загружает ресурс и вычисляет его хеш
  4. Если вычисленный хеш не совпадает с указанным, ресурс блокируется

- **Пример использования**:

  ```html
  <script
    src="https://cdn.example.com/lib.js"
    integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
    crossorigin="anonymous"
  ></script>
  ```

- **Особенности**:

  - Требует атрибут `crossorigin` для ресурсов с других доменов
  - Поддерживается всеми современными браузерами
  - Может использоваться с любыми подресурсами (скрипты, стили, шрифты)
  - Не предотвращает загрузку вредоносного контента, но блокирует его исполнение

- **Ограничения**:
  - При каждом обновлении ресурса нужно обновлять хеш
  - Не работает с динамически подгружаемыми ресурсами через JavaScript
  - Может создавать проблемы при использовании CDN с динамическим контентом

### Объясните принцип Same-Origin Policy

- **Определение**: Same-Origin Policy (политика одного источника) - механизм безопасности, ограничивающий взаимодействие между ресурсами из разных источников
- **Что считается "одним источником"**: Совпадение протокола (http/https), домена и порта

- **Ограничения**:

  - JavaScript из одного источника не может напрямую читать DOM-элементы страницы другого источника
  - AJAX-запросы ограничены тем же источником (без CORS)
  - Cookies и localStorage/sessionStorage доступны только для того же источника

- **Исключения и обходы**:

  - `<script>`, `<img>`, `<link>`, `<video>` и другие теги могут загружать ресурсы с других источников
  - `window.postMessage()` - безопасный способ коммуникации между окнами разных источников
  - CORS - механизм для контролируемого ослабления Same-Origin Policy
  - JSONP - устаревший способ обхода через динамическую загрузку скриптов

- **Примеры разных источников**:

  - `http://example.com` и `https://example.com` - разные (разные протоколы)
  - `https://example.com` и `https://sub.example.com` - разные (разные домены)
  - `https://example.com` и `https://example.com:8080` - разные (разные порты)
  - `https://example.com/page1` и `https://example.com/page2` - одинаковые (разные пути не влияют)

- **Значение для безопасности**:
  - Предотвращает кражу данных с других сайтов
  - Защищает от атак типа CSRF
  - Изолирует потенциально вредоносный код
  - Фундаментальный принцип безопасности веб-приложений

### Permissions Policy (Feature Policy)

- **Определение**: Механизм, позволяющий сайту явно разрешать или запрещать использование браузерных функций и API
- **Цель**: Улучшение безопасности и приватности путем ограничения доступа к мощным API

- **Способы настройки**:

  - Через HTTP-заголовок: `Permissions-Policy: camera=(), microphone=(self)`
  - Через мета-тег: `<meta http-equiv="Permissions-Policy" content="camera=()">`
  - Для iframe через атрибут `allow`: `<iframe allow="camera; microphone" src="...">`

- **Часто ограничиваемые функции**:

  - Доступ к медиа-устройствам (`camera`, `microphone`)
  - Геолокация (`geolocation`)
  - Автоматическое воспроизведение (`autoplay`)
  - Полноэкранный режим (`fullscreen`)
  - Доступ к буферу обмена (`clipboard-read`, `clipboard-write`)
  - Датчики устройства (`accelerometer`, `gyroscope`)

- **Примеры политик**:

  - Запрет использования камеры и микрофона: `camera=(), microphone=()`
  - Разрешение геолокации только для текущего источника: `geolocation=(self)`
  - Разрешение автовоспроизведения для определённых источников: `autoplay=(self https://trusted-site.com)`

- **Значение для безопасности**:
  - Смягчение последствий XSS-атак (ограничение вредоносного кода)
  - Предотвращение отслеживания пользователей третьими сторонами
  - Контроль над поведением встраиваемого контента

### Trusted Types

- **Определение**: API, позволяющий предотвращать DOM-based XSS-атаки на уровне браузера
- **Принцип работы**: Запрет использования небезопасных строковых функций для манипуляций с DOM

- **Проблемные API, защищаемые Trusted Types**:

  - `innerHTML`, `outerHTML`
  - `document.write()`, `document.writeln()`
  - `location` (для изменения URL через JavaScript)
  - `eval()`, `new Function()`
  - Атрибуты обработчиков событий (`onclick` и т.д.)

- **Настройка через CSP**:

  ```
  Content-Security-Policy: require-trusted-types-for 'script'; trusted-types myPolicy;
  ```

- **Создание политик**:

  ```javascript
  const myPolicy = trustedTypes.createPolicy("myPolicy", {
    createHTML: (string) => {
      // Санитизация HTML
      return sanitize(string);
    },
    createScript: (string) => {
      // Валидация JavaScript
      return validateJS(string) ? string : "";
    },
    createScriptURL: (string) => {
      // Проверка URL источника скрипта
      return /^https:\/\/trusted\.com\//.test(string) ? string : "";
    },
  });

  // Безопасное использование
  element.innerHTML = myPolicy.createHTML("<p>Текст</p>");
  ```

- **Преимущества**:
  - Предотвращение XSS на уровне платформы
  - Централизованная обработка потенциально опасного ввода
  - Повышенная безопасность критичных приложений

### Referrer Policy

- **Определение**: Механизм управления информацией, передаваемой в заголовке `Referer` при переходах между страницами
- **Значение для безопасности**: Предотвращение утечки чувствительной информации в URL

- **Способы настройки**:

  - HTTP-заголовок: `Referrer-Policy: strict-origin-when-cross-origin`
  - HTML-атрибут: `<a referrerpolicy="no-referrer" href="...">`
  - HTML мета-тег: `<meta name="referrer" content="origin">`

- **Основные политики**:

  - `no-referrer`: Не отправлять Referer
  - `no-referrer-when-downgrade`: Не отправлять при переходе с HTTPS на HTTP
  - `origin`: Отправлять только источник (без пути и параметров)
  - `origin-when-cross-origin`: Полный Referer для того же источника, только источник для других
  - `same-origin`: Отправлять только для того же источника
  - `strict-origin`: Только источник, не отправлять при переходе с HTTPS на HTTP
  - `strict-origin-when-cross-origin`: Комбинация строгости для кросс-доменных запросов
  - `unsafe-url`: Всегда отправлять полный URL (не рекомендуется)

- **Типичные сценарии использования**:
  - Защита конфиденциальных параметров в URL (токены, идентификаторы сессий)
  - Скрытие внутренней структуры сайта от внешних ресурсов
  - Предотвращение утечки информации при переходе с HTTPS на HTTP

### Iframe Sandbox

- **Определение**: Атрибут для `<iframe>`, создающий изолированную среду выполнения вложенного содержимого
- **Цель**: Ограничение потенциально опасных действий встраиваемого контента

- **Базовое использование**:

  ```html
  <iframe
    src="https://external-content.com"
    sandbox="allow-scripts allow-same-origin"
  ></iframe>
  ```

- **Доступные ограничения (при отсутствии разрешений)**:

  - Блокировка JavaScript
  - Блокировка форм
  - Блокировка всплывающих окон
  - Блокировка API, требующих пользовательского взаимодействия
  - Применение уникального источника (блокировка same-origin доступа)
  - Блокировка автоматического запуска контента (медиа-плееры)

- **Разрешения (tokens)**:

  - `allow-scripts`: Разрешить выполнение JavaScript
  - `allow-forms`: Разрешить отправку форм
  - `allow-same-origin`: Сохранить same-origin для iframe
  - `allow-top-navigation`: Разрешить изменение URL в родительском окне
  - `allow-popups`: Разрешить открытие popup-окон
  - `allow-modals`: Разрешить modal-диалоги
  - `allow-downloads`: Разрешить загрузки
  - `allow-storage-access-by-user-activation`: Разрешить доступ к Storage API при активации пользователем

- **Лучшие практики**:
  - Использовать минимально необходимый набор разрешений
  - Никогда не комбинировать `allow-scripts` и `allow-same-origin` для ненадежного контента
  - Применять дополнительные CSP-ограничения для iframe
  - Использовать атрибут `srcdoc` для полностью контролируемого содержимого

### Безопасность локальных хранилищ

- **Уязвимости localStorage и sessionStorage**:

  - Доступны для JavaScript (уязвимы к XSS)
  - Не имеют срока действия (localStorage)
  - Нет разделения по путям домена
  - Ограничены Same-Origin Policy (не доступны через HTTP-запросы)

- **Защитные меры**:

  - **Не хранить чувствительные данные** (пароли, токены доступа)
  - **Валидация данных** при чтении из хранилища
  - **Шифрование** важных данных перед сохранением
  - **Санитизация** данных перед использованием в DOM
  - **Резервное копирование** критичных данных на сервере

- **Безопасность Cookies vs Local Storage**:

  - **Cookies**:
    - Могут быть отмечены как `HttpOnly` (недоступны для JavaScript)
    - Имеют ограничения `Secure` (только HTTPS) и `SameSite`
    - Автоматически отправляются с запросами
    - Имеют срок действия
  - **Local Storage**:
    - Больший объем хранения (5MB vs ~4KB)
    - Не отправляется с запросами автоматически
    - Не имеет дополнительных мер защиты
    - Постоянное хранение без срока действия

- **Рекомендации по использованию**:
  - **Cookies**: Для аутентификации и данных сессии (с защитными флагами)
  - **Local Storage**: Для нечувствительных пользовательских настроек и кэширования
  - **Session Storage**: Для временных данных в рамках сессии

## DevTools и отладка

### Chrome DevTools: основные панели и их применение

- **Elements**: Инспектирование и модификация DOM и CSS

  - **DOM-дерево**: Просмотр структуры страницы
  - **Styles**: Редактирование CSS и просмотр наследуемых стилей
  - **Computed**: Вычисленные стили после применения всех правил CSS
  - **Layout**: Модель блока, отступы, границы и размеры
  - **Event Listeners**: Просмотр обработчиков событий
  - **DOM Breakpoints**: Остановка выполнения при изменении DOM

- **Console**: Выполнение JavaScript и просмотр логов

  - **Logging API**: `console.log()`, `console.warn()`, `console.error()`, `console.table()`
  - **Групповые функции**: `console.group()` / `console.groupEnd()`
  - **Профилирование**: `console.time()` / `console.timeEnd()`
  - **Счетчики**: `console.count()`
  - **Условные отображения**: `console.assert()`
  - **Стилизация**: `console.log('%c Текст', 'color: red; font-size: 20px')`

- **Sources**: Отладка JavaScript

  - **Breakpoints**: Обычные, условные, XHR, события
  - **Call Stack**: Стек вызовов
  - **Scope**: Просмотр локальных и глобальных переменных
  - **Watch**: Наблюдение за выражениями
  - **Snippets**: Сохранение и выполнение фрагментов кода
  - **Workspaces**: Редактирование локальных файлов

- **Network**: Анализ сетевых запросов

  - **Таблица запросов**: Все сетевые запросы с их статусами
  - **Waterfall**: Временная диаграмма запросов
  - **Фильтрация**: По типу (XHR, JS, CSS, Img), статусу, домену
  - **Throttling**: Эмуляция медленных соединений
  - **Disable cache**: Отключение кэширования для отладки
  - **Initiator**: Показывает, какой файл инициировал запрос

- **Performance**: Анализ производительности

  - **CPU Profiling**: Анализ затрат процессора
  - **Flame Chart**: Визуализация стека вызовов
  - **Summary**: Сводная статистика по категориям активности
  - **Main Thread**: Детальный анализ задач в основном потоке
  - **Frames**: Анализ отрисовки кадров и FPS

- **Memory**: Анализ использования памяти

  - **Heap Snapshot**: Снимок памяти для анализа объектов
  - **Allocation Instrumentation**: Отслеживание выделения памяти
  - **Allocation Timeline**: Хронология выделения памяти
  - **Обнаружение утечек**: Сравнение снимков памяти

- **Application**: Хранение и PWA

  - **Storage**: Просмотр и редактирование localStorage, sessionStorage, IndexedDB
  - **Cookies**: Просмотр и редактирование cookie
  - **Cache**: Cache Storage API
  - **Manifest**: Анализ Web App Manifest
  - **Service Workers**: Управление Service Workers

- **Security**: Проверка безопасности

  - **Certificates**: Информация о сертификатах
  - **Mixed Content**: Обнаружение смешанного контента (HTTP/HTTPS)
  - **Security Origins**: Проверка источников

- **Lighthouse**: Всесторонний аудит страницы
  - **Performance**: Производительность загрузки и выполнения
  - **Accessibility**: Доступность для пользователей с ограниченными возможностями
  - **Best Practices**: Соответствие лучшим практикам веб-разработки
  - **SEO**: Оптимизация для поисковых систем
  - **Progressive Web App**: Готовность к работе как PWA

### Техники отладки JavaScript

- **Breakpoints и их типы**:

  - **Line Breakpoints**: Остановка на определённой строке кода
  - **Conditional Breakpoints**: `if (count > 5) { ... }`
  - **DOM Breakpoints**: Остановка при изменении DOM
  - **XHR Breakpoints**: Остановка при определённых сетевых запросах
  - **Event Listener Breakpoints**: Остановка на обработчиках событий

- **Управление выполнением**:

  - **Continue**: Продолжение выполнения до следующего breakpoint
  - **Step Over**: Выполнение текущей строки и переход к следующей
  - **Step Into**: Переход внутрь функции
  - **Step Out**: Выход из текущей функции
  - **Deactivate Breakpoints**: Временное отключение всех breakpoints

- **Продвинутые техники**:

  - **debugger;**: Программная остановка выполнения
  - **Логирование объектов**: `console.dir(object)` для интерактивного отображения
  - **Мониторинг изменений**: `monitorEvents(element, ['click', 'focus'])` в консоли
  - **Анализ функций**: `debug(functionName)` для автоматической остановки
  - **Перезапись функций**: `window.fetch = function() { console.log('fetch called'); return originalFetch.apply(this, arguments); }`

- **Отладка асинхронного кода**:
  - **Async/Await Breakpoints**: Остановка на `await` выражениях
  - **Promise Breakpoints**: Отладка цепочек промисов
  - **Async Call Stack**: Просмотр полного стека вызовов для асинхронного кода
  - **Blackboxing**: Игнорирование кода библиотек при отладке

### Профилирование и оптимизация производительности

- **Анализ производительности загрузки**:

  - **Network Panel**: Анализ времени загрузки ресурсов
  - **Coverage Tab**: Определение неиспользуемого JS и CSS
  - **Memory Usage**: Анализ потребления памяти
  - **Waterfall**: Выявление блокирующих ресурсов
  - **Resource Hints**: Проверка preload, prefetch, dns-prefetch

- **Профилирование JavaScript**:

  - **Performance Recording**: Запись активности страницы
  - **Bottom-Up**: Функции с наибольшим собственным временем выполнения
  - **Call Tree**: Иерархическое представление вызовов функций
  - **Event Log**: Хронологический список событий
  - **Optimizations**: Выявление деоптимизаций JIT-компилятора

- **Анализ рендеринга**:

  - **Rendering Tab**: Визуализация перерисовок и layout
  - **Layers Panel**: Анализ композитных слоёв
  - **Paint Flashing**: Подсветка областей перерисовки
  - **Layout Shift Regions**: Области CLS (Cumulative Layout Shift)
  - **FPS Meter**: Отображение текущей частоты кадров

- **Метрики Web Vitals**:
  - **Lighthouse**: Всесторонний аудит метрик
  - **Performance Tab**: Маркеры для LCP, FCP, DCL
  - **Field Data**: Сбор реальных метрик от пользователей
  - **Web Vitals Extension**: Расширение Chrome для оценки метрик
  - **Performance.measure()**: Создание собственных меток для анализа

### Мобильная отладка

- **Remote Debugging**: Отладка на реальных устройствах

  - **Android**: USB-отладка через Chrome
  - **iOS**: Safari Web Inspector для отладки
  - **Chrome DevTools Devices Mode**: Эмуляция мобильных устройств
  - **Chrome Remote Debug**: `chrome://inspect/#devices`

- **Особенности мобильной отладки**:

  - **Touch Events**: Эмуляция сенсорных событий
  - **Throttling**: Эмуляция мобильных сетей (2G, 3G, 4G)
  - **Device Pixel Ratio**: Тестирование на различных плотностях экрана
  - **Emulatе Sensors**: Эмуляция GPS, акселерометра и других датчиков

- **Отладка PWA**:
  - **Offline Mode**: Тестирование в режиме офлайн
  - **Clear Storage**: Сброс данных для чистого тестирования
  - **Service Worker Debugging**: Инспектирование и отладка Service Workers
  - **Manifest Validation**: Проверка корректности manifest.json

### Инструменты командной строки и расширения

- **Browser Extensions for Debugging**:

  - **React Developer Tools**: Инспектирование компонентов React
  - **Redux DevTools**: Отладка состояния Redux
  - **Vue.js DevTools**: Анализ приложений Vue.js
  - **Apollo Client DevTools**: Отладка GraphQL-запросов
  - **Axe**: Проверка доступности

- **Command Line Debugging Tools**:

  - **Lighthouse CLI**: Автоматизированный аудит веб-страниц
  - **WebPageTest**: Тестирование производительности из разных локаций
  - **Puppeteer**: Автоматизация и отладка через Headless Chrome
  - **Cypress**: End-to-end тестирование с визуальной отладкой
  - **Playwright**: Кросс-браузерная автоматизация и отладка

- **Мониторинг в production**:
  - **Error Tracking**: Sentry, LogRocket, TrackJS
  - **Real User Monitoring (RUM)**: New Relic, Datadog
  - **Synthetic Monitoring**: Pingdom, Uptime Robot
  - **Analytics**: Google Analytics, Yandex.Metrica
  - **Custom Error Handlers**: `window.onerror`, `unhandledrejection`

### Особенности DevTools в различных браузерах

- **Chrome DevTools**:

  - Наиболее полный набор инструментов
  - Регулярные обновления с новыми возможностями
  - Протокол Chrome DevTools Protocol для расширений
  - Мощные возможности JavaScript-профилирования

- **Firefox Developer Tools**:

  - Инспектор Flexbox и Grid
  - Отладчик с продвинутым анализом прототипов
  - Shapes Editor для CSS-фигур
  - Inspector для работы с анимациями
  - Уникальный CSS-отладчик

- **Safari Web Inspector**:

  - Отладка iOS Safari и WebKit
  - Таймлайн с детализацией рендеринга
  - Энергопотребление и анализ батареи
  - Оптимизирован для отладки на устройствах Apple

- **Edge DevTools**:
  - Основан на Chromium, схож с Chrome DevTools
  - Интеграция с VS Code
  - Unique 3D View для анализа Z-Index
  - Оптимизация для отладки PWA в Windows

## Современные API и технологии

### Как работают веб-воркеры?

- **Определение**: Web Workers - это JavaScript-скрипты, выполняющиеся в фоновом потоке, отдельном от основного потока браузера
- **Цель**: Выполнение ресурсоемких задач без блокировки UI и повышение производительности многопоточных вычислений

- **Типы веб-воркеров**:

  - **Dedicated Workers**: Используются только одним скриптом
  - **Shared Workers**: Могут совместно использоваться несколькими скриптами (даже из разных окон/фреймов)
  - **Service Workers**: Действуют как прокси между приложением и сетью, используются для кэширования и работы офлайн

- **Особенности и ограничения**:

  - Работают в изолированном контексте без доступа к DOM, объекту window, родительским объектам
  - Общение с основным потоком только через обмен сообщениями (postMessage/onmessage)
  - Имеют доступ к: XMLHttpRequest, Fetch API, setTimeout/setInterval, IndexedDB, WebSockets
  - Не имеют доступа к: DOM API, document, window, parent

- **Пример использования**:

  ```javascript
  // Основной поток
  const worker = new Worker("worker.js");
  worker.postMessage({ data: "Данные для обработки" });
  worker.onmessage = (event) => {
    console.log("Результат:", event.data);
  };

  // worker.js
  self.onmessage = (event) => {
    const result = heavyComputation(event.data);
    self.postMessage(result);
  };
  ```

- **Типичные сценарии использования**:
  - Обработка больших массивов данных
  - Сложные вычисления (шифрование, компрессия, обработка изображений)
  - Кэширование и предварительная загрузка ресурсов
  - Поддержание долгоживущих соединений (WebSockets, Server-Sent Events)

### Что такое WebAssembly и его преимущества?

- **Определение**: WebAssembly (WASM) - бинарный формат инструкций для стековой виртуальной машины, низкоуровневый код, выполняемый в браузере
- **Цель**: Обеспечить высокопроизводительное выполнение кода, написанного на языках, отличных от JavaScript

- **Ключевые особенности**:

  - **Производительность**: Выполняется почти с нативной скоростью
  - **Компактность**: Бинарный формат значительно меньше эквивалентного JavaScript
  - **Предсказуемость**: Детерминированная производительность и меньшие колебания времени выполнения
  - **Безопасность**: Выполняется в изолированной "песочнице" с контролем доступа к ресурсам
  - **Поддержка языков**: C/C++, Rust, C#, Go, AssemblyScript и другие

- **Как это работает**:

  1. Код на языке высокого уровня компилируется в WebAssembly
  2. WebAssembly загружается и инстанцируется в JavaScript
  3. JavaScript и WebAssembly взаимодействуют через общий интерфейс
  4. WebAssembly выполняется в том же потоке, что и JavaScript

- **Преимущества**:

  - **Скорость**: Значительно быстрее JavaScript для вычислительно сложных задач
  - **Повторное использование кода**: Возможность переноса существующих кодовых баз
  - **Оптимизация для конкретных задач**: Игры, редактирование видео, CAD, симуляции
  - **Прогрессивная загрузка**: Возможность потоковой компиляции и выполнения

- **Ограничения**:

  - Нет прямого доступа к DOM (только через JavaScript)
  - Более сложный процесс разработки и отладки
  - Значительные накладные расходы для простых задач

- **Примеры использования**:
  - Игровые движки (Unity, Unreal Engine)
  - Сложные вычисления (обработка медиа, машинное обучение)
  - Порты настольных приложений в веб
  - Криптография и шифрование

### Расскажите о Intersection Observer API

- **Определение**: API для асинхронного наблюдения за пересечением элемента с его родителем или областью просмотра (viewport)
- **Цель**: Эффективное определение видимости элементов без использования scroll-событий и расчетов геометрии

- **Принцип работы**:

  - Создание объекта наблюдателя (observer) с коллбэк-функцией и опциями
  - Регистрация целевых элементов для наблюдения
  - Асинхронный вызов коллбэка при пересечении согласно заданным порогам

- **Основные компоненты**:

  - **IntersectionObserver**: Основной класс для создания наблюдателя
  - **IntersectionObserverEntry**: Объект с информацией о пересечении (target, isIntersecting, intersectionRatio и т.д.)
  - **Root**: Элемент, относительно которого рассчитывается пересечение (null = viewport)
  - **Threshold**: Пороги пересечения (от 0 до 1), при которых срабатывает коллбэк

- **Пример использования**:

  ```javascript
  const options = {
    root: null, // использовать viewport
    rootMargin: "0px", // отступы
    threshold: 0.5, // пересечение на 50%
  };

  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        console.log("Элемент видим", entry.target);
        // например, загрузить изображение или запустить анимацию
        observer.unobserve(entry.target); // прекратить наблюдение
      }
    });
  }, options);

  // Начать наблюдение за элементом
  observer.observe(document.querySelector(".my-element"));
  ```

- **Типичные применения**:

  - **Ленивая загрузка** изображений и медиа
  - **Бесконечная прокрутка** (infinite scroll)
  - **Анимации при прокрутке** (scroll-triggered animations)
  - **Отслеживание видимости рекламы**
  - **Отложенная загрузка контента** (отложенный рендеринг)

- **Преимущества**:
  - **Производительность**: Не блокирует основной поток, нет постоянных вычислений
  - **Простота**: Декларативный API вместо императивных вычислений
  - **Гибкость**: Множество опций конфигурации для разных сценариев

### Как работает WebSockets?

- **Определение**: WebSocket - протокол связи, обеспечивающий полнодуплексную коммуникацию через одно TCP-соединение
- **Особенности**: Двунаправленный, постоянный канал связи между клиентом и сервером

- **Принцип работы**:

  1. **Установление соединения** (handshake):

     - Клиент отправляет HTTP-запрос с заголовками `Upgrade: websocket` и `Connection: Upgrade`
     - Сервер отвечает с кодом 101 (Switching Protocols)
     - После успешного рукопожатия протокол переключается с HTTP на WebSocket

  2. **Обмен данными**:

     - Обе стороны могут отправлять сообщения независимо в любое время
     - Данные передаются в виде фреймов (бинарных или текстовых)
     - Нет необходимости в повторном установлении соединения для каждого сообщения

  3. **Закрытие соединения**:
     - Любая сторона может инициировать закрытие
     - Отправляется специальный frame с кодом закрытия и опциональным сообщением

- **JavaScript API**:

  ```javascript
  // Создание соединения
  const socket = new WebSocket("ws://example.com/socket");

  // Событие открытия соединения
  socket.onopen = (event) => {
    console.log("Соединение установлено");
    socket.send("Привет, сервер!");
  };

  // Получение сообщений
  socket.onmessage = (event) => {
    console.log("Получено:", event.data);
  };

  // Обработка ошибок
  socket.onerror = (error) => {
    console.error("Ошибка WebSocket:", error);
  };

  // Закрытие соединения
  socket.onclose = (event) => {
    console.log("Соединение закрыто", event.code, event.reason);
  };
  ```

- **Сценарии использования**:

  - **Чаты и мессенджеры**: Мгновенный обмен сообщениями
  - **Многопользовательские игры**: Синхронизация игрового состояния
  - **Торговые платформы**: Обновление цен в реальном времени
  - **Коллаборативные инструменты**: Совместное редактирование
  - **Уведомления и обновления**: Получение данных без запроса

- **Преимущества перед HTTP**:

  - **Меньшие накладные расходы**: Нет повторяющихся заголовков для каждого сообщения
  - **Меньшая задержка**: Нет необходимости устанавливать соединение для каждого сообщения
  - **Двунаправленность**: Сервер может инициировать отправку данных
  - **Реальное время**: Данные передаются сразу при их появлении

- **Ограничения и альтернативы**:
  - Некоторые прокси и брандмауэры могут блокировать WebSocket
  - Для случаев, когда WebSocket недоступен: Long Polling, Server-Sent Events (SSE)
  - Потребление ресурсов на сервере при большом количестве одновременных соединений

### Что такое IndexedDB и когда его использовать?

- **Определение**: Низкоуровневое API для хранения больших объемов структурированных данных на стороне клиента
- **Характеристики**: Асинхронное, транзакционное, неблокирующее, объектно-ориентированное хранилище

- **Ключевые концепции**:

  - **База данных**: Контейнер верхнего уровня для хранилищ объектов
  - **Object Store**: Аналог таблицы в реляционных БД
  - **Index**: Дополнительная структура для быстрого поиска по значениям
  - **Transaction**: Атомарная последовательность операций
  - **Cursor**: Механизм для итерации по записям

- **Особенности**:

  - **Асинхронный API**: Не блокирует основной поток
  - **Большой объем хранения**: Обычно несколько сотен МБ, зависит от браузера
  - **Структурированное хранение**: Поддержка сложных объектов и бинарных данных
  - **Поддержка транзакций**: Гарантия целостности данных
  - **Same-origin**: Доступ только из того же источника

- **Пример использования**:

  ```javascript
  // Открытие/создание базы данных
  const request = indexedDB.open("MyDatabase", 1);

  request.onupgradeneeded = (event) => {
    const db = event.target.result;
    // Создание хранилища объектов
    const store = db.createObjectStore("users", { keyPath: "id" });
    // Создание индекса
    store.createIndex("by_name", "name", { unique: false });
  };

  request.onsuccess = (event) => {
    const db = event.target.result;
    // Транзакция для записи данных
    const transaction = db.transaction(["users"], "readwrite");
    const store = transaction.objectStore("users");

    // Добавление данных
    store.add({ id: 1, name: "John", age: 30 });

    // Получение данных
    const getRequest = store.get(1);
    getRequest.onsuccess = () => {
      console.log(getRequest.result);
    };

    transaction.oncomplete = () => {
      db.close();
    };
  };
  ```

- **Когда использовать**:

  - **Офлайн-приложения**: Сохранение данных для работы без интернета
  - **Кэширование данных**: Уменьшение сетевых запросов
  - **Большие наборы данных**: Когда localStorage недостаточно
  - **Персистентность**: Долговременное хранение состояния приложения
  - **Комплексная структура данных**: Хранение связанных объектов

- **Сравнение с другими хранилищами**:

  - **localStorage/sessionStorage**: Проще, но ограничены (5MB), синхронные, только строки
  - **Cookies**: Очень ограничены по размеру (4KB), отправляются с каждым запросом
  - **Cache API**: Предназначен для кэширования HTTP-ответов, часть Service Worker API
  - **WebSQL**: Устаревшая технология, не рекомендуется использовать

- **Ограничения**:
  - Сложный API с большим количеством коллбэков
  - Ограничения в мобильных браузерах
  - Потенциальное удаление данных браузером при нехватке места

## Современные Web API

### Геолокация и определение положения

- **Geolocation API**:

  - Получение географического положения пользователя
  - ```javascript
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        console.log(`Широта: ${latitude}, Долгота: ${longitude}`);
      },
      (error) => console.error("Ошибка геолокации:", error.message),
      { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
    );
    ```
  - Методы для наблюдения за изменением положения:
    ```javascript
    const watchId = navigator.geolocation.watchPosition(
      successCallback,
      errorCallback
    );
    navigator.geolocation.clearWatch(watchId); // для прекращения наблюдения
    ```
  - Ограничения: требует разрешения пользователя, работает только по HTTPS

- **Device Orientation API**:
  - Доступ к данным с гироскопа и акселерометра
  - ```javascript
    window.addEventListener("deviceorientation", (event) => {
      const { alpha, beta, gamma } = event;
      // alpha: поворот вокруг оси Z (0-360)
      // beta: наклон вперед/назад (-180 до 180)
      // gamma: наклон влево/вправо (-90 до 90)
    });
    ```
  - Применение: игры, интерактивные интерфейсы, навигация

### Clipboard API

- **Современный асинхронный API для работы с буфером обмена**:

  - Чтение из буфера обмена:
    ```javascript
    navigator.clipboard
      .readText()
      .then((text) => console.log("Из буфера:", text))
      .catch((err) => console.error("Ошибка:", err));
    ```
  - Запись в буфер обмена:
    ```javascript
    navigator.clipboard
      .writeText("Текст для копирования")
      .then(() => console.log("Скопировано!"))
      .catch((err) => console.error("Ошибка:", err));
    ```
  - Работа с несколькими форматами и бинарными данными:
    ```javascript
    const imageItem = new ClipboardItem({
      "image/png": blob,
    });
    navigator.clipboard.write([imageItem]);
    ```

- **Требования безопасности**:
  - Для `readText()` требуется разрешение пользователя
  - Работает только на страницах, открытых по HTTPS
  - В некоторых браузерах работает только при активной вкладке

### Web Share API

- **Нативный способ поделиться контентом через системные механизмы**:

  ```javascript
  navigator
    .share({
      title: "Отличная статья",
      text: "Проверьте эту важную информацию",
      url: "https://example.com/article",
    })
    .then(() => console.log("Успешно поделились"))
    .catch((error) => console.log("Ошибка:", error));
  ```

- **Web Share Target API**: позволяет веб-приложениям выступать в качестве цели для операции "поделиться"

  - Настройка в manifest.json:
    ```json
    {
      "share_target": {
        "action": "/share-target",
        "method": "GET",
        "params": {
          "title": "title",
          "text": "text",
          "url": "url"
        }
      }
    }
    ```

- **Ограничения**:
  - Может быть вызван только в ответ на действие пользователя (клик)
  - Поддерживается не во всех браузерах (преимущественно мобильные)
  - Требует HTTPS

### File System Access API

- **Прямой доступ к файловой системе пользователя**:

  - Открытие файлов для чтения:
    ```javascript
    const [fileHandle] = await window.showOpenFilePicker();
    const file = await fileHandle.getFile();
    const content = await file.text();
    ```
  - Сохранение файлов:
    ```javascript
    const fileHandle = await window.showSaveFilePicker({
      suggestedName: "my-file.txt",
      types: [
        {
          description: "Text Files",
          accept: { "text/plain": [".txt"] },
        },
      ],
    });
    const writable = await fileHandle.createWritable();
    await writable.write("Содержимое файла");
    await writable.close();
    ```
  - Доступ к директориям:
    ```javascript
    const dirHandle = await window.showDirectoryPicker();
    for await (const entry of dirHandle.values()) {
      console.log(entry.kind, entry.name);
    }
    ```

- **Безопасность**:
  - Требует явных пользовательских действий
  - Предоставляет доступ только к выбранным файлам/папкам
  - Можно запросить "постоянное разрешение" для повторного доступа

### Screen Capture API

- **Захват экрана или отдельных окон**:

  ```javascript
  async function startCapture() {
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          cursor: "always",
        },
        audio: false,
      });

      videoElement.srcObject = stream;
    } catch (err) {
      console.error("Ошибка: " + err);
    }
  }
  ```

- **Применение**:
  - Скринкасты и обучающие видео
  - Видеоконференции с демонстрацией экрана
  - Удаленная техподдержка
  - Захват скриншотов из потока:
    ```javascript
    const videoTrack = stream.getVideoTracks()[0];
    const imageCapture = new ImageCapture(videoTrack);
    const bitmap = await imageCapture.grabFrame();
    const canvas = document.createElement("canvas");
    canvas.width = bitmap.width;
    canvas.height = bitmap.height;
    const context = canvas.getContext("2d");
    context.drawImage(bitmap, 0, 0);
    ```

### Payment Request API

- **Упрощение процесса оплаты в веб-приложениях**:

  ```javascript
  const paymentRequest = new PaymentRequest(
    [
      {
        supportedMethods: "basic-card",
        data: {
          supportedNetworks: ["visa", "mastercard"],
          supportedTypes: ["debit", "credit"],
        },
      },
    ],
    {
      total: {
        label: "Общая сумма",
        amount: { currency: "RUB", value: "1000.00" },
      },
    }
  );

  try {
    const paymentResponse = await paymentRequest.show();
    // Обработка платежа на сервере
    await paymentResponse.complete("success");
  } catch (err) {
    console.error("Ошибка оплаты:", err);
  }
  ```

- **Преимущества**:
  - Унифицированный интерфейс оплаты
  - Хранение платежной информации в браузере
  - Поддержка различных способов оплаты
  - Снижение количества ошибок при вводе данных

### Drag and Drop API

- **Нативный механизм перетаскивания элементов**:

  - Настройка перетаскиваемого элемента:

    ```javascript
    element.setAttribute("draggable", "true");
    element.addEventListener("dragstart", (event) => {
      event.dataTransfer.setData("text/plain", event.target.id);
      event.dataTransfer.effectAllowed = "move";
    });
    ```

  - Настройка целевой области:

    ```javascript
    dropzone.addEventListener("dragover", (event) => {
      event.preventDefault(); // Необходимо для разрешения сброса
      event.dataTransfer.dropEffect = "move";
    });

    dropzone.addEventListener("drop", (event) => {
      event.preventDefault();
      const id = event.dataTransfer.getData("text/plain");
      const draggableElement = document.getElementById(id);
      dropzone.appendChild(draggableElement);
    });
    ```

  - События жизненного цикла drag-and-drop:
    - `dragstart`: начало перетаскивания
    - `drag`: процесс перетаскивания
    - `dragenter`: вход в целевую область
    - `dragover`: перемещение над целевой областью
    - `dragleave`: выход из целевой области
    - `drop`: сброс элемента
    - `dragend`: завершение операции перетаскивания

- **Расширенные возможности**:

  - Перетаскивание файлов с компьютера пользователя:

    ```javascript
    dropzone.addEventListener("drop", (event) => {
      event.preventDefault();

      if (event.dataTransfer.items) {
        for (const item of event.dataTransfer.items) {
          if (item.kind === "file") {
            const file = item.getAsFile();
            console.log(`Файл ${file.name}, размер ${file.size}`);
          }
        }
      }
    });
    ```

  - Drag-and-drop API можно комбинировать с File System Access API для мощных интерфейсов

### Notifications API

- **Отображение системных уведомлений пользователю**:

  ```javascript
  // Запрос разрешения (должен быть вызван по событию пользователя)
  Notification.requestPermission().then((permission) => {
    if (permission === "granted") {
      // Создание уведомления
      const notification = new Notification("Новое сообщение", {
        body: "Вы получили новое сообщение от пользователя",
        icon: "/path/to/icon.png",
        badge: "/path/to/badge.png",
        vibrate: [200, 100, 200],
      });

      // Обработка кликов
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    }
  });
  ```

- **Интеграция с Service Worker**:

  ```javascript
  self.registration.showNotification("Фоновое уведомление", {
    body: "Это уведомление отправлено через Service Worker",
    icon: "/icon.png",
    actions: [
      { action: "view", title: "Просмотр" },
      { action: "close", title: "Закрыть" },
    ],
  });

  self.addEventListener("notificationclick", (event) => {
    if (event.action === "view") {
      clients.openWindow("/messages");
    }
    event.notification.close();
  });
  ```

### Web Bluetooth, USB и Serial API

- **Web Bluetooth API**: взаимодействие с Bluetooth-устройствами

  ```javascript
  navigator.bluetooth
    .requestDevice({
      filters: [{ services: ["battery_service"] }],
    })
    .then((device) => device.gatt.connect())
    .then((server) => server.getPrimaryService("battery_service"))
    .then((service) => service.getCharacteristic("battery_level"))
    .then((characteristic) => characteristic.readValue())
    .then((value) => {
      const batteryLevel = value.getUint8(0);
      console.log(`Уровень заряда: ${batteryLevel}%`);
    })
    .catch((error) => console.log(`Ошибка: ${error}`));
  ```

- **Web USB API**: доступ к USB-устройствам

  ```javascript
  navigator.usb
    .requestDevice({ filters: [{ vendorId: 0x1234 }] })
    .then((device) => {
      console.log(device.productName);
      return device.open();
    })
    .then((device) => device.selectConfiguration(1))
    .then((device) => device.claimInterface(0))
    .then((device) => device.transferOut(1, data));
  ```

- **Web Serial API**: коммуникация с устройствами через последовательный порт
  ```javascript
  navigator.serial
    .requestPort()
    .then((port) => port.open({ baudRate: 9600 }))
    .then((port) => {
      const writer = port.writable.getWriter();
      const data = new Uint8Array([104, 101, 108, 108, 111]); // "hello"
      return writer.write(data);
    });
  ```

### Другие важные Web API

- **Web Audio API**: обработка и синтез звука

  ```javascript
  const audioContext = new AudioContext();
  const oscillator = audioContext.createOscillator();
  oscillator.type = "sine";
  oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // Нота A
  oscillator.connect(audioContext.destination);
  oscillator.start();
  setTimeout(() => oscillator.stop(), 2000); // Звук на 2 секунды
  ```

- **Web Speech API**: распознавание и синтез речи

  ```javascript
  // Синтез речи
  const speech = new SpeechSynthesisUtterance("Привет, как дела?");
  speech.lang = "ru-RU";
  speechSynthesis.speak(speech);

  // Распознавание речи
  const recognition = new SpeechRecognition();
  recognition.lang = "ru-RU";
  recognition.start();
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    console.log(`Распознано: ${transcript}`);
  };
  ```

- **Credential Management API**: управление учетными данными

  ```javascript
  // Сохранение учетных данных
  navigator.credentials.store(
    new PasswordCredential({
      id: "user@example.com",
      password: "strong-password",
      name: "John Doe",
    })
  );

  // Автоматический вход
  navigator.credentials.get({ password: true }).then((cred) => {
    if (cred) {
      // Выполнить вход с использованием cred.id и cred.password
    }
  });
  ```

- **Media Session API**: управление медиа в системе

  ```javascript
  navigator.mediaSession.metadata = new MediaMetadata({
    title: "Название трека",
    artist: "Исполнитель",
    album: "Альбом",
    artwork: [{ src: "album-art.png", sizes: "256x256", type: "image/png" }],
  });

  navigator.mediaSession.setActionHandler("play", () => {
    audio.play();
  });
  navigator.mediaSession.setActionHandler("pause", () => {
    audio.pause();
  });
  ```

## Кросс-браузерность

### Как обеспечить поддержку разных браузеров?

- **Стратегический подход**:

  - **Progressive Enhancement**: Сначала базовая функциональность, затем улучшения
  - **Graceful Degradation**: Разработка современных функций с запасными вариантами
  - **Определение целевых браузеров**: Установка минимальных версий для поддержки

- **Приёмы в CSS**:

  - **Нормализация/сброс стилей**: normalize.css или reset.css для унификации базовых стилей
  - **Префиксы вендоров**: `-webkit-`, `-moz-`, `-ms-` для экспериментальных свойств
  - **Feature Queries**: `@supports` для проверки поддержки свойств
  - **Flexbox/Grid с запасными вариантами**: float-системы в качестве fallback
  - **CSS-переменные с fallback**: `var(--color, #default)`

- **Приёмы в JavaScript**:

  - **Feature Detection**: Проверка наличия функциональности вместо определения браузера
  - **Полифиллы и транспиляция**: Babel, core-js для совместимости нового синтаксиса
  - **Изоляция проблемных участков кода**: Обёртки для разных реализаций
  - **Прогрессивное улучшение функциональности**: Базовая версия для всех, расширенная для современных браузеров

- **Инструменты сборки**:

  - **Autoprefixer**: Автоматическое добавление префиксов
  - **Babel**: Транспиляция современного JS в поддерживаемый
  - **Browserslist**: Конфигурация целевых браузеров для инструментов
  - **PostCSS**: Трансформация CSS для совместимости

- **Пример конфигурации Browserslist**:
  ```json
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead",
    "not IE 11"
  ]
  ```

### Что такое полифиллы и когда их использовать?

- **Определение**: Полифилл (polyfill) - код, который добавляет функциональность, отсутствующую в старых браузерах, но присутствующую в современных стандартах
- **Отличие от шима (shim)**: Полифилл точно имитирует стандартный API, шим может предоставлять альтернативный интерфейс

- **Когда использовать**:

  - При необходимости поддержки устаревших браузеров
  - Для использования современных API в проектах с широкой аудиторией
  - В случаях, когда нужно обеспечить плавный переход к новым стандартам
  - Когда транспиляция синтаксиса (Babel) недостаточна для полной совместимости

- **Типы полифиллов**:

  - **Для языковых возможностей**: `Promise`, `Array.prototype.includes`, `Object.assign`
  - **Для браузерных API**: `fetch`, `IntersectionObserver`, `ResizeObserver`
  - **Для веб-компонентов**: Custom Elements, Shadow DOM
  - **Для CSS**: CSS Variables, Grid Layout

- **Подходы к использованию**:
  - **Ручное добавление**: Внедрение только необходимых полифиллов
  - **Автоматическое определение**: Библиотеки, определяющие и загружающие нужные полифиллы
  - **Условная загрузка**: Загрузка полифиллов только для браузеров, которым они нужны
- **Популярные решения**:

  - **core-js**: Наиболее полная библиотека полифиллов для JavaScript
  - **polyfill.io**: Сервис, автоматически определяющий и отдающий нужные полифиллы
  - **@babel/preset-env**: Интеграция с Babel для добавления только необходимых полифиллов
  - **whatwg-fetch**: Полифилл для Fetch API

- **Пример использования**:

  ```javascript
  // Условная загрузка полифилла
  if (!window.fetch) {
    import("whatwg-fetch").then(() => {
      // Fetch API теперь доступен
    });
  }

  // Или с polyfill.io
  <script src="https://polyfill.io/v3/polyfill.min.js?features=fetch"></script>;
  ```

### Как тестировать кросс-браузерную совместимость?

- **Методологии тестирования**:

  - **Ручное тестирование**: Проверка в различных браузерах на реальных устройствах
  - **Автоматизированное тестирование**: Использование средств автоматизации
  - **Регрессионное тестирование**: Проверка новых изменений на совместимость
  - **Визуальное тестирование**: Сравнение скриншотов для выявления различий рендеринга

- **Инструменты ручного тестирования**:

  - **Реальные устройства**: Физические устройства с различными ОС и браузерами
  - **Виртуальные машины**: VirtualBox, VMware для запуска разных ОС
  - **Browser Stack, LambdaTest, Sauce Labs**: Доступ к браузерам в облаке
  - **DevTools**: Режим эмуляции мобильных устройств (в Chrome, Firefox)

- **Инструменты автоматизированного тестирования**:

  - **Selenium WebDriver**: Кросс-браузерная автоматизация
  - **Cypress**: Тестирование на основных браузерах
  - **Playwright**: Поддержка всех современных движков рендеринга
  - **Jest + Puppeteer**: Интеграция для тестирования в headless-браузерах

- **Визуальное регрессионное тестирование**:

  - **BackstopJS**: Сравнение скриншотов
  - **Percy**: Облачное решение для визуального тестирования
  - **Chromatic**: Для приложений на Storybook
  - **Applitools Eyes**: Тестирование с использованием AI

- **Интеграция в CI/CD**:

  - Автоматические тесты при каждом коммите
  - Матрица тестирования для разных комбинаций браузеров
  - Настройка репортинга об ошибках совместимости
  - Блокировка деплоя при наличии проблем совместимости

- **Чек-лист тестирования**:
  - Верстка и отображение (размеры, позиции, цвета)
  - Работа JavaScript-функциональности
  - Валидация форм и пользовательский ввод
  - Производительность и скорость загрузки
  - Доступность (a11y) в различных браузерах

### Какие инструменты помогают в разработке кросс-браузерных приложений?

- **Инструменты сборки и транспиляции**:

  - **Webpack, Vite, Rollup**: Модульная сборка, минификация, tree-shaking
  - **Babel**: Транспиляция JavaScript в поддерживаемый формат
  - **PostCSS**: Трансформация CSS с плагинами для совместимости
  - **Autoprefixer**: Автоматическое добавление вендорных префиксов

- **CSS-фреймворки и нормализаторы**:

  - **normalize.css, reset.css**: Нормализация стилей между браузерами
  - **Bootstrap, Tailwind CSS**: Фреймворки с готовыми кросс-браузерными компонентами
  - **styled-components, Emotion**: CSS-in-JS с автоматическими префиксами

- **JavaScript-фреймворки и библиотеки**:

  - **React, Vue, Angular**: Абстракция над DOM с внутренней обработкой различий
  - **jQuery**: Исторически для решения кросс-браузерных проблем
  - **Modernizr**: Определение поддержки функций в браузере
  - **core-js, polyfill.io**: Полифиллы для современных функций

- **Системы анализа и мониторинга**:

  - **CanIUse**: База данных поддержки функций в браузерах
  - **Browserslist**: Спецификация целевых браузеров
  - **Lighthouse, WebPageTest**: Проверка производительности
  - **Error tracking (Sentry, LogRocket)**: Мониторинг ошибок в разных браузерах

- **Инструменты для тестирования**:

  - **BrowserStack, LambdaTest, Sauce Labs**: Платформы для тестирования в разных браузерах
  - **Cypress, Playwright, Selenium**: Автоматизация тестирования
  - **Ghost Inspector, Percy, BackstopJS**: Визуальное регрессионное тестирование

- **Интегрированные среды разработки (IDE)**:

  - **VSCode с плагинами**: ESLint, Stylelint для проверки совместимости
  - **JetBrains WebStorm**: Встроенная проверка совместимости
  - **Расширения браузеров**: DevTools, React/Redux DevTools, Vue DevTools

- **Сервисы для проверки совместимости**:
  - **Google PageSpeed Insights**: Проверка мобильной совместимости
  - **Browserling**: Интерактивное кросс-браузерное тестирование
  - **HTML/CSS/JS Validators**: W3C, JSHint, CSSLint

### Особенности мобильных браузеров и отличия от десктопных

- **Ключевые отличия**:

  - **Размер экрана**: Меньшие дисплеи требуют адаптивного дизайна
  - **Сенсорный ввод**: Touch вместо mouse-событий
  - **Производительность**: Обычно менее мощное железо
  - **Сетевое соединение**: Потенциально нестабильное, с ограниченным трафиком
  - **Контекст использования**: На ходу, при различном освещении, в разных условиях

- **Технические особенности**:

  - **Viewport**: Необходимость настройки через meta-теги
    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    ```
  - **Пиксельная плотность**: Физические пиксели vs CSS-пиксели (device pixel ratio)
  - **Hover-состояния**: Отсутствуют или ведут себя иначе в touch-интерфейсах
  - **Клавиатура**: Виртуальная клавиатура влияет на доступное пространство экрана
  - **Обработчики событий**: `touchstart`, `touchmove`, `touchend` вместо mouse-событий
  - **Инерционная прокрутка**: `-webkit-overflow-scrolling: touch`

- **Оптимизация производительности**:

  - **Оптимизация размера ресурсов**: Меньшие изображения, минификация кода
  - **Минимизация сетевых запросов**: Объединение ресурсов, спрайты
  - **Эффективный рендеринг**: Избегание expensive операций для DOM
  - **Оптимизация анимаций**: Использование transform и opacity вместо изменения геометрии
  - **Lazy loading**: Загрузка ресурсов по мере необходимости

- **Особенности различных мобильных браузеров**:

  - **iOS Safari**:
    - Ограничения в WebView (PWA, Service Workers в iOS <14)
    - Нестандартное поведение position: fixed при скролле
    - Ограничения localStorage в приватном режиме
  - **Android Chrome/WebView**:
    - Фрагментация версий Android
    - Различия рендеринга между версиями
  - **Samsung Internet**:
    - Уникальные особенности и расширения
    - Распространен на устройствах Samsung

- **Тестирование для мобильных браузеров**:
  - **Реальные устройства**: Тестирование на физических смартфонах/планшетах
  - **Эмуляторы и симуляторы**: Android Studio, Xcode, Chrome DevTools
  - **Удаленное тестирование**: BrowserStack, AWS Device Farm
  - **Чек-лист мобильного тестирования**:
    - Проверка адаптивности при разных ориентациях
    - Тестирование touch-взаимодействий
    - Проверка при медленном интернете
    - Тестирование жестов (swipe, pinch-zoom)

## Доступность (a11y) в веб-разработке

### Что такое веб-доступность и почему она важна?

- **Определение**: Практика создания веб-сайтов, доступных для всех пользователей, включая людей с ограниченными возможностями
- **Категории пользователей с особыми потребностями**:
  - Нарушения зрения (слепота, слабовидение, дальтонизм)
  - Нарушения моторики (ограниченная подвижность, тремор)
  - Когнитивные нарушения (дислексия, нарушения внимания)
  - Нарушения слуха (глухота, тугоухость)
- **Бизнес-значение**:
  - Расширение аудитории (до 15-20% пользователей имеют особые потребности)
  - Юридические требования (ADA, Section 508, EAA в ЕС)
  - Улучшение SEO (многие принципы доступности совпадают с требованиями SEO)
  - Улучшение пользовательского опыта для всех пользователей

### Основные принципы (WCAG)

- **WCAG (Web Content Accessibility Guidelines)**: Международный стандарт веб-доступности
- **Четыре основных принципа (POUR)**:
  - **Perceivable (Воспринимаемость)**: Информация должна быть представлена в формате, который могут воспринять все пользователи
  - **Operable (Управляемость)**: Интерфейс должен быть доступен для управления всеми пользователями
  - **Understandable (Понятность)**: Информация и управление должны быть понятны всем пользователям
  - **Robust (Надежность)**: Контент должен корректно интерпретироваться различными клиентами, включая ассистивные технологии
- **Уровни соответствия**:
  - A (минимальный уровень)
  - AA (стандартный целевой уровень для большинства сайтов)
  - AAA (максимальный уровень для специализированных ресурсов)

### Семантический HTML

- **Важность семантики**:

  - Правильная интерпретация контента ассистивными технологиями
  - Улучшение SEO и поддержки со стороны поисковых систем
  - Более читаемый и поддерживаемый код

- **Ключевые семантические элементы**:

  - **Структура документа**: `<header>`, `<nav>`, `<main>`, `<aside>`, `<footer>`, `<section>`, `<article>`
  - **Заголовки**: Правильная иерархия `<h1>` до `<h6>` для структурирования контента
  - **Списки**: `<ul>`, `<ol>`, `<dl>` для логической группировки элементов
  - **Формы**: `<fieldset>`, `<legend>`, `<label>` для структурирования форм
  - **Таблицы**: `<caption>`, `<thead>`, `<tbody>`, `<th scope="col|row">` для структурирования табличных данных

- **Антипаттерны**:
  - Использование `<div>` и `<span>` там, где подходят семантические элементы
  - Создание визуальных заголовков без соответствующих тегов
  - Использование таблиц для визуальной компоновки

### ARIA (Accessible Rich Internet Applications)

- **Назначение**: Расширение HTML для улучшения доступности динамического контента и современных веб-приложений
- **Принцип "No ARIA is better than bad ARIA"**: Используйте ARIA только когда нативные HTML-элементы не подходят

- **Ключевые компоненты ARIA**:

  - **Роли**: `role="button|checkbox|menuitem|..."` – определяют назначение элемента
  - **Свойства**: `aria-label`, `aria-labelledby`, `aria-describedby` – предоставляют дополнительную информацию
  - **Состояния**: `aria-expanded`, `aria-checked`, `aria-disabled` – описывают текущее состояние

- **Распространенные паттерны**:

  - **Модальные окна**: `role="dialog"` с `aria-modal="true"` и управлением фокусом
  - **Меню**: `role="menu"` с `aria-haspopup` и управлением с клавиатуры
  - **Аккордеоны**: `aria-expanded` для отображения состояния раскрытия
  - **Табы**: `role="tablist"`, `role="tab"` и `role="tabpanel"` для связи компонентов

- **Прямые ARIA (Live Regions)**: Уведомление пользователей о динамических изменениях
  - `aria-live="polite|assertive"`
  - `aria-atomic="true|false"`
  - `aria-relevant="additions|removals|text|all"`

### Клавиатурная навигация

- **Значение**: Многие пользователи не могут использовать мышь или тачскрин
- **Ключевые принципы**:

  - **Фокусируемость**: Все интерактивные элементы должны быть доступны с клавиатуры
  - **Видимый фокус**: Четкая визуальная индикация текущего фокуса (не отключайте outline)
  - **Логический порядок**: Порядок табуляции должен соответствовать визуальному порядку
  - **Ловушки фокуса**: Избегайте ситуаций, когда пользователь не может покинуть область с клавиатуры

- **Важные клавиатурные взаимодействия**:

  - **Tab**: Перемещение между фокусируемыми элементами
  - **Enter/Space**: Активация элементов (кнопки, ссылки)
  - **Стрелки**: Навигация внутри составных компонентов (меню, селекты)
  - **Escape**: Закрытие модальных окон, отмена операций

- **tabindex атрибут**:
  - `tabindex="0"`: Включает элемент в естественный порядок табуляции
  - `tabindex="-1"`: Исключает из порядка табуляции, но позволяет программно устанавливать фокус
  - `tabindex="1+"`: Позитивные значения (антипаттерн) – нарушают естественный порядок навигации

### Контрастность и цвета

- **Требования контрастности (WCAG)**:

  - **Уровень AA**: Соотношение контрастности минимум 4.5:1 для обычного текста, 3:1 для крупного текста
  - **Уровень AAA**: Соотношение контрастности минимум 7:1 для обычного текста, 4.5:1 для крупного текста

- **Дальтонизм и цветовосприятие**:

  - Около 8% мужчин и 0.5% женщин имеют нарушения цветовосприятия
  - Не используйте только цвет для передачи информации
  - Дополняйте цветовую индикацию иконками, текстом или узорами
  - Избегайте проблемных комбинаций (красный/зеленый, синий/фиолетовый)

- **Инструменты для проверки**:
  - **Контраст-анализаторы**: WebAIM Color Contrast Checker, Contrast Finder
  - **Симуляторы дальтонизма**: Chrome DevTools Rendering panel (Emulate vision deficiencies)
  - **Аудит**: Lighthouse, axe, WAVE

### Тестирование доступности

- **Автоматизированное тестирование**:

  - **Инструменты**: axe-core, Lighthouse, WAVE, Pa11y
  - **Ограничения**: Выявляют только 30-40% проблем доступности
  - **Интеграция**: Включение в CI/CD pipeline

- **Ручное тестирование**:

  - **Клавиатурная навигация**: Проверка всего пути пользователя без мыши
  - **Проверка с ассистивными технологиями**: Скринридеры (NVDA, JAWS, VoiceOver)
  - **Чек-листы**: WCAG-specific, WebAIM, GOV.UK доступности

- **Тестирование с реальными пользователями**:
  - Привлечение пользователей с ограниченными возможностями
  - Наблюдение за использованием ассистивных технологий
  - Сбор обратной связи о проблемах доступности

### Ассистивные технологии

- **Скринридеры**:

  - **Настольные**: JAWS, NVDA (Windows), VoiceOver (macOS), Orca (Linux)
  - **Мобильные**: VoiceOver (iOS), TalkBack (Android)
  - **Как тестировать**: Базовые команды навигации, объявление элементов, чтение содержимого

- **Другие ассистивные технологии**:

  - **Программы увеличения экрана**: ZoomText, Windows Magnifier
  - **Альтернативные устройства ввода**: Джойстики, контроль взглядом, системы отслеживания головы
  - **Переключатели (switch devices)**: Для пользователей с ограниченной подвижностью

- **Учет взаимодействия с технологиями**:
  - Разные скринридеры могут интерпретировать контент по-разному
  - Соблюдение стандартов увеличивает совместимость
  - Регулярное тестирование с разными технологиями

## Полный путь загрузки веб-страницы (от ввода URL до рендеринга)

### Ввод URL и обработка запроса

1. **Ввод URL и парсинг**:

   - Пользователь вводит URL в адресную строку
   - Браузер парсит URL на компоненты (протокол, домен, путь, параметры)
   - Если протокол не указан, добавляется http:// или https://
   - Браузер проверяет HSTS (HTTP Strict Transport Security) список для принудительного использования HTTPS

2. **DNS-резолвинг**:
   - Браузер проверяет свой кэш DNS
   - Затем проверяется кэш операционной системы
   - Если не найдено, идет запрос к указанному DNS-серверу (обычно провайдера)
   - DNS-сервер может выполнять рекурсивный запрос:
     - Корневой DNS-сервер → DNS-сервер TLD (.com, .org и т.д.) → Авторитативный DNS-сервер домена
   - Результат (IP-адрес) кэшируется для последующего использования
   - Современные браузеры могут использовать DNS-over-HTTPS для приватности

### Установление соединения

3. **TCP Handshake**:

   - Трехэтапный процесс установки соединения:
     - SYN: Клиент инициирует соединение
     - SYN-ACK: Сервер подтверждает и готов к установке соединения
     - ACK: Клиент подтверждает готовность, соединение установлено
   - Этот процесс гарантирует, что обе стороны готовы к обмену данными

4. **TLS Handshake (для HTTPS)**:
   - Client Hello: Клиент отправляет поддерживаемые методы шифрования
   - Server Hello: Сервер выбирает метод шифрования и отправляет сертификат
   - Проверка сертификата: Браузер проверяет подлинность сертификата сервера
   - Обмен ключами: Устанавливаются общие секретные ключи для шифрования
   - Завершение: Проверка успешности установки защищенного соединения
   - Теперь весь трафик между клиентом и сервером шифруется

### HTTP-запрос и ответ

5. **Отправка HTTP-запроса**:

   - Браузер формирует HTTP-запрос:
     ```
     GET /path/to/resource HTTP/1.1
     Host: example.com
     User-Agent: Mozilla/5.0 ...
     Accept: text/html,application/xhtml+xml,...
     Accept-Language: ru,en;q=0.9
     Cookie: session=abc123; user_id=456
     ```
   - Для HTTPS запрос шифруется ключами сессии
   - Запрос передается серверу через установленное соединение

6. **Обработка запроса на сервере**:

   - Сервер принимает запрос
   - При необходимости дешифрует (для HTTPS)
   - Анализирует запрос и определяет запрашиваемый ресурс
   - Обрабатывает бизнес-логику (взаимодействие с БД, кэшами, файловой системой и т.д.)
   - Генерирует HTTP-ответ со статус-кодом, заголовками и телом

7. **Получение HTTP-ответа**:

   - Браузер получает ответ:

     ```
     HTTP/1.1 200 OK
     Date: Mon, 23 May 2022 22:38:34 GMT
     Content-Type: text/html; charset=UTF-8
     Content-Length: 138
     Cache-Control: max-age=3600
     Set-Cookie: session=updated; HttpOnly; Secure

     <!DOCTYPE html>
     <html>
       <head>
         <title>Example Page</title>
         <link rel="stylesheet" href="styles.css">
       </head>
       <body>
         ...
     ```

   - Обрабатывает заголовки (устанавливает новые куки, применяет инструкции кэширования)
   - Начинает обработку тела ответа, обычно HTML-документа

### Построение DOM и CSSOM

8. **Парсинг HTML и построение DOM**:

   - Браузер читает HTML-код и преобразует его в DOM-дерево
   - DOM (Document Object Model) – это структура всех элементов страницы в памяти
   - Процесс идет сверху вниз, постепенно создавая узлы для каждого тега, атрибута и текстового содержимого
   - При встрече тегов `<link>`, `<script>`, `<img>` браузер инициирует дополнительные запросы ресурсов

9. **Обработка CSS и построение CSSOM**:

   - Параллельно с парсингом HTML браузер обрабатывает CSS
   - CSS из внешних файлов и встроенных тегов `<style>` преобразуется в CSSOM
   - CSSOM (CSS Object Model) – древовидная структура всех стилей
   - CSS в `<head>` блокирует рендеринг страницы до завершения парсинга

10. **Выполнение JavaScript**:
    - Обычные скрипты без атрибутов останавливают парсинг HTML до своего выполнения
    - Скрипты с атрибутом `async` загружаются параллельно и выполняются как только загрузятся
    - Скрипты с атрибутом `defer` выполняются только после построения DOM
    - JavaScript может изменять как DOM, так и стили, влияя на итоговое отображение

### Рендеринг

11. **Построение Render Tree (дерева рендеринга)**:

    - Объединение DOM и CSSOM
    - Включаются только видимые элементы (исключаются `display: none`)
    - Применение правил CSS к соответствующим узлам DOM
    - Вычисление наследуемых свойств

12. **Layout (Reflow)**:

    - Вычисление геометрии каждого видимого элемента:
      - Размеры (width, height)
      - Позиция (координаты x, y)
      - Учет отступов, границ, полей (margin, border, padding)
    - Управление потоком документа (normal flow, float, positioning)
    - Учет зависимостей (например, процентные размеры)

13. **Paint (Отрисовка)**:

    - Превращение данных из дерева рендеринга в пиксели:
      - Отрисовка текста
      - Заливка цветом
      - Отрисовка границ, теней, градиентов
      - Отрисовка изображений
    - Формирование слоев рендеринга для оптимизации
    - Использование растеризации для преобразования векторных форм

14. **Композитинг (Compositing)**:
    - Разделение элементов на слои (особенно с `transform`, `opacity`, `will-change`)
    - Объединение слоев с учетом z-index, прозрачности, наложений
    - Использование GPU для ускорения (аппаратное ускорение)
    - Финальная сборка изображения для вывода на экран

### Пост-загрузочные процессы

15. **Загрузка дополнительных ресурсов**:

    - Изображения, видео, шрифты, которые не блокируют рендеринг
    - Загрузка ресурсов с атрибутом `loading="lazy"` при прокрутке
    - Предзагрузка ресурсов (`prefetch`, `preload`) для будущих страниц

16. **События загрузки**:

    - `DOMContentLoaded`: срабатывает, когда DOM полностью построен
    - `load`: срабатывает, когда страница и все ресурсы загружены
    - Активация JavaScript-обработчиков

17. **Пользовательское взаимодействие**:

    - Обработка пользовательских событий (клики, нажатия клавиш и т.д.)
    - Изменения DOM и стилей могут запускать новые циклы reflow и repaint

18. **Фоновые процессы**:
    - Сбор статистики и аналитики
    - Работа Service Worker (если зарегистрирован)
    - Фоновая синхронизация данных
    - Запросы на обновление страницы

## HTTP-методы и их идемпотентность

- **Определение идемпотентности**: Операция, которая при многократном применении дает тот же результат, что и при однократном
- **Идемпотентные HTTP-методы**:
  - **GET**: Получение ресурса, не изменяет состояние сервера
  - **HEAD**: Аналогичен GET, но возвращает только заголовки
  - **PUT**: Замена существующего ресурса или создание нового с известным URI
  - **DELETE**: Удаление ресурса
  - **OPTIONS**: Получение информации о доступных методах для ресурса
  - **TRACE**: Диагностика (редко используется)
- **Неидемпотентные методы**:
  - **POST**: Создание нового ресурса или отправка данных для обработки
  - **PATCH**: Частичное изменение ресурса
- **Практическое значение**:
  - Безопасность при повторных запросах (например, при повторной отправке формы)
  - Кэширование (идемпотентные методы легче кэшировать)
  - Обработка ошибок сети (можно безопасно повторять идемпотентные запросы)

## Механизмы аутентификации в вебе

- **HTTP Authentication**:

  - **Basic Authentication**: Передача логина и пароля в заголовке Authorization (Base64-encoded)
  - **Digest Authentication**: Улучшенная версия Basic с хешированием
  - **Bearer Authentication**: Использование токенов (обычно JWT) в заголовке

- **Cookie-based Authentication**:

  - После успешной аутентификации сервер устанавливает куки сессии
  - Куки автоматически отправляются с каждым запросом
  - Часто используется с серверным сессионным хранилищем

- **Token-based Authentication**:

  - **JWT (JSON Web Tokens)**: Самодостаточные токены с подписью
  - **OAuth 2.0**: Протокол делегирования доступа без передачи учетных данных
  - **OpenID Connect**: Надстройка над OAuth 2.0 для аутентификации

- **Современные методы**:

  - **WebAuthn/FIDO2**: Аутентификация с помощью биометрии и аппаратных ключей
  - **Passwordless Authentication**: Магические ссылки, одноразовые коды, пуш-уведомления
  - **Многофакторная аутентификация (MFA/2FA)**: Сочетание нескольких факторов

- **Особенности безопасности**:

  - **Защита от CSRF**: Использование CSRF-токенов с куки-аутентификацией
  - **Защита от XSS**: Атрибуты HttpOnly и SameSite для куки
  - **Безопасное хранение токенов**: localStorage vs sessionStorage vs куки

- **Проблемы с SPA и микросервисами**:
  - **Cross-Origin Authentication**: Проблемы с куки в кросс-доменных запросах
  - **Single Sign-On (SSO)**: Единая аутентификация для нескольких приложений
  - **Identity Providers**: Централизованные провайдеры идентификации
