# Вопросы о браузере и веб на собеседовании фронтенд-разработчика

## Загрузка веб-страницы

### Что происходит при вводе URL в адресную строку браузера?

**Определение**: Процесс получения и отображения веб-страницы, запускающийся после ввода URL в адресную строку браузера.

1. **Ввод URL и парсинг**: Браузер парсит URL (протокол, домен, путь)
2. **DNS-резолвинг**: Преобразование домена в IP-адрес
3. **Установление соединения**: TCP handshake + TLS handshake (для HTTPS)
4. **HTTP-запрос**: Формирование и отправка запроса на сервер
5. **Обработка на сервере**: Сервер формирует ответ
6. **Получение ответа**: Браузер получает и обрабатывает ответ
7. **Рендеринг страницы**: Парсинг HTML, построение DOM, CSSOM, рендеринг

### Процесс отрисовки веб-страницы в браузере

**Определение**: Последовательность шагов, которые браузер выполняет для преобразования HTML, CSS и JavaScript в визуальное представление страницы.

1. **Парсинг HTML**: Создание DOM (Document Object Model)
2. **Парсинг CSS**: Создание CSSOM (CSS Object Model)
3. **Построение Render Tree**: Объединение DOM и CSSOM
4. **Layout (Reflow)**: Вычисление размеров и позиций элементов
5. **Paint**: Отрисовка пикселей
6. **Композитинг**: Объединение слоев для финальной отрисовки

### Critical Rendering Path

**Определение**: Последовательность шагов для первоначального отображения страницы, которые браузер должен выполнить, чтобы преобразовать HTML, CSS и JavaScript в пиксели на экране.

**Шаги Critical Rendering Path**:

1. **Построение DOM (Document Object Model)**:

   - Парсинг HTML-документа
   - Создание объектной модели документа (дерево узлов)
   - Блокируется парсером-блокирующими скриптами (без `async/defer`)

2. **Построение CSSOM (CSS Object Model)**:

   - Парсинг CSS-файлов и инлайн-стилей
   - Создание объектной модели стилей
   - CSS блокирует рендеринг, поэтому является критическим ресурсом

3. **Выполнение JavaScript**:

   - Выполнение скриптов может изменять DOM и CSSOM
   - Блокирует построение DOM, если не имеет атрибутов `async` или `defer`
   - Требует готового CSSOM перед выполнением (для операций с стилями)

4. **Создание Render Tree**:

   - Объединение DOM и CSSOM
   - Содержит только видимые элементы (исключает `display: none`, `<head>`, `<script>`, и т.д.)
   - Включает все стилевые вычисления

5. **Layout (Reflow)**:

   - Вычисление точных размеров и позиций элементов
   - Определение геометрии каждого объекта на странице
   - Зависит от размера экрана, разрешения и других факторов

6. **Paint**:

   - Преобразование элементов в реальные пиксели на экране
   - Рисование текста, цветов, изображений, границ, теней
   - Обычно выполняется в нескольких слоях

7. **Compositing**:
   - Объединение нарисованных слоев в окончательное изображение
   - Учёт порядка перекрытия элементов (z-index)
   - Применение эффектов прозрачности и смешивания

**Ключевые метрики**:

- **FCP (First Contentful Paint)**: первое отображение контента (текст, изображение, SVG)
- **LCP (Largest Contentful Paint)**: отображение основного/крупнейшего контента
- **INP (Interaction to Next Paint)**: время реакции на взаимодействие

**Оптимизация**:

- **Критический CSS** для первого экрана
- **Асинхронная загрузка JS**:
  - **`defer`**: Атрибут для скриптов, который указывает браузеру загружать скрипт параллельно с парсингом HTML, но выполнить его только после завершения парсинга DOM (перед событием DOMContentLoaded).
  - **`async`**: Атрибут для скриптов, который указывает браузеру загружать скрипт параллельно с парсингом HTML и выполнить его как только он загрузится, прерывая парсинг HTML если необходимо.
- **Оптимизация шрифтов**:
  - **`font-display: swap`**: CSS-свойство, указывающее браузеру временно использовать запасной шрифт до загрузки основного, затем заменить (swap) запасной на основной, когда он станет доступен. Предотвращает блокировку рендеринга текста при загрузке веб-шрифтов.
- **Lazy loading** для изображений
- **Минимизация количества ресурсов**: уменьшение числа запросов к серверу
- **Сокращение размера ресурсов**: минификация, сжатие, оптимизация изображений
- **Предварительная загрузка**: использование `preload`, `prefetch`, `preconnect` для критических ресурсов

**Техники измерения и отладки**:

- Chrome DevTools → Performance/Network/Rendering
- Lighthouse
- Core Web Vitals
- WebPageTest

## DOM и события

### Событийная модель JavaScript

**Определение**: Механизм обработки событий в JavaScript, определяющий как события распространяются через DOM и обрабатываются.

- **Event Loop**: Механизм, позволяющий JavaScript выполнять асинхронные операции несмотря на то, что сам JavaScript является однопоточным языком.

  **Подробное объяснение**:

  1. **Call Stack (Стек вызовов)**: Структура данных, которая отслеживает текущее местоположение выполнения программы.

     - Когда мы вызываем функцию, она добавляется в стек
     - Когда функция завершается, она удаляется из стека
     - JavaScript может выполнять только одну операцию за раз (однопоточность)

  2. **Web API**: Функциональность, предоставляемая браузером (но не самим JavaScript), которая обрабатывает асинхронные операции.

     - Таймеры: `setTimeout`, `setInterval`
     - Сетевые запросы: `fetch`, `XMLHttpRequest`
     - События DOM: клики, прокрутка страницы
     - Хранилища: localStorage, IndexedDB
     - Геолокация, Web Workers и т.д.

  3. **Callback Queue (Очередь задач)**: Структура данных, хранящая функции обратного вызова (коллбэки), готовые к выполнению.

     - **Task Queue (Макрозадачи)**: события DOM, таймеры, XHR
     - **Microtask Queue (Микрозадачи)**: Promise, queueMicrotask, MutationObserver, процесс микрозадач выполняется до следующей макрозадачи

  4. **Event Loop (Цикл событий)**: Механизм, который постоянно проверяет стек и очереди задач, перемещая задачи в стек для выполнения.

  **Алгоритм работы Event Loop**:

  1. Проверить стек вызовов. Если он не пуст, выполнять текущую операцию.
  2. Если стек пуст, проверить очередь микрозадач:
     - Если есть микрозадачи, взять первую микрозадачу и поместить в стек для выполнения
     - Продолжать обрабатывать все микрозадачи, пока очередь не станет пустой
  3. Когда очереди микрозадач опустела, проверить очередь макрозач:
     - Если есть макрозадачи, взять первую задачу и поместить в стек
     - После выполнения одной макрозадачи снова проверить очередь микрозадач
  4. После обработки задач, если необходимо, браузер выполняет рендеринг страницы
  5. Повторить цикл сначала

  **Визуальное представление**:

  ```
  ┌─────────────────────┐     ┌───────────────┐     ┌─────────────────┐
  │     Call Stack      │     │    Web API    │     │   Task Queue    │
  │                     │     │               │     │                 │
  │                     │     │               │     │ ┌─────────────┐ │
  │ ┌─────────────────┐ │     │ ┌───────────┐ │     │ │ Microtasks  │ │
  │ │ console.log()   │ │     │ │ setTimeout │ │─┐  │ │  • Promise  │ │
  │ └─────────────────┘ │     │ │ fetch()    │ │ │  │ │  • queueMT  │ │
  │ ┌─────────────────┐ │     │ │ events     │ │ │  │ └─────────────┘ │
  │ │ функция A       │ │     │ └───────────┘ │ │  │ ┌─────────────┐ │
  │ └─────────────────┘ │     │               │ └─>│ │ Tasks       │ │
  │ ┌─────────────────┐ │     │               │    │ │  • setTimeout│ │
  │ │ функция B       │<─┐    │               │    │ │  • events   │ │
  │ └─────────────────┘ │ │    │               │    │ └─────────────┘ │
  └─────────────────────┘ │    └───────────────┘    └─────────────────┘
                          │
                          └─── Event Loop проверяет стек и очереди
  ```

  **Пример для понимания последовательности выполнения**:

  ```javascript
  console.log("1"); // Выполняется немедленно (синхронно)

  // setTimeout - асинхронная операция, передается в Web API
  setTimeout(() => {
    console.log("2"); // Будет поставлен в очередь макрозадач
  }, 0);

  // Promise.resolve создает завершенный промис
  Promise.resolve().then(() => {
    console.log("3"); // Будет поставлен в очередь микрозадач

    // Вложенный then также будет микрозадачей
    Promise.resolve().then(() => {
      console.log("4"); // Вторая микрозадача
    });
  });

  // Еще один таймер
  setTimeout(() => {
    console.log("5"); // Вторая макрозадача
  }, 0);

  console.log("6"); // Выполняется немедленно (синхронно)

  // Результат: 1, 6, 3, 4, 2, 5
  // Объяснение:
  // 1. Синхронный код (1, 6) выполняется немедленно
  // 2. Затем обрабатываются все микрозадачи (3, потом 4)
  // 3. Затем берется первая макрозадача (2)
  // 4. Затем берется вторая макрозадача (5)
  ```

  **Важные моменты**:

  1. **Рендеринг UI** происходит между выполнением макрозадач, после обработки всех микрозадач
  2. **Микрозадачи** имеют приоритет над макрозадачами и всегда обрабатываются полностью
  3. **Блокировка Event Loop** (например, долго выполняющийся JavaScript) приводит к "зависанию" страницы
  4. **Web API** выполняет асинхронные операции параллельно с основным потоком JavaScript, но коллбэки всегда выполняются в основном потоке

  **Практический совет**: Разбивайте тяжелые вычисления на части с помощью `setTimeout(fn, 0)` для освобождения основного потока и обеспечения отзывчивости UI.

- **Фазы событий**: capturing → target → bubbling
- **Делегирование событий**: Обработка на родительском элементе

### Reflow и repaint

**Определение**: Процессы пересчета и перерисовки веб-страницы, происходящие при изменении DOM или стилей.

- **Reflow (перекомпоновка)**: Пересчет размеров/позиций элементов, затратная операция
- **Repaint (перерисовка)**: Обновление стилей без изменения геометрии
- **Оптимизация**: Минимизация DOM-манипуляций, группировка изменений, использование CSS-свойств без reflow

### Shadow DOM

**Определение**: Технология, которая обеспечивает инкапсуляцию DOM-элементов, позволяя изолировать стили и функциональность компонентов.

**Подробное объяснение**:

- **Shadow DOM** создает изолированный DOM-узел, который не доступен через обычные методы выбора DOM-элементов снаружи компонента
- Состоит из **Shadow Host** (обычный DOM-элемент), **Shadow Root** (корневой узел Shadow DOM) и **Shadow Tree** (содержимое Shadow DOM)
- Стили, определенные внутри Shadow DOM, не влияют на основной документ и наоборот
- События из Shadow DOM "всплывают" в обычный DOM, но с измененным путем (retargeting)

**Практический пример**:

```javascript
// Создание элемента с Shadow DOM
const host = document.createElement("div");
document.body.appendChild(host);

// Присоединение Shadow DOM к элементу
const shadowRoot = host.attachShadow({ mode: "open" });

// Добавление содержимого в Shadow DOM
shadowRoot.innerHTML = `
  <style>
    /* Эти стили изолированы в Shadow DOM */
    p { color: red; }
  </style>
  <p>Этот текст находится в Shadow DOM</p>
`;

// Стили в Shadow DOM не влияют на элементы основного DOM
document.body.innerHTML += "<p>Этот текст НЕ будет красным</p>";
```

**Отличия режимов Shadow DOM**:

- **open**: Внешний код может получить доступ к Shadow DOM через свойство `element.shadowRoot`
- **closed**: Внешний код не имеет доступа к Shadow DOM (`element.shadowRoot` возвращает null)

**Применение Shadow DOM**:

- Веб-компоненты: создание переиспользуемых элементов с инкапсулированной структурой и стилями
- Встроенные элементы браузера: `<video>`, `<audio>`, `<input type="range">` используют Shadow DOM
- Изоляция стилей в микрофронтендах и виджетах, встраиваемых на сторонние сайты

## Хранение данных

### localStorage, sessionStorage и cookie

**Определение**: Механизмы хранения данных на стороне клиента, предоставляемые веб-браузерами.

#### Особенности и сравнение:

| Характеристика     | localStorage                                        | sessionStorage           | Cookies                                 |
| ------------------ | --------------------------------------------------- | ------------------------ | --------------------------------------- |
| Срок жизни         | Бессрочно (до явного удаления)                      | До закрытия вкладки/окна | Настраиваемый через `expires`/`max-age` |
| Объем              | ~5MB                                                | ~5MB                     | ~4KB на один cookie                     |
| Доступ на клиенте  | JavaScript API                                      | JavaScript API           | JavaScript или HTTP заголовки           |
| Отправка на сервер | Нет                                                 | Нет                      | Да, с каждым запросом                   |
| Область видимости  | Все вкладки/окна (домен)                            | Только текущая вкладка   | Все вкладки/окна (домен)                |
| API                | `setItem()`, `getItem()`, `removeItem()`, `clear()` | Аналогично localStorage  | `document.cookie` (строковый)           |

#### Примеры использования:

```javascript
// localStorage
localStorage.setItem("user", JSON.stringify({ name: "Иван", id: 123 }));
const user = JSON.parse(localStorage.getItem("user"));
localStorage.removeItem("user");
localStorage.clear(); // Удаляет все

// sessionStorage
sessionStorage.setItem(
  "searchFilters",
  JSON.stringify({ category: "Электроника" })
);
const filters = JSON.parse(sessionStorage.getItem("searchFilters"));

// Cookies
document.cookie =
  "username=Иван; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";
document.cookie = "token=abc123; max-age=3600; path=/; secure; samesite=strict";
```

#### Типичные вопросы на собеседовании:

1. **Чем localStorage отличается от sessionStorage?**

   - localStorage сохраняет данные бессрочно, sessionStorage — только до закрытия вкладки
   - localStorage доступен во всех вкладках с тем же доменом, sessionStorage — только в текущей

2. **Почему cookies могут быть предпочтительнее localStorage?**

   - Cookies автоматически отправляются на сервер с каждым запросом
   - Cookies имеют настраиваемые параметры безопасности (HttpOnly, Secure, SameSite)
   - Cookies могут иметь срок действия

3. **Какие ограничения у механизмов хранения?**

   - Все хранят только строки (объекты нужно сериализовать через JSON)
   - Ограничены размером (cookies особенно малы — ~4KB)
   - Блокируются в приватном режиме или при отключенных cookies
   - Небезопасны для хранения критически важных данных без дополнительного шифрования

4. **Что такое HttpOnly, Secure и SameSite в cookies?**

   - HttpOnly — защищает cookie от доступа через JavaScript (только сервер)
   - Secure — отправка cookie только через HTTPS-соединения
   - SameSite — контролирует отправку cookie при кросс-доменных запросах (none, lax, strict)

5. **Когда использовать каждый тип хранилища?**
   - localStorage: настройки пользователя, темы, некритичные долгосрочные данные
   - sessionStorage: состояние временных форм, данные одноразовой сессии
   - Cookies: аутентификация, отслеживание сессий, данные для сервера

### IndexedDB

**Определение**: Низкоуровневое API для хранения значительных объемов структурированных данных, включая файлы и блобы.

- Асинхронное хранилище структурированных данных
- Транзакционная модель, большой объем хранения
- Подходит для offline-приложений и кэширования

## Сетевые аспекты

### HTTP/1.1, HTTP/2 и HTTP/3

**Определение**: Протоколы передачи данных, используемые для передачи веб-контента между клиентом и сервером.

- **HTTP/1.1**: Текстовый протокол, последовательная обработка запросов
- **HTTP/2**: Бинарный протокол, мультиплексирование, сжатие заголовков, Server Push
- **HTTP/3**: На базе QUIC (UDP), улучшенное управление соединениями, встроенное шифрование

### CORS (Cross-Origin Resource Sharing)

**Определение**: Механизм, позволяющий веб-страницам делать запросы к серверам, находящимся на других доменах.

- Механизм для безопасного выполнения кросс-доменных запросов
- Использует HTTP-заголовки для разрешения доступа
- Для сложных запросов выполняется preflight (предварительный OPTIONS-запрос)

### Кэширование в браузере

**Определение**: Процесс временного хранения ресурсов (HTML, CSS, JavaScript, изображения) в локальной памяти браузера для ускорения загрузки страниц.

- **HTTP-заголовки**: `Cache-Control`, `ETag`, `Last-Modified`
- **Стратегии кэширования**: Cache-first, Network-first, Stale-while-revalidate
- **Service Worker API**: Программный контроль над кэшированием

## Безопасность

### XSS (Cross-Site Scripting)

**Определение**: Тип уязвимости веб-приложений, позволяющий злоумышленникам внедрять вредоносный код на страницы, просматриваемые другими пользователями.

**Типы XSS**:

- **Отраженный XSS (Reflected)**: Вредоносный код отражается от веб-приложения в ответе на конкретный запрос, например через параметры URL.
- **Хранимый XSS (Stored)**: Вредоносный код сохраняется на сервере (в БД) и выполняется при посещении страницы, например через комментарии.
- **DOM-based XSS**: Атака происходит полностью на стороне клиента, когда JavaScript динамически изменяет DOM небезопасным образом.

**Примеры уязвимостей**:

```javascript
// Небезопасно: прямая вставка пользовательского ввода в DOM
element.innerHTML = userInput;

// Небезопасно: использование eval() с пользовательскими данными
eval("var result = " + userInput);

// Небезопасно: использование небезопасных методов создания HTML
document.write('<script>alert("XSS")</script>');
```

**Методы защиты**:

- **Экранирование вывода**: Преобразование специальных символов в HTML-сущности
  ```javascript
  function escapeHTML(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
  // Безопасно: экранирование перед вставкой
  element.textContent = userInput; // предпочтительно вместо innerHTML
  ```
- **Валидация входных данных**: Проверка пользовательского ввода на соответствие ожидаемому формату
- **CSP (Content Security Policy)**: Ограничение источников для загрузки скриптов
- **HttpOnly Cookies**: Предотвращение доступа к cookies через JavaScript
- **Использование фреймворков**: Современные фреймворки (React, Angular, Vue) автоматически экранируют вывод
- **DOMPurify**: Библиотека для санитизации HTML
  ```javascript
  const clean = DOMPurify.sanitize(userInput);
  element.innerHTML = clean;
  ```

### CSRF (Cross-Site Request Forgery)

**Определение**: Атака, при которой злоумышленник заставляет аутентифицированного пользователя выполнить нежелательное действие на веб-сайте без его ведома.

**Пример уязвимости**:

```html
<!-- Злоумышленный сайт -->
<img
  src="https://bank.com/transfer?to=attacker&amount=1000"
  style="display:none"
/>
<!-- При посещении страницы, если пользователь авторизован на bank.com, 
     браузер автоматически отправит его cookies в запросе -->
```

**Методы защиты**:

- **CSRF-токены**: Уникальные маркеры для каждой сессии/формы, которые проверяются сервером
  ```html
  <form action="/transfer" method="POST">
    <input type="hidden" name="csrf_token" value="random_token_value" />
    <!-- Остальные поля формы -->
  </form>
  ```
- **SameSite Cookies**: Ограничение отправки cookies в кросс-доменных запросах
  ```
  Set-Cookie: session=123; SameSite=Strict;
  ```
- **Double Submit Cookie**: Отправка одинакового токена в cookie и в параметрах запроса
- **Проверка заголовков Origin/Referer**: Валидация источника запроса на сервере
- **Требование повторной аутентификации**: Для критичных операций (изменение пароля, перевод денег)

### Content Security Policy (CSP)

**Определение**: Механизм безопасности, позволяющий контролировать, какие ресурсы может загружать и выполнять веб-страница.

**Настройка CSP**:

- **HTTP-заголовок**:
  ```
  Content-Security-Policy: default-src 'self'; script-src 'self' trusted-cdn.com; img-src *;
  ```
- **META-тег**:
  ```html
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self' trusted-cdn.com;"
  />
  ```

**Основные директивы**:

- **default-src**: Политика по умолчанию для всех типов ресурсов
- **script-src**: Разрешенные источники JavaScript
- **style-src**: Разрешенные источники CSS
- **img-src**: Разрешенные источники изображений
- **connect-src**: Разрешенные источники для fetch, XHR, WebSocket
- **frame-src**: Разрешенные источники для iframe

**Режим отчетов**: Позволяет тестировать CSP без блокировки ресурсов

```
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report-endpoint;
```

**Дополнительные меры безопасности**:

### HTTPS и HSTS

**HTTPS**: Шифрованное соединение с веб-сервером
**HSTS (HTTP Strict Transport Security)**: Механизм, принуждающий браузер использовать только HTTPS

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

### Защита от Clickjacking

**X-Frame-Options**: Контролирует возможность встраивания страницы в iframe

```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
```

## Производительность

### Core Web Vitals

**Определение**: Набор метрик от Google, оценивающих пользовательский опыт на веб-страницах с точки зрения загрузки, интерактивности и визуальной стабильности.

- **LCP (Largest Contentful Paint)**: ≤2.5с - скорость загрузки основного контента
- **CLS (Cumulative Layout Shift)**: ≤0.1 - визуальная стабильность
- **INP (Interaction to Next Paint)**: ≤200мс - отзывчивость интерфейса

### Оптимизация загрузки

**Определение**: Комплекс мер, направленных на ускорение загрузки и отображения веб-страниц.

**Критический CSS**:

- **Определение**: Минимальный набор стилей, необходимых для отображения контента "первого экрана"
- **Реализация**:
  ```html
  <head>
    <style>
      /* Критические стили для первого экрана */
      header {
        background: #333;
        color: white;
      }
      .hero {
        height: 100vh;
        display: flex;
      }
    </style>
    <!-- Остальные стили загружаются асинхронно -->
    <link
      rel="preload"
      href="styles.css"
      as="style"
      onload="this.rel='stylesheet'"
    />
  </head>
  ```
- **Инструменты**: Critical CSS, Penthouse, критический путь Chrome DevTools

**Адаптивные изображения**:

- **srcset и sizes**: Позволяют браузеру выбрать оптимальный размер изображения
  ```html
  <img
    src="image-800w.jpg"
    srcset="image-480w.jpg 480w, image-800w.jpg 800w, image-1600w.jpg 1600w"
    sizes="(max-width: 600px) 480px, (max-width: 1200px) 800px, 1600px"
    alt="Адаптивное изображение"
  />
  ```
- **picture**: Позволяет указать разные источники для разных условий
  ```html
  <picture>
    <source media="(max-width: 600px)" srcset="small.jpg" />
    <source media="(max-width: 1200px)" srcset="medium.jpg" />
    <source media="(min-width: 1201px)" srcset="large.jpg" />
    <img src="fallback.jpg" alt="Изображение" />
  </picture>
  ```
- **Современные форматы**: WebP (поддержка ~96%), AVIF (~74%)
  ```html
  <picture>
    <source type="image/avif" srcset="image.avif" />
    <source type="image/webp" srcset="image.webp" />
    <img src="image.jpg" alt="Изображение с прогрессивным улучшением формата" />
  </picture>
  ```

**Lazy loading**:

- **Нативный lazy loading**: Встроенный механизм отложенной загрузки
  ```html
  <img src="image.jpg" loading="lazy" alt="Ленивая загрузка" />
  <iframe src="video.html" loading="lazy"></iframe>
  ```
- **Intersection Observer API**: Программная отложенная загрузка

  ```javascript
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src; // Загружаем реальный источник
        observer.unobserve(img); // Прекращаем наблюдение
      }
    });
  });

  // Применяем ко всем изображениям с data-src
  document.querySelectorAll("img[data-src]").forEach((img) => {
    observer.observe(img);
  });
  ```

- **Lazy loading компонентов**: Динамическая загрузка частей UI

**Code splitting и динамические импорты**:

- **Разделение кода по маршрутам**: Загрузка только необходимого для текущей страницы

  ```javascript
  // React с React Router
  const Home = React.lazy(() => import("./Home"));
  const About = React.lazy(() => import("./About"));

  function App() {
    return (
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    );
  }
  ```

- **Динамический импорт**: Загрузка модулей по требованию
  ```javascript
  // Загрузка модуля только при необходимости
  button.addEventListener("click", async () => {
    const { Chart } = await import("./chart.js");
    const chart = new Chart(data);
    chart.render();
  });
  ```
- **Разделение библиотек**: Вынесение редко изменяемых зависимостей в отдельный бандл для эффективного кэширования

**Tree shaking**:

- **Определение**: Удаление неиспользуемого кода из итогового бандла
- **Пример с ESM импортами**:

  ```javascript
  // Только sum будет включен в бандл, multiply - нет
  import { sum } from "./math.js";

  console.log(sum(1, 2));
  ```

- **Настройка в Webpack**:
  ```javascript
  // webpack.config.js
  module.exports = {
    mode: "production", // Включает tree shaking
    optimization: {
      usedExports: true,
    },
  };
  ```
- **Маркировка side-effects**: Указание побочных эффектов в package.json для более эффективного tree shaking
  ```json
  {
    "name": "my-package",
    "sideEffects": false // или ["./src/polyfills.js"]
  }
  ```

**Дополнительные стратегии оптимизации**:

- **Предзагрузка (preload)**: Загрузка критических ресурсов с высоким приоритетом
  ```html
  <link
    rel="preload"
    href="critical-font.woff2"
    as="font"
    type="font/woff2"
    crossorigin
  />
  ```
- **Предварительное соединение (preconnect)**: Установка ранних соединений с источниками
  ```html
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  ```
- **Предварительная выборка (prefetch)**: Загрузка ресурсов для будущих навигаций в фоновом режиме
  ```html
  <link rel="prefetch" href="/next-page.js" />
  ```

## Современные API и технологии

### Service Workers

**Определение**: JavaScript-воркеры, работающие в фоновом режиме браузера и действующие как прокси-сервер между веб-приложением, браузером и сетью.

- JavaScript-скрипты, работающие в фоновом режиме
- Позволяют создавать offline-функциональность
- Обеспечивают кэширование ресурсов и push-уведомления
- Основа для Progressive Web Apps (PWA)

### Web Workers

**Определение**: API, позволяющее запускать скрипты в фоновом потоке, отдельном от основного потока JavaScript.

- Фоновые потоки для выполнения JavaScript вне основного потока
- Общение через сообщения (postMessage/onmessage)
- Подходят для тяжелых вычислений без блокировки UI

### Server-Side Rendering (SSR)

**Определение**: Техника рендеринга JavaScript-приложений на сервере и отправки готового HTML клиенту, что улучшает начальную загрузку и SEO.

- Генерация HTML на сервере с последующей гидратацией на клиенте
- Улучшает время до первого контентного отображения (FCP)
- Повышает SEO, так как поисковые роботы получают готовый HTML
- Улучшает производительность для устройств с низкой мощностью
- Существует в нескольких вариантах: полный SSR, частичный SSR, статическая генерация (SSG)

### Progressive Web Apps (PWA)

**Определение**: Веб-приложения, которые используют современные веб-возможности для предоставления пользователю опыта, схожего с нативными приложениями.

- Работают в оффлайн-режиме благодаря Service Workers
- Устанавливаются на домашний экран устройства
- Имеют быструю загрузку и отзывчивый интерфейс
- Могут отправлять Push-уведомления
- Соответствуют определенным критериям производительности и безопасности
- Работают во всех браузерах с постепенным улучшением функциональности

### Web App Manifest

**Определение**: JSON-файл, который предоставляет информацию о веб-приложении, необходимую для установки на устройство пользователя и отображения в нужном формате.

- Определяет имя, иконки, цвета и другие метаданные приложения
- Контролирует режим отображения (fullscreen, standalone, minimal-ui, browser)
- Указывает ориентацию экрана и стартовую страницу
- Необходим для создания PWA и возможности установки на устройство
- Подключается к HTML через тег `<link rel="manifest" href="/manifest.json">`

### Взаимосвязь Web Worker, Service Worker и Web App Manifest

**Определение**: Несмотря на схожие названия и некоторую общую функциональность, эти технологии имеют разные цели и дополняют друг друга в современной веб-разработке.

- **Web Worker и Service Worker**:

  - Оба используют отдельные потоки выполнения от основного потока JavaScript
  - Service Worker является специализированным типом Web Worker с дополнительными API
  - Web Worker фокусируется на параллельных вычислениях, Service Worker — на перехвате сетевых запросов
  - Web Worker существует только пока открыта страница, Service Worker может работать в фоне даже при закрытии страницы

- **Service Worker и Web App Manifest**:

  - Вместе формируют основу для создания Progressive Web Apps (PWA)
  - Service Worker обеспечивает офлайн-функциональность и кэширование для PWA
  - Web App Manifest предоставляет метаданные для установки PWA на устройство
  - Для полноценного PWA требуются оба компонента: функциональность (Service Worker) и "упаковка" (Manifest)

- **Совместное использование всех трех технологий**:
  - Создает высокопроизводительные веб-приложения с нативными возможностями
  - Web Workers могут обрабатывать тяжелые задачи без блокировки UI
  - Service Worker обеспечивает быструю загрузку и автономную работу
  - Web App Manifest позволяет приложению интегрироваться с операционной системой
  - При правильной реализации все три технологии обеспечивают бесшовный пользовательский опыт

### Intersection Observer

**Определение**: API, предоставляющее способ асинхронно наблюдать за изменениями пересечения элемента с его родителем или областью просмотра.

- API для асинхронного наблюдения за пересечением элементов
- Используется для lazy loading, бесконечной прокрутки, анимаций
- Более эффективен чем события прокрутки и getBoundingClientRect()

### WebSockets

**Определение**: Протокол связи, обеспечивающий полнодуплексный канал связи через одно TCP-соединение.

**Подробное объяснение**:

- **Постоянное соединение**: В отличие от HTTP, где каждый запрос/ответ — отдельное соединение, WebSocket устанавливает одно постоянное соединение
- **Двунаправленная коммуникация**: Клиент и сервер могут отправлять сообщения независимо друг от друга, без необходимости запрос-ответ
- **Небольшие накладные расходы**: Минимальные заголовки сообщений, что уменьшает объем передаваемых данных
- **Работа в реальном времени**: Мгновенная передача данных, без необходимости периодически опрашивать сервер

**Жизненный цикл WebSocket-соединения**:

1. **Установка соединения** (WebSocket handshake):
   - Клиент отправляет HTTP-запрос с заголовком `Upgrade: websocket`
     - Сервер отвечает с кодом 101 (Switching Protocols)
   - После этого HTTP-соединение заменяется WebSocket-соединением
2. **Обмен данными**:

- Сообщения передаются в виде фреймов (текстовых или бинарных)
- Любая сторона может отправлять сообщения в любой момент

  3. **Закрытие соединения**:

- Любая сторона может инициировать закрытие, отправив соответствующий фрейм
- Соединение закрывается корректно, с возможностью указать причину

**Пример использования WebSocket API**:

```javascript
// Создание WebSocket-соединения
const socket = new WebSocket("ws://example.com/socket");

// Обработчики событий
socket.onopen = (event) => {
  console.log("Соединение установлено");
  socket.send("Привет, сервер!");
};

socket.onmessage = (event) => {
  console.log("Получено сообщение:", event.data);
};

socket.onerror = (error) => {
  console.error("Ошибка WebSocket:", error);
};

socket.onclose = (event) => {
  console.log("Соединение закрыто, код:", event.code, "причина:", event.reason);
};

// Отправка сообщений
function sendMessage(message) {
  // Проверка состояния соединения
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(message);
  } else {
    console.warn("Соединение не установлено");
  }
}
```

**Состояния WebSocket-соединения**:

- `WebSocket.CONNECTING` (0): Соединение устанавливается
- `WebSocket.OPEN` (1): Соединение установлено, можно отправлять/получать данные
- `WebSocket.CLOSING` (2): Соединение закрывается
- `WebSocket.CLOSED` (3): Соединение закрыто

**Отличие от других технологий**:

- **Long Polling**: Требует повторного установления соединений, высокая задержка
- **Server-Sent Events (SSE)**: Только односторонняя коммуникация (сервер → клиент)
- **HTTP/2 Server Push**: Разные семантика и назначение, не поддерживает клиент → сервер

**Практические применения**:

- **Чаты и мессенджеры**: Мгновенная доставка сообщений
- **Многопользовательские игры**: Быстрый обмен данными о перемещениях и действиях игроков
- **Торговые платформы**: Обновление котировок в реальном времени
- **Коллаборативные инструменты**: Одновременное редактирование документов
- **Системы мониторинга**: Постоянное обновление метрик и статистики

## Безопасность и аутентификация

### Аутентификация и авторизация

**Определение аутентификации**: Процесс проверки подлинности пользователя — подтверждение того, что пользователь действительно является тем, за кого себя выдает.

**Определение авторизации**: Процесс проверки прав и разрешений аутентифицированного пользователя на доступ к определенным ресурсам или операциям.

**Разница между аутентификацией и авторизацией**:

- **Аутентификация** отвечает на вопрос "Кто вы?" (проверка личности)
- **Авторизация** отвечает на вопрос "Что вам разрешено делать?" (проверка прав)
- Аутентификация предшествует авторизации: сначала идентифицируем пользователя, потом определяем его права

**Методы аутентификации**:

1. **Пароли**: Наиболее распространенный метод
   - Плюсы: простота реализации
   - Минусы: проблемы с безопасностью, забывание пользователями
2. **Многофакторная аутентификация (MFA)**:
   - SMS/Email коды подтверждения
   - Приложения-аутентификаторы (Google Authenticator, Authy)
   - Физические ключи (YubiKey)
3. **Биометрическая аутентификация**:
   - Отпечатки пальцев, распознавание лица/голоса
   - Используется в мобильных приложениях через WebAuthn API
4. **OAuth/OpenID Connect**: Для авторизации через сторонние сервисы
5. **Токены**: JWT, сессионные токены

### JWT (JSON Web Token) и аналоги

**Определение JWT**: Открытый стандарт (RFC 7519) для создания токенов доступа, представляющий собой компактный и самодостаточный способ безопасной передачи информации между сторонами в формате JSON.

**Структура JWT**:

- **Заголовок (Header)**: Тип токена и алгоритм шифрования
  ```json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ```
- **Полезная нагрузка (Payload)**: Данные пользователя и метаданные
  ```json
  {
    "sub": "1234567890",
    "name": "Иван Иванов",
    "role": "admin",
    "iat": 1516239022,
    "exp": 1516242622
  }
  ```
- **Подпись (Signature)**: Проверка целостности токена
  ```
  HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret
  )
  ```

**Формат JWT**: `xxxx.yyyy.zzzz`, где:

- `xxxx` - закодированный в Base64URL заголовок
- `yyyy` - закодированная в Base64URL полезная нагрузка
- `zzzz` - подпись

**Пример JWT**:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ItCY0LLQsNC9INCV0LLQsNC90L7QsiIsImFkbWluIjp0cnVlLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjI0MjYyMn0.N5BQfRZzhjt9H9AHCXn0IlzQY5XnBQAK9b_7w6MYR9s
```

**Типы JWT-токенов**:

- **Access Token**: Краткосрочный токен для доступа к ресурсам
- **Refresh Token**: Долгосрочный токен для получения нового access token
- **ID Token**: Содержит информацию о пользователе (используется в OpenID Connect)

**Преимущества JWT**:

- **Самодостаточность**: Вся необходимая информация содержится в самом токене
- **Компактность**: Небольшой размер, удобно передавать в HTTP-заголовках
- **Безопасность**: Подпись гарантирует целостность данных
- **Кросс-платформенность**: Поддерживается на разных языках и платформах
- **Stateless**: Не требует хранения сессии на сервере

**Реализация JWT в Angular**:

```typescript
// Сервис аутентификации
@Injectable({ providedIn: "root" })
export class AuthService {
  private apiUrl = "https://api.example.com/auth";

  constructor(private http: HttpClient) {}

  login(email: string, password: string): Observable<any> {
    return this.http.post(`${this.apiUrl}/login`, { email, password }).pipe(
      tap((response) => {
        // Сохраняем токены в localStorage
        localStorage.setItem("access_token", response.accessToken);
        localStorage.setItem("refresh_token", response.refreshToken);
      })
    );
  }

  // Получение нового токена с помощью refresh token
  refreshToken(): Observable<any> {
    const refreshToken = localStorage.getItem("refresh_token");

    return this.http
      .post(`${this.apiUrl}/refresh`, { token: refreshToken })
      .pipe(
        tap((response) => {
          localStorage.setItem("access_token", response.accessToken);
        })
      );
  }

  logout(): void {
    localStorage.removeItem("access_token");
    localStorage.removeItem("refresh_token");
  }

  isAuthenticated(): boolean {
    const token = localStorage.getItem("access_token");
    // Проверка наличия токена и его срока действия
    if (!token) return false;

    try {
      // Декодируем токен (без проверки подписи на клиенте)
      const payload = JSON.parse(atob(token.split(".")[1]));
      // Проверяем срок действия
      return payload.exp > Date.now() / 1000;
    } catch (e) {
      return false;
    }
  }
}

// HTTP-интерцептор для добавления токена к запросам
@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  intercept(
    req: HttpRequest<any>,
    next: HttpHandler
  ): Observable<HttpEvent<any>> {
    const token = localStorage.getItem("access_token");

    if (token) {
      // Клонируем запрос и добавляем заголовок Authorization
      const authReq = req.clone({
        headers: req.headers.set("Authorization", `Bearer ${token}`),
      });
      return next.handle(authReq);
    }

    return next.handle(req);
  }
}
```

**Аналоги JWT**:

1. **Сессионные куки**:

   - Хранение идентификатора сессии в cookie
   - Требует хранения состояния сессии на сервере
   - Проще в реализации, более стойкий к некоторым атакам
   - Минусы: overhead на сервере, сложности с масштабированием

2. **OAuth токены**:

   - Стандарт для делегирования доступа (авторизации)
   - Часто используется вместе с JWT для реализации tokens
   - Фокусируется на авторизации, а не на хранении данных пользователя

3. **SAML (Security Assertion Markup Language)**:

   - XML-формат для обмена данными аутентификации и авторизации
   - Используется в корпоративных средах, особенно для SSO
   - Более сложный и многословный, чем JWT

4. **Macaroons**:
   - Токены с поддержкой делегирования и ограничений (caveats)
   - Более гибкие, чем JWT, в плане ограничения доступа
   - Позволяют добавлять ограничения к токену без его пересоздания

**Безопасное использование JWT**:

- Хранить токены в HttpOnly cookie или memory (не в localStorage для защиты от XSS)
- Использовать короткий срок жизни для access tokens (минуты)
- Проверять подпись на сервере
- Применять HTTPS для всех API-запросов
- Использовать механизм обновления токенов

## Доступность (a11y)

### Основы доступности

**Определение**: Практики разработки, обеспечивающие доступность веб-контента для всех пользователей, включая людей с ограниченными возможностями.

- **Семантический HTML**: Правильные теги для правильного контекста
- **ARIA**: Расширение HTML для улучшения доступности динамического контента
- **Клавиатурная навигация**: Все функции должны быть доступны без мыши
- **Контрастность**: Минимум 4.5:1 для обычного текста (WCAG AA)

## Кросс-браузерность

### Подходы к кросс-браузерной разработке

**Определение**: Методы и техники, обеспечивающие корректную работу веб-сайтов и приложений во всех популярных браузерах.

- **Feature detection** вместо определения браузера
- **Полифиллы** для добавления недостающей функциональности
- **Прогрессивное улучшение** - базовая функциональность для всех, расширенная для современных браузеров

### Полифиллы (Polyfills)

**Определение**: Полифилл — это фрагмент кода (обычно JavaScript), который реализует функциональность, которая ожидается от браузера, но отсутствует в более старых его версиях.

**Назначение полифиллов**:

- Обеспечение единообразной работы кода в различных браузерах
- Использование современных API в старых браузерах
- Сохранение читаемости кода без необходимости писать обходные решения

**Пример полифилла**: Полифилл для метода `Array.prototype.includes` (ES2016):

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement, fromIndex) {
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var o = Object(this);
    var len = o.length >>> 0;

    if (len === 0) {
      return false;
    }

    var n = fromIndex | 0;
    var k = Math.max(n >= 0 ? n : len + n, 0);

    while (k < len) {
      if (o[k] === searchElement) {
        return true;
      }
      k++;
    }

    return false;
  };
}
```

**Типы полифиллов**:

1. **API браузера**: `fetch`, `localStorage`, `Promise`, Web Components
2. **Методы JavaScript**: новые методы массивов, строк, объектов
3. **CSS-свойства**: переменные, `grid`, `flexbox`
4. **HTML5-элементы**: семантические элементы для IE

**Подходы к использованию полифиллов**:

1. **Ручное добавление**: включение конкретных полифиллов в проект
2. **Библиотеки полифиллов**:
   - **core-js**: всеобъемлющая библиотека полифиллов для ES6+
   - **polyfill.io**: сервис, определяющий браузер пользователя и предоставляющий только необходимые полифиллы
   - **Modernizr**: обнаружение функций и подключение полифиллов по необходимости
3. **Автоматизация через сборщики**: Babel с preset-env и useBuiltIns

**Лучшие практики**:

- Не включать полифиллы для всех браузеров (увеличивает размер бандла)
- Использовать механизмы условной загрузки для разных браузеров
- Регулярно пересматривать необходимость полифиллов с ростом поддержки функций в браузерах
- Тестировать в различных браузерах для проверки корректной работы полифиллов

**Пример ответа на собеседовании**:

**Вопрос**: Что такое полифиллы и зачем они нужны?

**Ответ**:
"Полифилл (polyfill) — это код, который реализует современную функциональность в старых браузерах, не поддерживающих её нативно. Термин происходит от названия шпаклёвки для заполнения трещин в стенах.

Полифиллы позволяют разработчикам писать современный код, не беспокоясь о поддержке устаревших браузеров. Например, если мы хотим использовать метод `Promise.allSettled()`, который появился относительно недавно, но нам нужна поддержка старых браузеров, мы можем добавить полифилл для этого метода.

Существуют разные подходы к использованию полифиллов:

1. Мы можем вручную добавлять только необходимые полифиллы
2. Использовать библиотеки вроде core-js
3. Применять сервисы как polyfill.io, который автоматически определяет браузер и подгружает только нужные полифиллы
4. Интегрировать с инструментами сборки (Babel с preset-env)

Важно помнить, что полифиллы увеличивают размер кода, поэтому следует применять их разумно, загружая только для тех браузеров, которым они действительно необходимы."

### Особенности мобильных браузеров

**Определение**: Специфические характеристики и ограничения браузеров на мобильных устройствах, требующие особого подхода к разработке.

- **Viewport** и адаптивный дизайн
- **Touch** вместо mouse-событий
- **Производительность** и оптимизация для слабых устройств
- **Оффлайн-поддержка** и прерывистое соединение

**Веб - технологии**:

<details>
  <summary>Что такое HTTP?</summary>
  <div>
    <p>
      Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса, а затем ждет ответа. HTTP - это протокол без сохранения состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной доставкой.
    </p>
    <p>
      Ниже перечислены общие функции, управляемые с HTTP:
    </p>
    <ul>
      <li>
        <b>Кэш.</b> Сервер может инструктировать прокси и клиенты: что и как долго кэшировать. Клиент может инструктировать прокси промежуточных кэшей игнорировать хранимые документы.
      </li>
      <li>
        <b>Ослабление ограничений источника.</b> Для предотвращения шпионских и других, нарушающих приватность, вторжений, веб-браузер обчеспечивает строгое разделеление между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).
      </li>
      <li>
        <b>Аутентификация.</b> Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate и подобных ему, либо с помощью настройки спецсессии, используя куки.
      </li>
      <li>
        <b>Прокси и тунелирование.</b> Серверы и/или клиенты часто располагаются в интранете, и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси -- HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.
      </li>
      <li>
        <b>Сессии.</b> Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создает сессию,  хотя ядро HTTP -- протокол без состояния.  Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Из чего состоит HTTP-запрос?</summary>
  <div>
    <img src="https://www.cloud4y.ru/upload/medialibrary/4c2/yt8bj40q1rh22nzkdhuc1kh1seqth33g/2.jpg" alt="http request

" style="height: 350px; width:475px;"/>

<p>
Запросы содержат следующие элементы:
</p>
<ul>
<li>
HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
</li>
<li>
Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без protocol (http://), domain (здесь developer.mozilla.org), или TCP port (здесь 80).
</li>
<li>
Версию HTTP-протокола.
</li>
<li>
Заголовки (опционально), предоставляюшие дополнительную информацию для сервера.
</li>
<li>
Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.
</li>
</ul>
<p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>

  </div>
</details>

<details>
  <summary>Какие методы может иметь HTTP-запрос?</summary>
  <div>
    <p>
      HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кэшируемыми.
    </p>
    <ul>
      <li>
        <b>GET</b> запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
      </li>
      <li>
        <b>HEAD</b> запрашивает ресурс так же, как и метод GET, но без тела ответа.
      </li>
      <li>
        <b>POST</b> используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
      </li>
      <li>
        <b>PUT</b> заменяет все текущие представления ресурса данными запроса.
      </li>
      <li>
        <b>DELETE</b> удаляет указанный ресурс.
      </li>
      <li>
        <b>CONNECT</b> устанавливает "туннель" к серверу, определённому по ресурсу.
      </li>
      <li>
        <b>OPTIONS</b> используется для описания параметров соединения с ресурсом.
      </li>
      <li>
        <b>TRACE</b> выполняет вызов возвращаемого тестового сообщения с ресурса.
      </li>
      <li>
        <b>PATCH</b> используется для частичного изменения ресурса.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Что такое Cross-Origin Resource Sharing (CORS)?</summary>
  <div>
    <p>
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
    </p>
    <p>
      В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
    </p>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Что такое HTTP cookie и для чего их используют?</summary>
  <div>
    <p>
      HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
    </p>
    <p>
      Cookie используются, главным образом, для:
    </p>
    <ul>
      <li>
        Управления сеансом (логины, корзины для виртуальных покупок)
      </li>
      <li>
        Персонализации (пользовательские предпочтения)
      </li>
      <li>
        Мониторинга (отслеживания поведения пользователя)
      </li>
    </ul>
    <p>
      Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок  Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP  Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать  ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту  оно отсылается.
    </p>
    <p>
      Куки можно создавать через JavaScript при помощи свойства Document.cookie. Если флаг HttpOnly не установлен, то и доступ к существующим cookies можно получить через JavaScript.
    </p>

      document.cookie = "yummy_cookie=choco";
      document.cookie = "tasty_cookie=strawberry";

   <p><i>Источник: <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Какие существуют основные принципы ООП?</summary>
  <div>
    <br/>
    <p>
      Базовые принципы ООП:
    </p>
    <ul>
      <li>
        Абстракция — отделение концепции от ее экземпляра;
      </li>
      <li>
        Полиморфизм — реализация задач одной и той же идеи разными способами;
      </li>
      <li>
        Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
      </li>
      <li>
        Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
      </li>
    </ul>
    <p>
     <i>
       Источник: <a href="https://tproger.ru/translations/oop-principles-cheatsheet/">tproger.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Что такое SOLID (объектно-ориентированное программирование)?</summary>
  <div>
    <br/>
    <p>
      SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».
    </p>
    <p>
      Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:
    </p>
    <ul>
      <li>
        <b>S</b> - Принцип единственной ответственности (The Single Responsibility Principle) каждый класс выполняет лишь одну задачу.
      </li>
      <li>
        <b>O</b> - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности должны быть открыты для расширения, но закрыты для модификации.»
      </li>
      <li>
        <b>L</b> - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.
      </li>
      <li>
        <b>I</b> - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
      </li>
      <li>
        <b>D</b> - Принцип инверсии зависимостей (The Dependency Inversion Principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
      </li>
    </ul>
    <p>
     <i>
       Источник: <a href="https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">wikipedia.org</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Что такое Babel и для чего он используется?</summary>
  <div>
    <br/>
    <p>
      Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.
    </p>
    <p>
      Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.
    </p>
    <p>
      Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них.
    </p>
    <p>
      Конфигурация Babel прописывается в файле babel.config.js, либо в .babelrc для настроек одного пакета, а также в package.json или .babelrc.js
    </p>
    <p>
    Пример конфига в babel.config.js:

      module.exports = function (api) {
        api.cache(true);

        const presets = [ ... ];
        const plugins = [ ... ];

        return {
          presets,
          plugins
        };
      }

   </p>
    <p>
     <i>
       Источник: 
        <a href="https://learn.javascript.ru/es-modern-usage#babel-js">learn.javascript.ru</a>, 
        <a href="https://babeljs.io/docs/en/next/configuration">babeljs.io</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Для чего используется WebSocket? В чем принцип его работы?</summary>
  <div>
    <br/>
    <p>
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
    </p>
    <p>
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
      <code>
        let socket = new WebSocket("ws://javascript.info");
      </code>
    </p>
    <p>
      Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
    </p>
    <ul>
      <li>
        <b>open</b> – соединение установлено,
      </li>
      <li>
        <b>message</b> – получены данные,
      </li>
      <li>
        <b>error</b> – ошибка,
      </li>
      <li>
        <b>close</b> – соединение закрыто.
      </li>
    </ul>
    <p>
      Вот пример:
    </p>
    <p>

      let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

      socket.onopen = function(e) {
        alert("[open] Соединение установлено");
        alert("Отправляем данные на сервер");
        socket.send("Меня зовут Джон");
      };

      socket.onmessage = function(event) {
        alert(`[message] Данные получены с сервера: ${event.data}`);
      };

      socket.onclose = function(event) {
        if (event.wasClean) {
          alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
        } else {
          // например, сервер убил процесс или сеть недоступна
          // обычно в этом случае event.code 1006
          alert('[close] Соединение прервано');
        }
      };

      socket.onerror = function(error) {
        alert(`[error] ${error.message}`);
      };

   </p>
    <p>
      Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате. При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: Blob или ArrayBuffer.
    </p>
    <p>
     <i>
       Источник: <a href="https://learn.javascript.ru/websocket">javascript.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Что такое Веб-компоненты и какие технологии в них используются?</summary>
  <div>
    <br/>
    <p>
      Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
    </p>
    <p>
      Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других:
    </p>
    <ul>
      <li>
        Custom Elements — API для создания собственных HTML элементов.
      </li>
      <li>
        HTML Templates — тег <code>template</code> позволяет реализовывать изолированные DOM-элементы.
      </li>
      <li>
        Shadow DOM — изолирует DOM и стили в разных элементах.
      </li>
      <li>
        HTML Imports — импорт HTML документов.
      </li>
    </ul>
    <p>
     <i>
       Источник: 
        <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B">wikipedia.org</a>
     </i>
    </p>
  </div>
</details>
