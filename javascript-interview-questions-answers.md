# Вопросы и ответы по JavaScript для собеседований

# Архитектуры фронтенд-приложений для собеседования

<details>
<summary><strong>MVC (Модель-Представление-Контроллер)</strong></summary>

### Описание

Архитектурный паттерн, разделяющий приложение на три взаимосвязанных компонента:

- **Модель** — управляет данными, логикой и правилами приложения
- **Представление** — отвечает за визуальное отображение данных пользователю
- **Контроллер** — обрабатывает действия пользователя и обновляет модель

### Как работает

1. Пользователь взаимодействует с представлением
2. Контроллер обрабатывает ввод пользователя
3. Контроллер обновляет модель
4. Представление отображает обновленные данные из модели

### Примеры

- Backbone.js
- Ранние версии Angular.js

### Преимущества

- Четкое разделение ответственности
- Возможность параллельной разработки компонентов
- Многократное использование кода

### Недостатки

- Сложность поддержки при росте приложения
- Часто сильная связанность между компонентами

### Как отвечать на собеседовании

"MVC разделяет приложение на модель (бизнес-логика и данные), представление (интерфейс) и контроллер (обработка действий пользователя). Ключевое преимущество — разделение ответственности, но при масштабировании может возникать тесная связь между компонентами. В чистом виде сейчас применяется редко, чаще используются его производные."

</details>

<details>
<summary><strong>MVVM (Модель-Представление-Модель Представления)</strong></summary>

### Описание

Развитие MVC, где контроллер заменяется на Модель Представления (ViewModel):

- **Модель** — данные и бизнес-логика
- **Представление** — интерфейс пользователя
- **Модель Представления** — промежуточный слой между моделью и представлением

### Как работает

1. Представление связывается с Моделью Представления через механизм привязки данных (data binding)
2. При взаимодействии пользователя с интерфейсом изменения передаются в Модель Представления
3. Модель Представления обновляет Модель и сообщает об изменениях Представлению
4. Двустороннее связывание позволяет автоматически синхронизировать данные

### Примеры

- Angular
- Vue.js
- Knockout.js

### Преимущества

- Двусторонняя привязка данных (two-way data binding)
- Хорошо тестируемый код
- Более четкое разделение ответственности по сравнению с MVC

### Недостатки

- Может быть сложно отлаживать привязку данных
- Потенциальные проблемы с производительностью при большом количестве привязок

### Как отвечать на собеседовании

"MVVM — паттерн с Моделью, Представлением и Моделью Представления, которая выступает в качестве конвертера данных. Ключевой особенностью является двустороннее связывание данных, что позволяет автоматически синхронизировать состояние UI и данных. Это делает код более декларативным, но может создавать сложности при отладке. Angular использует этот подход, расширяя его своими концепциями компонентов, директив и сервисов."

</details>

<details>
<summary><strong>Компонентная архитектура</strong></summary>

### Описание

Построение приложения из независимых, переиспользуемых компонентов, каждый из которых содержит:

- Шаблон (HTML)
- Стили (CSS/SCSS)
- Логику (JavaScript/TypeScript)

### Как работает

1. Приложение разбивается на древовидную структуру компонентов
2. Каждый компонент изолирован и отвечает за свой участок интерфейса
3. Компоненты общаются через входные параметры (props/inputs) и события (events/outputs)
4. Компоненты могут содержать другие компоненты (композиция)

### Примеры

- Angular (с компонентами и директивами)
- React
- Vue.js
- Svelte

### Преимущества

- Высокая переиспользуемость кода
- Изолированная ответственность
- Упрощенное тестирование
- Лучшая поддерживаемость

### Недостатки

- Необходимость правильной декомпозиции на компоненты
- Может возникать проблема с управлением глобальным состоянием
- "Компонентный ад" при неправильном проектировании

### Как отвечать на собеседовании

"Компонентная архитектура — основа современного фронтенд-разработки. Компоненты инкапсулируют HTML, CSS и JavaScript, представляя собой изолированные, переиспользуемые блоки. В Angular компоненты определяются с декоратором @Component и могут быть standalone или частью модулей. Ключевые преимущества — переиспользуемость, легкость тестирования и поддержки. Композиция компонентов позволяет строить сложные интерфейсы из простых блоков. Для эффективного использования необходимо правильно распределять ответственность между компонентами и управлять потоком данных."

</details>

<details>
<summary><strong>Flux и Redux</strong></summary>

### Описание

Архитектурные паттерны для управления состоянием приложения с однонаправленным потоком данных:

- **Flux** — оригинальный паттерн, разработанный Facebook
- **Redux** — реализация Flux-подобной архитектуры

### Ключевые концепции Redux

- **Store** — единый источник истины для всего состояния приложения
- **Actions** — объекты, описывающие, что произошло
- **Reducers** — чистые функции, определяющие как состояние изменяется
- **Dispatch** — метод отправки действий в хранилище

### Как работает

1. Компоненты отправляют (dispatch) действия (actions)
2. Редьюсеры обрабатывают действия и формируют новое состояние
3. Store уведомляет компоненты о изменениях
4. Компоненты перерисовываются, отображая новое состояние

### Примеры

- Redux
- NgRx (для Angular)
- Vuex (для Vue.js)

### Преимущества

- Предсказуемость состояния
- Легкость отладки
- Улучшенный поток данных
- Централизованное управление состоянием

### Недостатки

- Избыточность кода (boilerplate)
- Крутая кривая обучения
- Может быть излишним для небольших приложений

### Как отвечать на собеседовании

"Flux и Redux — архитектуры с однонаправленным потоком данных для управления состоянием. В Redux всё состояние хранится в одном иммутабельном объекте (store). Изменение состояния возможно только через отправку действий (actions), которые обрабатываются чистыми функциями (reducers). В Angular экосистеме используется NgRx — имплементация Redux, расширенная для работы с RxJS. Это обеспечивает предсказуемость состояния и упрощает отладку, но требует написания большего количества кода. Применение оправдано для средних и крупных приложений с комплексным состоянием."

</details>

<details>
<summary><strong>Микрофронтенды</strong></summary>

### Описание

Архитектурный стиль, при котором фронтенд-приложение разбивается на отдельные, независимые части (микрофронтенды), разрабатываемые, тестируемые и развертываемые независимо.

### Как работает

1. Приложение делится на части по бизнес-доменам или функциональности
2. Каждая часть может разрабатываться отдельной командой с различными технологиями
3. Части объединяются на этапе сборки или выполнения
4. Коммуникация между частями осуществляется через API, события или общую шину

### Методы интеграции

- **Webpack Module Federation** (используется в Angular)
- **Web Components**
- **iFrames**
- **Server-side включение**

### Преимущества

- Независимая разработка и деплой частей
- Масштабирование команд разработки
- Возможность использования разных технологий
- Изолированность ошибок

### Недостатки

- Сложность интеграции и тестирования
- Потенциальное дублирование кода и увеличение размера приложения
- Сложности в согласовании стилей и дизайн-системы

### Как отвечать на собеседовании

"Микрофронтенды — архитектурный подход, при котором веб-приложение разбивается на независимые части, разрабатываемые разными командами. Это позволяет масштабировать разработку и независимо развертывать компоненты. В Angular для этого часто используется Module Federation из Webpack 5. Каждый микрофронтенд может быть отдельным Angular-приложением со своим состоянием и маршрутизацией. Ключевые вызовы — согласованность пользовательского опыта, разделение общего кода и эффективная коммуникация между частями. Подход оправдан для больших проектов с несколькими командами разработки."

</details>

<details>
<summary><strong>JAMstack</strong></summary>

### Описание

Архитектурный подход, основанный на клиентском JavaScript, API и предварительно созданной разметке (Markup):

- **J** — JavaScript, выполняющийся на клиенте
- **A** — API для получения данных
- **M** — предварительно генерируемая разметка (Markup)

### Как работает

1. Страницы генерируются заранее на этапе сборки
2. Статические файлы доставляются через CDN
3. Динамический функционал реализуется через JavaScript и API
4. Серверный рендеринг может использоваться для SEO

### Примеры реализации

- Gatsby
- Next.js (SSG режим)
- Angular с Scully
- Astro

### Преимущества

- Высокая производительность и безопасность
- Простое масштабирование (статические файлы через CDN)
- Меньшая нагрузка на сервер
- Лучший пользовательский опыт

### Недостатки

- Ограничения для высокодинамического контента
- Потенциально сложная сборка
- Необходимость перегенерации контента при изменениях

### Как отвечать на собеседовании

"JAMstack — подход, основанный на JavaScript, API и предварительно сгенерированной разметке. Контент создается на этапе сборки и доставляется пользователю через CDN, что обеспечивает высокую скорость загрузки. Динамические функции реализуются через JavaScript и внешние API. В Angular этот подход можно реализовать с помощью Scully — генератора статических сайтов. Преимущества включают лучшую производительность, безопасность и масштабируемость. Подходит для контентных сайтов, блогов и приложений с относительно статическим содержимым."

</details>

<details>
<summary><strong>Feature-Sliced Design (FSD)</strong></summary>

### Описание

Архитектурная методология, организующая код по принципу функциональных срезов и слоев абстракции.

### Слои (снизу вверх)

1. **shared** — переиспользуемые элементы без бизнес-логики (UI-компоненты, утилиты)
2. **entities** — бизнес-сущности (User, Product)
3. **features** — пользовательские возможности (авторизация, фильтрация)
4. **widgets** — композиция фич и сущностей (UserProfile, ProductCard)
5. **pages** — композиция виджетов на страницах
6. **app** — глобальные настройки (роутинг, провайдеры)

### Как работает

1. Код организуется в сегменты по функциональности (слайсы)
2. Каждый слайс может содержать элементы различных слоев
3. Взаимодействие происходит только вверх по иерархии
4. Верхние слои могут использовать нижние, но не наоборот

### Примеры

- Многие React-проекты
- Адаптируется для Angular и других фреймворков

### Преимущества

- Явное разделение зависимостей
- Легкость навигации по проекту
- Масштабируемость и устойчивость к изменениям
- Единообразная структура для всей команды

### Недостатки

- Требует дисциплины от команды
- Может показаться избыточным для маленьких проектов
- Дополнительное время на планирование структуры

### Как отвечать на собеседовании

"Feature-Sliced Design — методология организации кода, разделяющая проект на функциональные слайсы и слои абстракции. Нижние слои (shared, entities) содержат базовые компоненты и бизнес-сущности, верхние (widgets, pages, app) — их композицию. Ключевой принцип — односторонняя зависимость: верхние слои могут использовать нижние, но не наоборот. В Angular это можно реализовать, структурируя модули и компоненты согласно этим слоям. Это обеспечивает лучшую поддерживаемость кода, понятную навигацию в проекте и упрощает масштабирование."

</details>

<details>
<summary><strong>Clean Architecture</strong></summary>

### Описание

Архитектурный подход, основанный на разделении системы на слои с четкими границами и независимостью бизнес-логики от фреймворков и внешних сервисов.

### Ключевые слои (от внутренних к внешним)

1. **Domain** — бизнес-сущности и правила
2. **Application** — сценарии использования, не зависящие от инфраструктуры
3. **Infrastructure** — адаптеры для внешних сервисов и инфраструктуры
4. **Presentation** — UI компоненты и форматеры данных

### Принципы

- Внутренние слои не зависят от внешних
- Зависимости направлены внутрь
- Бизнес-правила не зависят от фреймворков и UI

### Как работает

1. Внешние слои используют интерфейсы, определенные внутренними слоями
2. Инверсия зависимостей применяется для сохранения направления зависимостей
3. Данные преобразуются при переходе между слоями

### Преимущества

- Независимость бизнес-логики от фреймворков
- Легкость тестирования
- Гибкость при изменении технологий
- Четкое разделение ответственности

### Недостатки

- Увеличение объема кода (больше интерфейсов и адаптеров)
- Сложность первоначальной настройки
- Может быть избыточным для простых приложений

### Как отвечать на собеседовании

"Clean Architecture — подход, разделяющий приложение на концентрические слои с четкими границами. Внутренние слои содержат бизнес-логику и не зависят от внешних. В Angular это реализуется через разделение на core (ядро с бизнес-правилами), services (сервисы-адаптеры) и presentation (компоненты и страницы). Применяются принципы инверсии зависимостей через DI и интерфейсы. Это позволяет заменять внешние слои (UI, API-клиенты) без влияния на бизнес-логику, упрощает тестирование и помогает справляться со сложностью. Особенно полезно для долгосрочных проектов с изменяющимися требованиями."

</details>

<details>
<summary><strong>Atomic Design</strong></summary>

### Описание

Методология проектирования интерфейсов, разбивающая UI на иерархические элементы, вдохновленная химией:

- **Атомы** — базовые HTML-элементы (кнопки, поля ввода)
- **Молекулы** — группы атомов (форма поиска)
- **Организмы** — группы молекул (шапка сайта)
- **Шаблоны** — группы организмов (макет страницы)
- **Страницы** — конкретные экземпляры шаблонов с реальным контентом

### Как работает

1. Создание библиотеки компонентов от простых к сложным
2. Композиция более крупных компонентов из мелких
3. Повторное использование на разных уровнях
4. Согласуется с подходом компонентных библиотек

### Примеры

- Storybook для управления компонентами
- Angular Material
- Design systems

### Преимущества

- Согласованность интерфейса
- Повторное использование компонентов
- Эффективная совместная работа дизайнеров и разработчиков
- Модульность и последовательность развития

### Недостатки

- Иногда сложно однозначно классифицировать компоненты
- Необходимость поддерживать документацию компонентов
- Потенциальные проблемы с производительностью при неправильной реализации

### Как отвечать на собеседовании

"Atomic Design — методология проектирования UI, разделяющая интерфейс на пять уровней: атомы (базовые элементы), молекулы (простые комбинации атомов), организмы (сложные компоненты), шаблоны (макеты) и страницы (шаблоны с данными). В Angular это реализуется через создание соответствующей иерархии компонентов с четкими API. Такой подход обеспечивает согласованность интерфейса, упрощает повторное использование и ускоряет разработку. Часто используется вместе с Storybook для документирования компонентов. Это основа для создания дизайн-систем и компонентных библиотек."

</details>

## Основные концепции JavaScript

<details>
<summary>
### 1. Какие типы данных существуют в JavaScript?
</summary>

JavaScript имеет 8 основных типов данных:

**Примитивные типы:**

- **Number** - представляет как целые, так и дробные числа
- **String** - последовательность символов, заключенных в кавычки
- **Boolean** - логический тип с двумя значениями: true и false
- **Null** - специальное значение, означающее "ничего" или "пусто"
- **Undefined** - значение неинициализированных переменных
- **Symbol** - уникальный и неизменяемый идентификатор
- **BigInt** - для целых чисел произвольной длины

**Ссылочный тип:**

- **Object** - коллекция данных и/или функциональности

**Примеры:**

```javascript
// Number
const intNumber = 42;
const floatNumber = 3.14;

// String
const singleQuotes = "Привет";
const doubleQuotes = "Мир";
const templateString = `${singleQuotes}, ${doubleQuotes}!`;

// Boolean
const isTrue = true;
const isFalse = false;

// Null
const empty = null;

// Undefined
let notInitialized;
console.log(notInitialized); // undefined

// Symbol
const uniqueKey = Symbol("description");
const anotherUniqueKey = Symbol("description");
console.log(uniqueKey === anotherUniqueKey); // false

// BigInt
const bigNumber = 1234567890123456789012345678901234567890n;

// Object
const person = { name: "Иван", age: 30 };
const array = [1, 2, 3]; // Массивы тоже объекты
const date = new Date(); // Даты тоже объекты
const regex = /\d+/; // Регулярные выражения тоже объекты
```

Для проверки типа можно использовать оператор `typeof`:

```javascript
console.log(typeof 42); // "number"
console.log(typeof "Привет"); // "string"
console.log(typeof true); // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof Symbol()); // "symbol"
console.log(typeof 42n); // "bigint"
console.log(typeof {}); // "object"
console.log(typeof null); // "object" - это известная ошибка в JavaScript
console.log(typeof []); // "object" - массивы это тоже объекты
```

</details>

<details>
<summary>
### 2. Что такое цикл событий (event loop) и как он работает?
</summary>

Event Loop (цикл событий) - это механизм, который позволяет JavaScript работать асинхронно, несмотря на то, что JavaScript является однопоточным языком.

**Основные компоненты цикла событий:**

1. **Call Stack (стек вызовов)** - структура данных, которая отслеживает выполнение функций в программе
2. **Web APIs** - предоставляются браузером, выполняют асинхронные операции (setTimeout, AJAX, DOM события)
3. **Callback Queue (очередь колбэков)** - очередь функций обратного вызова, ожидающих выполнения
4. **Microtask Queue (очередь микрозадач)** - очередь более приоритетных задач (Promise)
5. **Event Loop** - постоянно проверяет стек вызовов и очереди

**Как работает цикл событий:**

1. Когда JavaScript запускает код, он помещает его в стек вызовов
2. Если встречается асинхронная операция (например, setTimeout), она передается в Web API
3. Когда Web API завершает операцию, колбэк помещается в соответствующую очередь
4. Event Loop ждет, пока стек вызовов освободится, затем берет задачу из очереди и помещает в стек

**Пример:**

```javascript
console.log("Начало");

setTimeout(() => {
  console.log("Таймер на 0мс");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Промис 1");
  })
  .then(() => {
    console.log("Промис 2");
  });

console.log("Конец");

// Вывод будет:
// Начало
// Конец
// Промис 1
// Промис 2
// Таймер на 0мс
```

В этом примере:

1. "Начало" и "Конец" выполняются сразу (синхронный код)
2. Микрозадачи (промисы) выполняются после синхронного кода, но до макрозадач
3. Макрозадача (setTimeout) выполняется последней, даже с задержкой 0мс

Event Loop обеспечивает неблокирующий характер JavaScript, позволяя асинхронным операциям выполняться без остановки основного потока.

</details>

<details>
<summary>
### 3. Что такое замыкание?
</summary>

Замыкание (closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Замыкание позволяет функции сохранять доступ к переменным из внешней области видимости даже после того, как эта область завершила выполнение.

**Ключевые аспекты замыканий:**

1. Функция имеет доступ к переменным, определенным внутри неё
2. Функция имеет доступ к переменным, определенным в её родительской функции
3. Функция сохраняет доступ к этим переменным даже после завершения родительской функции

**Простой пример замыкания:**

```javascript
function createCounter() {
  let count = 0; // Переменная, захваченная замыканием

  return function () {
    count++; // Доступ к переменной из внешней функции
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

const counter2 = createCounter();
console.log(counter2()); // 1 (новое замыкание, новая переменная count)
```

В этом примере:

- Внутренняя функция замыкается над переменной `count`
- Каждый вызов `createCounter()` создает новое замыкание с собственной переменной `count`
- Переменная `count` не доступна извне и защищена от изменений

**Практическое применение замыканий:**

1. **Инкапсуляция данных:**

```javascript
function createUser(name) {
  // Приватная переменная
  let accessCount = 0;

  return {
    getName: function () {
      accessCount++;
      return name;
    },
    getAccessCount: function () {
      return accessCount;
    },
  };
}

const user = createUser("Иван");
console.log(user.getName()); // "Иван"
console.log(user.getName()); // "Иван"
console.log(user.getAccessCount()); // 2
```

2. **Создание фабричных функций:**

```javascript
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

Замыкания - это мощный механизм JavaScript, который используется во многих паттернах программирования, включая модули, каррирование и частичное применение функций.

</details>

<details>
<summary>
### 4. Что такое прототип объекта в JavaScript?
</summary>

Прототип объекта в JavaScript - это механизм, с помощью которого объекты наследуют свойства и методы друг от друга. Каждый JavaScript объект имеет внутреннюю ссылку на другой объект, называемый его прототипом.

**Ключевые концепции прототипов:**

1. **Прототипная цепочка** - последовательность объектов, связанных через прототипы
2. **Прототипное наследование** - механизм, позволяющий объектам наследовать свойства и методы
3. **`__proto__`** - устаревшее свойство для доступа к прототипу объекта
4. **`Object.getPrototypeOf()`** - современный метод для получения прототипа
5. **`prototype`** - свойство функций-конструкторов, определяющее прототип для создаваемых объектов

**Пример прототипного наследования:**

```javascript
// Функция-конструктор
function Animal(name) {
  this.name = name;
}

// Добавление метода в прототип
Animal.prototype.sayHello = function () {
  return `${this.name} говорит привет!`;
};

// Создание объекта с прототипом Animal.prototype
const cat = new Animal("Мурзик");

console.log(cat.sayHello()); // "Мурзик говорит привет!"
console.log(cat.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

**Наследование с помощью Object.create():**

```javascript
const person = {
  isHuman: true,
  printInfo: function () {
    return `${this.name} - человек? ${this.isHuman}`;
  },
};

// Создание объекта с прототипом person
const me = Object.create(person);
me.name = "Петр";

console.log(me.printInfo()); // "Петр - человек? true"
console.log(me.__proto__ === person); // true
```

**Классы в ES6 (синтаксический сахар над прототипами):**

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    return `${this.name} говорит привет!`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  sayHello() {
    return `${super.sayHello()} Я ${this.breed}!`;
  }
}

const dog = new Dog("Рекс", "овчарка");
console.log(dog.sayHello()); // "Рекс говорит привет! Я овчарка!"
```

Под капотом классы в ES6 используют тот же механизм прототипов. `Dog.prototype.__proto__ === Animal.prototype` будет true.

**Важные особенности прототипов:**

1. Если свойство не найдено в объекте, JavaScript ищет его в прототипе объекта, затем в прототипе прототипа, и так далее
2. Изменения в прототипе влияют на все объекты, использующие этот прототип
3. Собственные свойства объекта имеют приоритет над свойствами прототипа

Прототипы - это фундаментальный механизм в JavaScript, который позволяет реализовать наследование и повторное использование кода.

</details>

<details>
<summary>
### 5. Как работает ключевое слово this?
</summary>

`this` в JavaScript - это специальная переменная, которая создаётся для каждого контекста выполнения (функции) и указывает на объект, в контексте которого эта функция была вызвана.

Ключевое слово `this` в JavaScript ссылается на контекст выполнения функции и его значение определяется тем, как функция вызывается, а не где она была объявлена.

**Основные правила определения this:**

1. **Глобальный контекст:** в глобальной области видимости `this` указывает на глобальный объект (в браузере это `window`, в Node.js - `global`)

2. **В методе объекта:** `this` ссылается на объект, в контексте которого вызван метод

3. **В функции-конструкторе:** при использовании оператора `new`, `this` ссылается на новый создаваемый объект

4. **В стрелочных функциях:** `this` берётся из внешней функции (лексический контекст)

5. **При явной привязке:** с помощью методов `call()`, `apply()` или `bind()`

**Примеры:**

1. **Глобальный контекст:**

```javascript
console.log(this === window); // true (в браузере)

function globalFunc() {
  console.log(this === window);
}

globalFunc(); // true (в браузере)
```

2. **В методе объекта:**

```javascript
const user = {
  name: "Иван",
  greet() {
    return `Привет, я ${this.name}`;
  },
};

console.log(user.greet()); // "Привет, я Иван"

// Потеря контекста при передаче метода как колбэка
const greetFunc = user.greet;
console.log(greetFunc()); // "Привет, я undefined" (потому что this теперь window)
```

3. **В функции-конструкторе:**

```javascript
function User(name) {
  this.name = name;
  this.greet = function () {
    return `Привет, я ${this.name}`;
  };
}

const ivan = new User("Иван");
console.log(ivan.greet()); // "Привет, я Иван"
```

4. **В стрелочных функциях:**

```javascript
const user = {
  name: "Иван",
  // Обычная функция
  delayedGreet: function () {
    setTimeout(function () {
      console.log(`Привет, я ${this.name}`); // this здесь window, не user
    }, 1000);
  },
  // Стрелочная функция
  delayedGreetArrow: function () {
    setTimeout(() => {
      console.log(`Привет, я ${this.name}`); // this здесь user
    }, 1000);
  },
};

user.delayedGreet(); // "Привет, я undefined"
user.delayedGreetArrow(); // "Привет, я Иван"
```

5. **Явная привязка:**

```javascript
function greet() {
  return `Привет, ${this.name}!`;
}

const user = { name: "Иван" };

console.log(greet.call(user)); // "Привет, я Иван"
console.log(greet.apply(user)); // "Привет, я Иван"

const boundGreet = greet.bind(user);
console.log(boundGreet()); // "Привет, я Иван"
```

**Важные замечания:**

1. В строгом режиме (`'use strict'`), значение `this` в функциях, вызванных без контекста, будет `undefined` вместо глобального объекта.

2. Стрелочные функции не имеют собственного `this` и не могут быть переназначены с помощью `call`, `apply` или `bind`.

3. При использовании колбэков часто возникает проблема потери контекста, которую можно решить с помощью стрелочных функций или `bind`.

Правильное понимание того, как работает `this` в разных контекстах, является ключевым для эффективного программирования на JavaScript.

</details>

<details>
<summary>
### 6. В чем разница между let, const и var?
</summary>

В JavaScript существует три способа объявления переменных: `var`, `let` и `const`. Они отличаются по области видимости, поднятию (hoisting) и возможности переопределения.

**1. var:**

- Имеет функциональную область видимости (function scope)
- Поднимается (hoists) в начало функции со значением `undefined`
- Может быть повторно объявлена в той же области видимости
- Может быть изменена после объявления

**2. let:**

- Имеет блочную область видимости (block scope)
- Поднимается, но не инициализируется (временная мертвая зона)
- Не может быть повторно объявлена в той же области видимости
- Может быть изменена после объявления

**3. const:**

- Имеет блочную область видимости (block scope)
- Поднимается, но не инициализируется (временная мертвая зона)
- Не может быть повторно объявлена в той же области видимости
- Не может быть переназначена после инициализации
- Но! Если значение - объект, его свойства можно изменять

**Примеры разницы в области видимости:**

```javascript
// var имеет функциональную область видимости
function varExample() {
  if (true) {
    var x = 10;
  }
  console.log(x); // 10 - var видна за пределами блока if
}

// let имеет блочную область видимости
function letExample() {
  if (true) {
    let y = 10;
  }
  console.log(y); // ReferenceError: y is not defined
}

// const также имеет блочную область видимости
function constExample() {
  if (true) {
    const z = 10;
  }
  console.log(z); // ReferenceError: z is not defined
}
```

**Примеры разницы в поднятии (hoisting):**

```javascript
// Поднятие var
console.log(a); // undefined (переменная поднята, но не инициализирована)
var a = 5;

// Поднятие let и const
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 5;

console.log(c); // ReferenceError: Cannot access 'c' before initialization
const c = 5;
```

**Примеры переопределения и изменения:**

```javascript
// var можно переопределять и изменять
var x = 1;
x = 2; // OK
var x = 3; // Тоже OK

// let можно изменять, но нельзя переопределять
let y = 1;
y = 2; // OK
// let y = 3; // SyntaxError: Identifier 'y' has already been declared

// const нельзя переназначать, но можно изменять свойства объектов
const z = 1;
// z = 2;     // TypeError: Assignment to constant variable

const obj = { name: "John" };
// obj = {}; // TypeError: Assignment to constant variable
obj.name = "Jane"; // OK - мы изменяем свойство, а не саму переменную
```

**Рекомендации по использованию:**

1. Используйте `const` по умолчанию для всех переменных, которые не нужно переназначать
2. Используйте `let` для переменных, которые нужно переназначать
3. Избегайте использования `var` в современном коде

Такой подход помогает избежать случайных ошибок и делает код более предсказуемым.

</details>

<details>
<summary>
### 7. Что такое hoisting (поднятие) переменных?
</summary>

Hoisting (поднятие) - это механизм в JavaScript, при котором объявления переменных и функций "поднимаются" в начало их области видимости перед выполнением кода. Важно понимать, что поднимается только объявление, а не инициализация.

**Механизм работы hoisting:**

1. **Во время фазы компиляции** JavaScript движок сканирует код и находит все объявления переменных и функций
2. **Объявления "поднимаются"** в начало своей области видимости
3. **При выполнении кода** инициализация происходит там, где она объявлена в коде

**Поднятие переменных (var, let, const):**

```javascript
console.log(varVariable); // undefined
var varVariable = 10;

// Как это интерпретирует JavaScript:
// var varVariable; // объявление поднято
// console.log(varVariable); // undefined
// varVariable = 10; // присваивание остается на месте

console.log(letVariable); // ReferenceError: Cannot access 'letVariable' before initialization
let letVariable = 10;

console.log(constVariable); // ReferenceError: Cannot access 'constVariable' before initialization
const constVariable = 10;
```

`let` и `const` также поднимаются, но находятся в "временной мертвой зоне" до момента инициализации и к ним нельзя обращаться.

**Поднятие функций:**

Для Function Declaration (объявление функции) поднимается вся функция целиком:

```javascript
// Можно вызвать до объявления
sayHello(); // "Привет!"

// Function Declaration поднимается полностью
function sayHello() {
  console.log("Привет!");
}
```

Для Function Expression (функциональное выражение) поднимается только объявление переменной:

```javascript
// Нельзя вызвать до объявления
sayHi(); // TypeError: sayHi is not a function (для var) или ReferenceError (для let/const)

// Поднимается только объявление переменной, но не присваивание функции
var sayHi = function () {
  console.log("Привет!");
};

// То же самое с let/const:
let sayHello = function () {
  console.log("Привет!");
};
```

**Порядок поднятия:**

1. Сначала поднимаются объявления переменных
2. Затем поднимаются объявления функций

Если есть конфликты, объявления функций "перезаписывают" объявления переменных:

```javascript
console.log(typeof value); // "function", а не "undefined"

var value = 10;

function value() {
  return 20;
}
```

**Практические следствия hoisting:**

1. Всегда объявляйте переменные в начале их области видимости для улучшения читаемости
2. Используйте `let` и `const` вместо `var` для предотвращения ошибок, связанных с поднятием
3. Будьте осторожны с объявлениями функций внутри условных блоков (их поведение может различаться в разных браузерах)

Понимание механизма поднятия помогает избежать неожиданного поведения кода и делает его более предсказуемым.

</details>

<details>
<summary>
### 8. JavaScript синхронный или асинхронный? Однопоточный или многопоточный?
</summary>

**JavaScript как язык:**

- **Синхронный** - выполняет код последовательно, строка за строкой
- **Однопоточный** - выполняет только одну операцию за раз в одном потоке выполнения

Однако, среда выполнения JavaScript (браузер или Node.js) предоставляет механизмы для асинхронного выполнения кода.

**Как достигается асинхронность в JavaScript:**

1. **Цикл событий (Event Loop)** - механизм, обрабатывающий события и колбэки
2. **Колбэки (Callbacks)** - функции, которые вызываются после завершения асинхронной операции
3. **Промисы (Promises)** - объекты, представляющие результат асинхронной операции
4. **Async/Await** - синтаксический сахар над промисами для более удобной работы с асинхронным кодом
5. **Web APIs** (в браузере) или **C++ APIs** (в Node.js) - выполняют тяжелые операции вне основного потока JavaScript

**Пример синхронного кода:**

```javascript
function syncOperation() {
  console.log("Шаг 1");
  console.log("Шаг 2");
  console.log("Шаг 3");
}

syncOperation();
// Вывод всегда будет:
// Шаг 1
// Шаг 2
// Шаг 3
```

**Пример асинхронного кода с колбэками:**

```javascript
console.log("Начало");

setTimeout(() => {
  console.log("Выполнение асинхронной операции");
}, 1000);

console.log("Конец");

// Вывод будет:
// Начало
// Конец
// (через 1 секунду)
// Выполнение асинхронной операции
```

**Пример асинхронного кода с промисами:**

```javascript
console.log("Начало");

fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log("Данные получены:", data))
  .catch((error) => console.error("Ошибка:", error));

console.log("Конец");

// Вывод будет:
// Начало
// Конец
// (когда данные будут получены)
// Данные получены: {...}
```

**Пример асинхронного кода с async/await:**

```javascript
async function fetchData() {
  console.log("Начало fetchData");

  try {
    // await приостанавливает выполнение функции, но не блокирует поток
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log("Данные получены:", data);
  } catch (error) {
    console.error("Ошибка:", error);
  }

  console.log("Конец fetchData");
}

console.log("Перед вызовом fetchData");
fetchData();
console.log("После вызова fetchData");

// Вывод будет:
// Перед вызовом fetchData
// Начало fetchData
// После вызова fetchData
// (когда данные будут получены)
// Данные получены: {...}
// Конец fetchData
```

**Ключевые моменты:**

1. Несмотря на однопоточность JavaScript, асинхронные операции могут выполняться параллельно благодаря среде выполнения
2. Event Loop координирует выполнение асинхронного кода
3. Web APIs (в браузере) или задачи libuv (в Node.js) выполняют тяжелую работу вне основного потока JavaScript
4. Асинхронные операции не блокируют основной поток, что позволяет UI оставаться отзывчивым
5. Асинхронный код всегда выполняется после синхронного, даже если задержка равна 0

Понимание однопоточной природы JavaScript и механизмов асинхронного выполнения кода критически важно для создания производительных веб-приложений.

</details>

<details>
<summary>
### 9. Какая разница между undefined и null?
</summary>

`undefined` и `null` - это два специальных значения в JavaScript, которые представляют отсутствие значения, но имеют разный смысл и применение.

**undefined:**

- Переменная объявлена, но не инициализирована
- Функция возвращает `undefined`, если в ней нет явного return
- Отсутствующие параметры функции имеют значение `undefined`
- Свойство объекта, которое не существует, возвращает `undefined`
- Тип данных: `undefined` (typeof undefined === "undefined")

**null:**

- Явное отсутствие значения (пустота, ничто)
- Используется программистом для указания, что переменная намеренно пуста
- Не устанавливается автоматически JavaScript (всегда устанавливается вручную)
- Тип данных: `object` (typeof null === "object") - это известная ошибка в JavaScript

**Примеры undefined:**

```javascript
// Неинициализированная переменная
let variable;
console.log(variable); // undefined

// Функция без return
function noReturn() {
  // нет return
}
console.log(noReturn()); // undefined

// Отсутствующий параметр
function test(param) {
  console.log(param);
}
test(); // undefined

// Несуществующее свойство объекта
const obj = { name: "John" };
console.log(obj.age); // undefined
```

**Примеры null:**

```javascript
// Явное присваивание null
let user = null; // пользователь неизвестен/отсутствует

// Очистка значения
let data = { name: "John" };
data = null; // явно очищаем переменную

// В API часто используется null
const element = document.getElementById("non-existent"); // null
```

**Сравнение undefined и null:**

```javascript
// При нестрогом сравнении они равны
console.log(undefined == null); // true

// При строгом сравнении они разные
console.log(undefined === null); // false

// Тип данных
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object" (историческая ошибка в JavaScript)

// Преобразования в логическое значение
console.log(Boolean(undefined)); // false
console.log(Boolean(null)); // false

// Преобразования в число
console.log(Number(undefined)); // NaN
console.log(Number(null)); // 0

// Оператор нулевого слияния (??)
console.log(undefined ?? "Значение по умолчанию"); // "Значение по умолчанию"
console.log(null ?? "Значение по умолчанию"); // "Значение по умолчанию"
```

**Важно понимать случаи использования:**

1. `undefined` - автоматическое значение для неинициализированных переменных
2. `null` - явное указание на отсутствие значения
3. При проверке наличия значения полезно проверять на оба значения: `if (value !== undefined && value !== null)`
4. Современный способ проверки: `if (value != null)` или `if (value !== null && value !== undefined)`
5. Еще один современный способ: `if (value ?? default_value)`

**Рекомендации:**

- Используйте `null` для явного указания на отсутствие значения
- Не устанавливайте переменные в `undefined` вручную
- Для значений по умолчанию используйте оператор нулевого слияния `??`
- Помните, что `typeof null === "object"` - это известная ошибка в JavaScript

</details>

<details>
<summary>
### 10. Что такое строгий режим (use strict)?
</summary>

Строгий режим ("use strict") - это режим в JavaScript, который вводит более строгие правила синтаксиса и поведения. Он был добавлен в ECMAScript 5 (ES5) для устранения некоторых "опасных" возможностей языка и повышения безопасности кода.

**Как включить строгий режим:**

```javascript
// Для всего скрипта (в начале файла)
"use strict";

// Или для отдельной функции
function strictFunction() {
  "use strict";
  // Код в строгом режиме
}
```

**Основные изменения в строгом режиме:**

1. **Запрет использования необъявленных переменных:**

```javascript
"use strict";
x = 10; // ReferenceError: x is not defined
```

2. **this в функциях не указывает на глобальный объект:**

```javascript
"use strict";
function showThis() {
  console.log(this);
}
showThis(); // undefined (вместо window в нестрогом режиме)
```

3. **Ошибка при дублировании имен параметров:**

```javascript
"use strict";
// SyntaxError: Duplicate parameter name not allowed in this context
function add(a, a, b) {
  return a + b;
}
```

4. **Запрет на удаление неудаляемых свойств:**

```javascript
"use strict";
// TypeError: Cannot delete property 'prototype' of function Object()
delete Object.prototype;
```

5. **Запрет на использование октальных литералов:**

```javascript
"use strict";
// В нестрогом режиме: 8
// В строгом режиме: SyntaxError
const num = 010;
```

6. **Запрет на использование with:**

```javascript
"use strict";
// SyntaxError: Strict mode code may not include a with statement
with (Math) {
  console.log(PI);
}
```

7. **Ограничения на eval:**

```javascript
"use strict";
// eval не создает переменных в окружающей области видимости
eval("var x = 10");
console.log(x); // ReferenceError: x is not defined
```

8. **Преобразование примитивов в объекты:**

```javascript
"use strict";
// TypeError: Cannot set property '0' of null (в нестрогом режиме работало бы)
null[0] = 1;

// TypeError: Cannot set property 'foo' of undefined (в нестрогом режиме работало бы)
undefined.foo = 1;
```

**Преимущества строгого режима:**

1. **Выявление ошибок на ранней стадии** - многие "молчаливые" ошибки становятся исключениями
2. **Предотвращение случайных глобальных переменных**
3. **Запрет использования "проблемных" возможностей языка**
4. **Улучшение оптимизации** - код может быть лучше оптимизирован из-за меньшего количества "магии"
5. **Подготовка к будущим версиям ECMAScript** - многие ограничения строгого режима стали стандартными в ES6+

**Рекомендации по использованию:**

1. Всегда используйте строгий режим в новых проектах
2. Будьте осторожны при включении строгого режима в существующий код (могут возникнуть ошибки)
3. Современные модули ES6 всегда работают в строгом режиме
4. Современные фреймворки обычно уже используют строгий режим
5. При использовании транспилеров (Babel) строгий режим часто включается автоматически

Строгий режим является хорошей практикой для написания более надежного и безопасного JavaScript-кода.

</details>

<details>
<summary>
### 101. Как работает сравнение типов в JavaScript? Разница между == и ===?
</summary>

В JavaScript существует два оператора сравнения: нестрогое равенство `==` и строгое равенство `===`. Они отличаются поведением при сравнении значений разных типов.

**Строгое равенство (===):**

- Проверяет равенство значений **без преобразования типов**
- Значения считаются равными только если они одного типа и имеют одинаковое значение
- Всегда предпочтительнее использовать `===` вместо `==`

**Нестрогое равенство (==):**

- Проверяет равенство значений **с преобразованием типов**
- Если типы разные, JavaScript пытается привести их к общему типу и затем сравнить
- Правила преобразования могут быть неинтуитивными

**Примеры строгого равенства:**

```javascript
// Сравнение чисел
console.log(5 === 5); // true
console.log(5 === 6); // false

// Разные типы - всегда false
console.log(5 === "5"); // false
console.log(0 === false); // false
console.log(null === undefined); // false

// Объекты сравниваются по ссылке
const obj1 = { a: 1 };
const obj2 = { a: 1 };
const obj3 = obj1;
console.log(obj1 === obj2); // false - разные объекты, хотя содержимое одинаковое
console.log(obj1 === obj3); // true - та же ссылка

// NaN не равен ничему, даже самому себе
console.log(NaN === NaN); // false (это особенность JavaScript)
```

**Примеры нестрогого равенства и преобразования типов:**

```javascript
// Строка и число
console.log(5 == "5"); // true - строка преобразуется в число

// Булево значение и число
console.log(0 == false); // true - false преобразуется в 0
console.log(1 == true); // true - true преобразуется в 1

// null и undefined
console.log(null == undefined); // true - специальное правило
console.log(null == 0); // false - null не преобразуется в число при сравнении с 0

// Объекты преобразуются в примитивы
console.log([1] == 1); // true - [1].toString() -> "1" -> 1
```

**Алгоритм сравнения с преобразованием типов (==):**

1. Если типы одинаковые, сравнение происходит как при `===`
2. Если сравниваются `null` и `undefined`, возвращается `true`
3. Если один операнд - число, а другой - строка, строка преобразуется в число
4. Если один операнд - булево значение, оно преобразуется в число (false -> 0, true -> 1)
5. Если один операнд - объект, а другой - примитив, объект преобразуется в примитив с помощью методов `valueOf()` или `toString()`

**Сравнение объектов:**

Для объектов оба оператора (`==` и `===`) сравнивают ссылки, а не содержимое:

```javascript
const obj1 = { value: 10 };
const obj2 = { value: 10 };
const obj3 = obj1;

console.log(obj1 == obj2); // false
console.log(obj1 === obj2); // false
console.log(obj1 == obj3); // true
console.log(obj1 === obj3); // true
```

**Рекомендации по использованию:**

1. Всегда используйте строгое равенство (`===` и `!==`), если нет веской причины для использования нестрогого
2. Нестрогое равенство (`==` и `!=`) может привести к неожиданным результатам из-за неочевидных правил преобразования типов
3. Если вам действительно нужно сравнить значения с преобразованием типов, лучше сделать это явно

**Особые случаи сравнения:**

```javascript
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true - ES6 метод для "правильного" сравнения

console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false - ES6 метод различает +0 и -0
```

</details>

<details>
<summary>
### 102. Что такое truthy и falsy значения?
</summary>

В JavaScript любое значение можно преобразовать в логический тип (boolean). При этом значения делятся на "truthy" (преобразуются в `true`) и "falsy" (преобразуются в `false`).

**Falsy значения** - значения, которые преобразуются в `false`. Их всего 6:

1. `false` - логическое значение false
2. `0` - числовой ноль (также `-0`)
3. `""` или `''` или `` - пустая строка
4. `null` - отсутствие значения
5. `undefined` - неопределенное значение
6. `NaN` - "не число" (результат некорректной математической операции)

**Truthy значения** - все остальные значения, которые преобразуются в `true`:

1. `true` - логическое значение true
2. Любое число, кроме 0 (включая `Infinity`)
3. Любая непустая строка (`"0"`, `"false"`)
4. Все объекты (включая массивы и функции)
5. Все символы (`Symbol()`)
6. Все объекты-обертки (`new Boolean(false)`, `new Number(0)`, `new String("")`)

**Примеры преобразования в логический тип:**

```javascript
// Явное преобразование с помощью Boolean()
console.log(Boolean(false)); // false
console.log(Boolean(0)); // false
console.log(Boolean("")); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN)); // false

console.log(Boolean(true)); // true
console.log(Boolean(1)); // true
console.log(Boolean("hello")); // true
console.log(Boolean("false")); // true (строка "false" является truthy)
console.log(Boolean({})); // true
console.log(Boolean([])); // true
```

**Неявное преобразование в условных выражениях:**

```javascript
// В if условиях
if (value) {
  // Выполнится, если value - truthy
} else {
  // Выполнится, если value - falsy
}

// Тернарный оператор
const result = value ? "Truthy" : "Falsy";

// Логические операторы
const a = value && "Value is truthy"; // Если value - falsy, возвращается value; иначе - "Value is truthy"
const b = value || "Default"; // Если value - falsy, возвращается "Default"; иначе - value

// Оператор двойного отрицания для преобразования в boolean
const isValid = !!value; // Эквивалентно Boolean(value)
```

**Полезные паттерны с использованием truthy/falsy:**

1. **Значения по умолчанию** (до появления оператора `??`):

```javascript
// Если name - falsy (undefined, null, пустая строка), используем "Гость"
const displayName = name || "Гость";
```

2. **Условное выполнение функции:**

```javascript
// Вызываем callback только если он существует (truthy)
callback && callback(data);
```

3. **Проверка обязательных параметров:**

```javascript
function createUser(name, email) {
  if (!name || !email) {
    throw new Error("Имя и email обязательны");
  }
  // ...
}
```

4. **Фильтрация массива от falsy значений:**

```javascript
const values = [0, 1, false, 2, "", 3, null, undefined, NaN];
const filteredValues = values.filter(Boolean); // [1, 2, 3]
```

5. **Преобразование значений в массиве в логический тип:**

```javascript
const truthyValues = [0, 1, false, 2, ""].map(Boolean); // [false, true, false, true, false]
```

**Важные замечания:**

1. Пустые объекты и массивы являются truthy: `{}` и `[]` преобразуются в `true`
2. Строка "0" и строка "false" являются truthy, так как это непустые строки
3. Объекты-обертки всегда truthy, даже `new Boolean(false)` и `new Number(0)`
4. Для проверки на `null` и `undefined` лучше использовать оператор `??` (ES2020)

Понимание truthy и falsy значений необходимо для эффективного использования условных выражений в JavaScript.

</details>

<details>
<summary>
### 103. Что такое область видимости (scope) в JavaScript?
</summary>

Область видимости (Scope) - это пространство, где переменные и функции доступны для использования. В JavaScript существуют глобальная, функциональная и блочная области видимости.

Лексическое окружение (Lexical Environment) - это внутренний механизм JavaScript, который хранит сведения о доступных переменных и их значениях во время выполнения кода. Содержит два компонента: запись переменных (Environment Record) и ссылку на внешнее окружение.

Связь: область видимости определяется лексическим окружением. Когда код выполняется, JavaScript создает лексическое окружение для каждой области видимости. Это позволяет реализовать механизм замыканий, где функция сохраняет доступ к переменным из родительской области видимости, даже после завершения выполнения родительской функции.

**Основные типы областей видимости:**

1. **Глобальная область видимости (Global Scope)** - переменные, объявленные вне функций, доступны везде
2. **Функциональная область видимости (Function Scope)** - переменные, объявленные внутри функции, доступны только внутри функции
3. **Блочная область видимости (Block Scope)** - переменные, объявленные внутри блока (с `let` и `const`), доступны только внутри блока
4. **Лексическая область видимости (Lexical Scope)** - вложенные функции имеют доступ к переменным из внешних функций

**Глобальная область видимости:**

```javascript
// Глобальная переменная (часть глобальной области видимости)
const globalVariable = "Я глобальная переменная";

function example() {
  console.log(globalVariable); // Доступна внутри функции
}

console.log(globalVariable); // Доступна в глобальной области
```

**Функциональная область видимости:**

```javascript
function example() {
  // Функциональная переменная (часть функциональной области видимости)
  var functionVariable = "Я функциональная переменная";
  console.log(functionVariable); // Доступна внутри функции
}

example();
// console.log(functionVariable); // ReferenceError: functionVariable is not defined
```

**Блочная область видимости:**

```javascript
{
  // Блочная переменная (часть блочной области видимости)
  let blockVariable = "Я блочная переменная";
  const anotherBlockVariable = "Я еще одна блочная переменная";

  console.log(blockVariable); // Доступна внутри блока
  console.log(anotherBlockVariable); // Доступна внутри блока
}

// console.log(blockVariable); // ReferenceError: blockVariable is not defined
// console.log(anotherBlockVariable); // ReferenceError: anotherBlockVariable is not defined

// var не имеет блочной области видимости
{
  var nonBlockVariable = "Я не имею блочной области видимости";
}
console.log(nonBlockVariable); // Доступна вне блока
```

**Лексическая область видимости и замыкания:**

```javascript
function outer() {
  const outerVariable = "Я переменная внешней функции";

  function inner() {
    const innerVariable = "Я переменная внутренней функции";
    console.log(outerVariable); // Доступна благодаря лексической области видимости
  }

  inner();
  // console.log(innerVariable); // ReferenceError: innerVariable is not defined
}

outer();
```

**Вложенные области видимости:**

```javascript
const globalVar = "Глобальная";

function outerFunction() {
  const outerVar = "Внешняя";

  function innerFunction() {
    const innerVar = "Внутренняя";

    console.log(globalVar); // Доступна
    console.log(outerVar); // Доступна
    console.log(innerVar); // Доступна
  }

  console.log(globalVar); // Доступна
  console.log(outerVar); // Доступна
  // console.log(innerVar); // Не доступна

  innerFunction();
}

console.log(globalVar); // Доступна
// console.log(outerVar); // Не доступна
// console.log(innerVar); // Не доступна

outerFunction();
```

**Поиск переменных в цепочке областей видимости:**

1. JavaScript ищет переменную в текущей области видимости
2. Если не найдено, поиск продолжается во внешней области видимости
3. Процесс продолжается до глобальной области видимости
4. Если переменная не найдена нигде, возникает ошибка `ReferenceError`

**Особенности областей видимости и переменных:**

1. **var:**

   - Имеет функциональную область видимости
   - Поднимается (hoisting) в начало функции
   - Глобальные var-переменные становятся свойствами глобального объекта

2. **let и const:**

   - Имеют блочную область видимости
   - Поднимаются, но находятся в "временной мертвой зоне" до инициализации
   - Не становятся свойствами глобального объекта

3. **Функции:**
   - Создают собственную область видимости
   - Имеют доступ к внешним областям видимости
   - Function Declaration поднимается целиком
   - Function Expression поднимается только объявление переменной

**Практические рекомендации:**

1. Избегайте глобальных переменных, чтобы предотвратить конфликты имен и утечки памяти
2. Используйте `let` и `const` вместо `var` для более предсказуемого поведения
3. Применяйте принцип "наименьшей привилегии" - объявляйте переменные в максимально узкой области видимости
4. Используйте IIFE (Immediately Invoked Function Expression) для создания изолированных областей видимости

</details>

<details>
<summary>
### 104. Как работает временная мертвая зона (Temporal Dead Zone)?
</summary>

Временная мертвая зона (Temporal Dead Zone, TDZ) - это поведение в JavaScript, при котором переменные, объявленные с помощью `let` и `const`, не могут быть доступны до момента их объявления, даже несмотря на то, что они "поднимаются" (hoisted).

**Ключевые особенности TDZ:**

1. Переменные, объявленные через `let` и `const`, существуют в блоке с самого начала, но находятся в "мертвой зоне"
2. Попытка обращения к переменной в TDZ вызывает ошибку `ReferenceError`
3. TDZ действует от начала блока до точки объявления переменной
4. TDZ помогает выявлять ошибки, связанные с обращением к переменным до их инициализации

**Пример временной мертвой зоны:**

```javascript
{
  // Начало TDZ для переменной value

  console.log(value); // ReferenceError: Cannot access 'value' before initialization

  // TDZ продолжается...

  let value = 10; // Конец TDZ для переменной value

  console.log(value); // 10 - теперь все в порядке
}
```

**Сравнение с var (без TDZ):**

```javascript
{
  console.log(valueVar); // undefined (не вызывает ошибку)
  var valueVar = 10;
  console.log(valueVar); // 10
}
```

**TDZ и выражения:**

```javascript
{
  // TDZ для variables

  const func = () => console.log(variables);

  // func(); // Вызовет ReferenceError, если раскомментировать

  const variables = ["let", "const"];

  func(); // Теперь работает: ["let", "const"]
}
```

**TDZ и функции:**

```javascript
{
  // TDZ для функции declaration

  declaration(); // ReferenceError: Cannot access 'declaration' before initialization

  const declaration = function () {
    console.log("Function Declaration");
  };

  // А вот функции, объявленные через Function Declaration, не имеют TDZ
  expression(); // "Function Expression" - работает

  function expression() {
    console.log("Function Expression");
  }
}
```

**TDZ в циклах:**

```javascript
for (let i = 0; i < 3; i++) {
  // Каждая итерация имеет свою область видимости
  // и свой экземпляр переменной i
}

// То же самое с TDZ внутри каждой итерации:
for (let i = 0; i < 3; i++) {
  // TDZ для j
  // console.log(j); // ReferenceError
  let j = i * 2;
  console.log(j);
}
```

**TDZ в параметрах функций:**

```javascript
// TDZ работает и с параметрами по умолчанию:
function example(a = b, b = 2) {
  console.log(a, b);
}

// example(); // ReferenceError: Cannot access 'b' before initialization
// Потому что b используется в параметре по умолчанию для a, но еще не инициализирована

// А вот так работает:
function correctExample(a = 1, b = a) {
  console.log(a, b);
}

correctExample(); // 1, 1
```

**Почему TDZ важна:**

1. **Улучшение качества кода** - предотвращает использование переменных до их объявления
2. **Выявление ошибок** - ошибки обнаруживаются раньше, во время выполнения
3. **Предсказуемость** - делает поведение переменных более логичным
4. **Подготовка к константам** - обеспечивает, что константы (`const`) всегда имеют значение
5. **Семантическая целостность** - `let` и `const` имеют логичное блочное поведение

**Практические рекомендации:**

1. Всегда объявляйте `let` и `const` переменные в начале блока
2. Инициализируйте переменные сразу при объявлении, если возможно
3. Не полагайтесь на hoisting (поднятие) для `let` и `const`, в отличие от `var`
4. Будьте особенно внимательны при использовании параметров функций по умолчанию

Понимание концепции временной мертвой зоны помогает писать более надежный и предсказуемый код на JavaScript.

</details>

## Функции

<details>
<summary>
### 11. Какие способы объявления функций существуют в JavaScript?
</summary>

В JavaScript существует несколько способов объявления функций, каждый со своими особенностями и применением.

**1. Function Declaration (Объявление функции):**

```javascript
function sayHello(name) {
  return `Привет, ${name}!`;
}
```

**Особенности:**

- Поднимается (hoisting) полностью, можно вызвать до объявления
- Имеет имя в стеке вызова (удобно для отладки)
- Создаёт контекст `this`
- Доступна во всей области видимости, где объявлена

**2. Function Expression (Функциональное выражение):**

```javascript
const sayHello = function (name) {
  return `Привет, ${name}!`;
};

// Именованное функциональное выражение
const factorial = function factorial(n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
};
```

**Особенности:**

- Поднимается только объявление переменной, не функция
- Может быть анонимной или именованной
- Именованная версия полезна для рекурсии и отладки
- Создаёт контекст `this`
- Доступна только после объявления

**3. Arrow Function (Стрелочная функция):**

```javascript
const sayHello = (name) => `Привет, ${name}!`;

// Многострочная версия
const getUser = (id) => {
  // Выполнение дополнительной логики
  return { id, name: "Пользователь " + id };
};

// Без параметров
const sayHi = () => "Привет!";

// Один параметр (скобки можно опустить)
const double = (x) => x * 2;
```

**Особенности:**

- Более краткий синтаксис
- Не имеет собственного `this` (берет из окружения)
- Не имеет собственного `arguments`
- Не может быть использована как конструктор
- Не может быть использована как генератор
- Не имеет собственного объекта `prototype`

**4. Method Definition (Определение метода в объекте):**

```javascript
// В литерале объекта (ES6 сокращенный синтаксис)
const user = {
  name: "Иван",
  sayHello() {
    return `Привет, меня зовут ${this.name}!`;
  },
};

// Эквивалентно:
const userOld = {
  name: "Иван",
  sayHello: function () {
    return `Привет, меня зовут ${this.name}!`;
  },
};
```

**Особенности:**

- Сокращенный синтаксис в ES6
- Имеет доступ к `this` объекта
- Может использовать `super` в классах

**5. Constructor Function (Функция-конструктор):**

```javascript
function User(name) {
  this.name = name;
  this.sayHello = function () {
    return `Привет, меня зовут ${this.name}!`;
  };
}

const ivan = new User("Иван");
console.log(ivan.sayHello()); // "Привет, меня зовут Иван!"
```

**Особенности:**

- Предназначена для использования с `new`
- Создает новый объект с `this`, указывающим на этот объект
- По соглашению названия начинаются с заглавной буквы

**6. Class Methods (Методы класса):**

```javascript
class User {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    return `Привет, меня зовут ${this.name}!`;
  }

  static create(name) {
    return new User(name);
  }
}

const ivan = new User("Иван");
console.log(ivan.sayHello()); // "Привет, меня зовут Иван!"
```

**Особенности:**

- Синтаксический сахар над прототипным наследованием
- Обычные методы добавляются в prototype
- Статические методы добавляются непосредственно в класс
- Всегда в строгом режиме

**7. IIFE (Immediately Invoked Function Expression):**

```javascript
(function () {
  console.log("Эта функция выполняется сразу после объявления");
})();

// С параметрами
(function (name) {
  console.log(`Привет, ${name}!`);
})("Иван");

// Со стрелочной функцией
(() => {
  console.log("IIFE со стрелочной функцией");
})();
```

**Особенности:**

- Выполняется сразу после объявления
- Создает изолированную область видимости
- Полезна для инкапсуляции переменных

**8. Generator Function (Функция-генератор):**

```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = generateSequence();
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
console.log(generator.next().value); // 3
```

**Особенности:**

- Объявляется со звездочкой `function*`
- Может приостанавливать свое выполнение (yield)
- Возвращает объект-итератор

**9. Async Function (Асинхронная функция):**

```javascript
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Ошибка:", error);
  }
}

// Асинхронное функциональное выражение
const fetchUser = async function (id) {
  // ...
};

// Асинхронная стрелочная функция
const fetchPosts = async (userId) => {
  // ...
};

// Асинхронный метод
const api = {
  async getUsers() {
    // ...
  },
};

// Асинхронная IIFE
(async () => {
  const data = await fetchData();
  console.log(data);
})();
```

**Особенности:**

- Всегда возвращает Promise
- Позволяет использовать синтаксис await
- Может быть использована с любым типом функций

**10. Bound Function (Привязанная функция):**

```javascript
function greet() {
  return `Привет, ${this.name}!`;
}

const user = { name: "Иван" };
const boundGreet = greet.bind(user);

console.log(boundGreet()); // "Привет, Иван!"
```

**Особенности:**

- Создается с помощью метода `bind()`
- Имеет фиксированный контекст `this`
- Может иметь предустановленные аргументы

**Сравнение различных видов функций:**

| Тип функции          | Hoisting              | Собственный this | arguments        | super                | new.target           | Конструктор | Пример использования                    |
| -------------------- | --------------------- | ---------------- | ---------------- | -------------------- | -------------------- | ----------- | --------------------------------------- |
| Function Declaration | Да (полностью)        | Да               | Да               | Нет                  | Да                   | Да          | Общая функциональность                  |
| Function Expression  | Частично              | Да               | Да               | Нет                  | Да                   | Да          | Функции обратного вызова, замыкания     |
| Arrow Function       | Частично              | Нет              | Нет              | Нет                  | Нет                  | Нет         | Краткая запись, сохранение контекста    |
| Method Definition    | Нет                   | Да               | Да               | Да                   | Да                   | Нет         | Методы объектов и классов               |
| Class Method         | Нет                   | Да               | Да               | Да                   | Да                   | Нет         | ООП-подход                              |
| Generator Function   | Да (если Declaration) | Да               | Да               | Зависит от контекста | Зависит от контекста | Нет         | Итераторы, асинхронное программирование |
| Async Function       | Зависит от формы      | Зависит от формы | Зависит от формы | Зависит от формы     | Зависит от формы     | Нет         | Асинхронное программирование            |

**Рекомендации по выбору типа функции:**

- Используйте **Function Declaration** для основных функций, которые нужны во всей области видимости
- Используйте **Function Expression** для функций обратного вызова и локальных функций
- Используйте **Arrow Functions** (стрелочные функции) для коротких функций и сохранения `this`
- Используйте **Method Shorthand** для методов объектов и классов
- Используйте **Class Methods** для ООП-подхода
- Используйте **IIFE** для изоляции области видимости
- Используйте **Generator Function** для итерируемых последовательностей
- Используйте **Async Function** для асинхронного программирования

</details>

<details>
<summary>
### 12. Как работают методы apply(), call() и bind()?
</summary>

Методы `apply()`, `call()` и `bind()` в JavaScript используются для управления контекстом выполнения функции (значением `this`). Они позволяют явно указать, какой объект должен быть `this` при вызове функции.

**1. call(thisArg, arg1, arg2, ...)**

Метод `call()` вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Иван" };

// Вызываем функцию greet с this = person и передаем аргументы
console.log(greet.call(person, "Привет", "!")); // "Привет, Иван!"
```

**2. apply(thisArg, [argsArray])**

Метод `apply()` делает то же самое, что и `call()`, но принимает аргументы в виде массива.

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Иван" };

// Вызываем функцию greet с this = person и передаем аргументы в массиве
console.log(greet.apply(person, ["Привет", "!"])); // "Привет, Иван!"
```

**Разница между call и apply:**

- `call()` принимает аргументы через запятую
- `apply()` принимает аргументы в виде массива

**3. bind(thisArg, arg1, arg2, ...)**

Метод `bind()` создает новую функцию, которая при вызове будет иметь `this`, установленный в предоставленное значение, с последовательностью аргументов, предшествующей любым аргументам, предоставленным при вызове новой функции.

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "Иван" };

// Создаем новую функцию с привязанным this = person
const greetIvan = greet.bind(person);
console.log(greetIvan("Привет", "!")); // "Привет, Иван!"

// Также можно предустановить часть аргументов
const sayHiToIvan = greet.bind(person, "Привет");
console.log(sayHiToIvan("!")); // "Привет, Иван!"

// Предустановка всех аргументов
const sayHiToIvanWithExclamation = greet.bind(person, "Привет", "!");
console.log(sayHiToIvanWithExclamation()); // "Привет, Иван!"
```

**Ключевые отличия bind от call/apply:**

- `bind()` не вызывает функцию, а возвращает новую привязанную функцию
- Привязка `this` в `bind()` постоянна и не может быть переопределена
- `bind()` позволяет частично применять аргументы (partial application)

**Практические примеры использования:**

**1. Исправление потери контекста:**

```javascript
const user = {
  name: "Иван",
  greet: function () {
    console.log(`Привет, я ${this.name}`);
  },
};

// Потеря контекста при передаче метода в качестве колбэка
setTimeout(user.greet, 1000); // "Привет, я undefined"

// Исправление с помощью bind
setTimeout(user.greet.bind(user), 1000); // "Привет, я Иван"
```

**2. Позаимствовать метод:**

```javascript
const arrayLike = {
  0: "a",
  1: "b",
  2: "c",
  length: 3,
};

// Заимствуем метод slice у массива
const array = Array.prototype.slice.call(arrayLike);
console.log(array); // ["a", "b", "c"]

// Современный эквивалент
const modernArray = Array.from(arrayLike);
```

**3. Применение функции к элементам массива:**

```javascript
const numbers = [5, 8, 2, 1, 4];

// Находим минимальное и максимальное значения
const min = Math.min.apply(null, numbers); // 1
const max = Math.max.apply(null, numbers); // 8

// Современный эквивалент с оператором spread
const minModern = Math.min(...numbers); // 1
const maxModern = Math.max(...numbers); // 8
```

**4. Частичное применение функции (partial application):**

```javascript
function multiply(a, b) {
  return a * b;
}

// Создаем функцию, которая умножает на 2
const double = multiply.bind(null, 2);
console.log(double(5)); // 10

// Создаем функцию, которая умножает на 3
const triple = multiply.bind(null, 3);
console.log(triple(5)); // 15
```

**5. Привязка обработчиков событий:**

```javascript
class Button {
  constructor(label) {
    this.label = label;
    this.element = document.createElement("button");
    this.element.textContent = label;

    // Решаем проблему потери контекста
    this.element.addEventListener("click", this.handleClick.bind(this));
  }

  handleClick() {
    console.log(`Кнопка ${this.label} была нажата`);
  }
}
```

**Особенности и ограничения:**

1. **Стрелочные функции** не имеют собственного `this` и игнорируют переданный через `call`, `apply` или `bind`:

```javascript
const arrowFunc = () => {
  console.log(this);
};

const obj = { name: "Объект" };
arrowFunc.call(obj); // Window или global (this не переопределяется)
```

2. **Повторная привязка** не изменяет контекст уже привязанной функции:

```javascript
function greet() {
  return `Привет, ${this.name}`;
}

const user1 = { name: "Иван" };
const user2 = { name: "Мария" };

const greetIvan = greet.bind(user1);
// Попытка повторной привязки не сработает
const tryGreetMaria = greetIvan.bind(user2);
console.log(tryGreetMaria()); // "Привет, Иван", а не "Привет, Мария"
```

3. **Значение null или undefined** для thisArg в глобальном контексте:

```javascript
function showThis() {
  console.log(this);
}

// В нестрогом режиме null и undefined заменяются на глобальный объект
showThis.call(null); // Window (в браузере)
showThis.call(undefined); // Window (в браузере)

// В строгом режиме значения сохраняются как есть
function strictShowThis() {
  "use strict";
  console.log(this);
}

strictShowThis.call(null); // null
strictShowThis.call(undefined); // undefined
```

**Выбор между call, apply и bind:**

- Используйте `call` когда у вас есть отдельные аргументы и вы хотите сразу вызвать функцию
- Используйте `apply` когда у вас есть массив аргументов и вы хотите сразу вызвать функцию
- Используйте `bind` когда вам нужно создать новую функцию с привязанным контекстом для последующего вызова
- В современном JavaScript во многих случаях можно использовать стрелочные функции или оператор spread вместо этих методов

</details>

<details>
<summary>
### 13. Чем отличается Function Declaration от Function Expression?
</summary>

Function Declaration (объявление функции) и Function Expression (функциональное выражение) — это два основных способа определения функций в JavaScript. Хотя в обоих случаях создаются функции, между ними есть важные различия.

**Function Declaration (FD):**

```javascript
function sayHello(name) {
  return `Привет, ${name}!`;
}
```

**Function Expression (FE):**

```javascript
const sayHello = function (name) {
  return `Привет, ${name}!`;
};

// Именованное функциональное выражение
const factorial = function factorial(n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
};
```

**Основные отличия:**

**1. Поднятие (Hoisting)**

- **Function Declaration:** Поднимаются полностью. Функцию можно вызвать до её объявления в коде.

```javascript
// Работает благодаря hoisting
console.log(sum(2, 3)); // 5

function sum(a, b) {
  return a + b;
}
```

- **Function Expression:** Поднимается только объявление переменной, не функция

```javascript
// Ошибка: multiply is not a function
console.log(multiply(2, 3));

const multiply = function (a, b) {
  return a * b;
};

// С var будет иная ошибка
// console.log(multiplyVar(2, 3)); // TypeError: multiplyVar is not a function
// var multiplyVar = function(a, b) { return a * b; };
```

**2. Именование и объект функции**

- **Function Declaration:** Всегда должна иметь имя. Это имя доступно как внутри функции, так и снаружи.

- **Function Expression:** Может быть анонимной или именованной. Если именованная, то имя доступно только внутри функции.

```javascript
// Именованное функциональное выражение
const factorial = function fact(n) {
  // fact доступно здесь
  return n <= 1 ? 1 : n * fact(n - 1);
};

// factorial доступно здесь
// fact не доступно здесь - вызовет ReferenceError
```

**3. Когда и где создаются**

- **Function Declaration:** Создается интерпретатором перед выполнением кода (во время "фазы создания").

- **Function Expression:** Создается во время выполнения, когда интерпретатор доходит до этого выражения.

**4. Использование в условных выражениях**

- **Function Declaration:** В строгом режиме не рекомендуется использовать внутри блоков, так как их поведение может различаться в разных средах JavaScript.

```javascript
// В разных браузерах это может работать по-разному
if (condition) {
  function test() {
    return "A";
  }
} else {
  function test() {
    return "B";
  }
}
// В современных браузерах это обычно работает ожидаемо,
// но лучше избегать такого кода
```

**5. Использование в IIFE (Immediately Invoked Function Expression)**

- **Function Declaration:** Не может быть немедленно вызвана без обертывания в скобки.

- **Function Expression:** Может быть немедленно вызвана.

```javascript
// Сработает
(function () {
  console.log("IIFE с Function Expression");
})();

// Ошибка синтаксиса без скобок
// function() { console.log('Это не сработает'); }();
```

**6. В качестве значений выражений**

- **Function Declaration:** Не может быть использована как часть выражения.

- **Function Expression:** Может быть использована везде, где ожидается выражение.

```javascript
// Function Expression как часть тернарного оператора
const getCalculator = isAdvanced
  ? function (a, b) {
      return a ** b;
    }
  : function (a, b) {
      return a * b;
    };
```

**7. Место в коде**

- **Function Declaration:** Может быть только на верхнем уровне сценария или функции.

- **Function Expression:** Может быть частью любого выражения.

**8. Применение в современном JavaScript**

- **Function Declaration:** Подходит для общих функций, которые нужны на уровне модуля или функции.

- **Function Expression:** Часто используется для функций обратного вызова, замыканий, функций, привязанных к событиям, или когда функция является временной.

**9. Стрелочные функции (особый тип Function Expression)**

```javascript
const arrowSum = (a, b) => a + b;
```

- Стрелочные функции - это всегда Function Expression
- Имеют более краткий синтаксис
- Не имеют собственного `this`, `arguments`, `super` или `new.target`
- Не могут быть использованы с `new`
- Не могут быть генераторами

**Рекомендации по использованию:**

- Используйте **Function Declaration** для основных функций, которые должны быть доступны повсеместно.
- Используйте **Function Expression** для функций обратного вызова и локальных функций
- Используйте **Arrow Functions** (стрелочные функции) для коротких функций и сохранения `this`
- Будьте осторожны с Function Declaration в блоках кода - их поведение может отличаться в разных средах JavaScript.

```javascript
// Function Declaration - для основных функций
function calculateTotal(items) {
  return items.reduce((total, item) => total + item.price, 0);
}

// Function Expression - для колбэков
const filteredItems = items.filter(function (item) {
  return item.category === "electronics";
});

// Arrow Function - для краткости и сохранения this
element.addEventListener("click", () => {
  this.processClick(); // this из внешней области
});
```

</details>

<details>
<summary>
### 14. Что такое IIFE (Immediately Invoked Function Expression)?
</summary>

IIFE (Immediately Invoked Function Expression) или Немедленно Вызываемое Функциональное Выражение — это JavaScript функция, которая выполняется сразу же после своего создания.

**Базовый синтаксис IIFE:**

```javascript
(function () {
  // Код, который выполнится немедленно после объявления
  console.log("Эта функция вызывается немедленно!");
})();

// Альтернативный синтаксис
(function () {
  console.log("Этот синтаксис тоже работает!");
})();
```

**Ключевые особенности IIFE:**

**1. Инкапсуляция и изоляция переменных**

Основное преимущество IIFE — создание изолированной области видимости, которая не загрязняет глобальный объект:

```javascript
// Без IIFE - переменная доступна глобально
var globalCounter = 0;

// С IIFE - переменная инкапсулирована
(function () {
  var counter = 0;
  console.log("Начальное значение:", counter);
  counter++;
  console.log("Новое значение:", counter);
})();

// counter здесь недоступна
// console.log(counter); // ReferenceError: counter is not defined
```

**2. Передача аргументов**

IIFE может принимать параметры:

```javascript
(function (name, greeting) {
  console.log(`${greeting}, ${name}!`);
})("Иван", "Привет"); // "Привет, Иван!"

// Часто используется для передачи глобальных объектов
(function (window, document, $) {
  // Теперь window, document и jQuery доступны как локальные переменные
  $(document).ready(function () {
    // jQuery-код...
  });
})(window, document, jQuery);
```

**3. Возврат значений**

IIFE может возвращать значения:

```javascript
const counter = (function () {
  let count = 0;

  return {
    increment() {
      return ++count;
    },
    decrement() {
      return --count;
    },
    getValue() {
      return count;
    },
  };
})();

console.log(counter.getValue()); // 0
counter.increment();
console.log(counter.getValue()); // 1
```

**4. Использование со стрелочными функциями**

IIFE можно создавать и с помощью стрелочных функций:

```javascript
(() => {
  console.log("IIFE со стрелочной функцией");
})();

// С параметрами
((name) => {
  console.log(`Привет, ${name}!`);
})("Иван");
```

**5. Асинхронные IIFE**

С появлением async/await IIFE стали использоваться для асинхронного кода:

```javascript
(async function () {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Ошибка:", error);
  }
})();
```

**Применение IIFE в реальных проектах:**

**1. Модульная структура (до появления ES модулей)**

```javascript
// Модуль пользователя
const UserModule = (function () {
  // Приватные переменные и функции
  const users = [];

  function findUserById(id) {
    return users.find((user) => user.id === id);
  }

  // Публичный API
  return {
    addUser(user) {
      users.push(user);
    },
    getUser(id) {
      return findUserById(id);
    },
    getAllUsers() {
      return [...users]; // Возвращаем копию массива
    },
  };
})();

UserModule.addUser({ id: 1, name: "Иван" });
console.log(UserModule.getUser(1)); // { id: 1, name: 'Иван' }
```

**2. Предотвращение загрязнения глобальной области видимости в библиотеках**

```javascript
// Классический паттерн для создания библиотек
(function (global, factory) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    // CommonJS
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    // AMD
    define(factory);
  } else {
    // Браузер или другая среда
    global.MyLibrary = factory();
  }
})(typeof window !== "undefined" ? window : this, function () {
  // Код библиотеки
  return {
    version: "1.0.0",
    // ... другие публичные методы и свойства
  };
});
```

**3. Создание приватных счетчиков и генераторов**

```javascript
const uniqueIdGenerator = (function () {
  let id = 0;

  return function () {
    return `id_${++id}`;
  };
})();

console.log(uniqueIdGenerator()); // "id_1"
console.log(uniqueIdGenerator()); // "id_2"
```

**4. Перезаписывание глобальных переменных (например, для полифилов)**

```javascript
// Полифил для Array.prototype.includes, если он не существует
(function () {
  if (!Array.prototype.includes) {
    Array.prototype.includes = function (searchElement, fromIndex) {
      // Реализация метода includes
      // ...
    };
  }
})();
```

**5. Управление состоянием в одностраничных приложениях**

```javascript
const AppState = (function () {
  let state = {
    user: null,
    isAuthenticated: false,
    preferences: {},
  };

  const listeners = [];

  function notifyListeners() {
    listeners.forEach((listener) => listener(state));
  }

  return {
    getState() {
      return { ...state }; // Возвращаем копию состояния
    },
    setState(newState) {
      state = { ...state, ...newState };
      notifyListeners();
    },
    subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    },
  };
})();

// Использование
AppState.setState({ isAuthenticated: true });
console.log(AppState.getState().isAuthenticated); // true

const unsubscribe = AppState.subscribe((state) => {
  console.log("Состояние изменилось:", state);
});
```

**Преимущества IIFE:**

1. **Приватная область видимости**: Переменные и функции, объявленные внутри IIFE, не загрязняют глобальный объект.
2. **Инкапсуляция**: Можно создавать приватные данные, доступные только через замыкания.
3. **Изоляция**: Код внутри IIFE изолирован от внешней области видимости, что предотвращает конфликты имен.
4. **Структурированность**: Помогает организовать код в модули (до появления нативных модулей ES6).

**Современные альтернативы:**

С появлением блочной области видимости (`let`, `const`), модулей ES6 и классов, необходимость в IIFE уменьшилась:

```javascript
// Вместо IIFE для создания приватных переменных
// Блочная область видимости с let и const
{
  const privateData = "секрет";
  // Код здесь
}
// privateData недоступна здесь

// Вместо IIFE для создания модулей
// ES6 модули (file.js)
const privateVariable = "секрет";

export function publicFunction() {
  return privateVariable;
}
```

Тем не менее, IIFE все еще имеют свои применения и остаются важным паттерном в инструментарии JavaScript-разработчика.

</details>

<details>
<summary>
### 15. Что такое функции высшего порядка (Higher Order Functions)?
</summary>

Функции высшего порядка (Higher Order Functions) — это функции, которые работают с другими функциями, либо принимая их в качестве аргументов, либо возвращая их. Этот концепт является фундаментальным для функционального программирования в JavaScript.

**Определение:**

1. Функция, которая принимает другую функцию как аргумент
2. Функция, которая возвращает другую функцию
3. Функция, которая и принимает, и возвращает функции

**Примеры функций высшего порядка:**

**1. Функция, принимающая функцию как аргумент:**

```javascript
// Пример: функция forEach
function forEach(array, callback) {
  for (let i = 0; i < array.length; i++) {
    callback(array[i], i, array);
  }
}

// Использование
forEach([1, 2, 3], function (item) {
  console.log(item * 2); // 2, 4, 6
});

// Встроенные методы массивов - тоже функции высшего порядка
[1, 2, 3].map((x) => x * 2); // [2, 4, 6]
[1, 2, 3, 4].filter((x) => x > 2); // [3, 4]
[1, 2, 3, 4].reduce((acc, x) => acc + x, 0); // 10
```

**2. Функция, возвращающая функцию:**

```javascript
// Функция, создающая приветствие
function createGreeting(greeting) {
  // Возвращаем новую функцию
  return function (name) {
    return `${greeting}, ${name}!`;
  };
}

// Создаем конкретные функции приветствия
const sayHello = createGreeting("Привет");
const sayGoodMorning = createGreeting("Доброе утро");

// Используем созданные функции
console.log(sayHello("Иван")); // "Привет, Иван!"
console.log(sayGoodMorning("Мария")); // "Доброе утро, Мария!"
```

**3. Комбинированный пример:**

```javascript
// Создаем функцию-обертку для логирования
function withLogging(fn) {
  // Возвращаем новую функцию
  return function (...args) {
    console.log(`Вызов функции с аргументами: ${args}`);
    const result = fn(...args);
    console.log(`Результат: ${result}`);
    return result;
  };
}

// Оборачиваем обычную функцию
const sum = (a, b) => a + b;
const loggedSum = withLogging(sum);

// Используем обернутую функцию
loggedSum(2, 3);
// Вывод:
// "Вызов функции с аргументами: 2,3"
// "Результат: 5"
```

**Практические примеры использования функций высшего порядка:**

**1. Обработка массивов:**

```javascript
const numbers = [1, 2, 3, 4, 5];

// Используем map для создания нового массива
const doubled = numbers.map((n) => n * 2); // [2, 4, 6, 8, 10]

// Используем filter для создания подмножества
const even = numbers.filter((n) => n % 2 === 0); // [2, 4]

// Используем reduce для агрегации
const sum = numbers.reduce((acc, n) => acc + n, 0); // 15

// Использование нескольких функций высшего порядка вместе (композиция)
const sumOfDoubledEven = numbers
  .filter((n) => n % 2 === 0) // [2, 4]
  .map((n) => n * 2) // [4, 8]
  .reduce((acc, n) => acc + n, 0); // 12
```

**2. Управление функциональностью:**

```javascript
// Функция-декоратор для добавления кэширования
function memoize(fn) {
  const cache = {};

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache[key] === undefined) {
      cache[key] = fn(...args);
    }

    return cache[key];
  };
}

// Рекурсивная функция для вычисления чисел Фибоначчи
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Создаем кэшированную версию функции
const memoizedFibonacci = memoize(fibonacci);

console.time("regular");
fibonacci(35); // Медленно
console.timeEnd("regular");

console.time("memoized");
memoizedFibonacci(35); // Быстро
console.timeEnd("memoized");
```

**3. Отложенное выполнение (currying):**

```javascript
// Функция currying
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    } else {
      return function (...moreArgs) {
        return curried(...args, ...moreArgs);
      };
    }
  };
}

// Обычная функция с тремя параметрами
function sum(a, b, c) {
  return a + b + c;
}

// Создаем каррированную функцию
const curriedSum = curry(sum);

// Различные способы вызова
console.log(curriedSum(1, 2, 3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2)(3)); // 6
```

**4. Управление событиями и асинхронным кодом:**

```javascript
// Функция-обертка для добавления debounce
function debounce(fn, delay) {
  let timer = null;

  return function (...args) {
    clearTimeout(timer);

    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// Функция, которая будет вызываться при изменении размера окна
function handleResize() {
  console.log("Размер окна изменен!");
}

// Создаем debounced версию функции
const debouncedHandleResize = debounce(handleResize, 300);

// Использование
window.addEventListener("resize", debouncedHandleResize);
```

**Преимущества функций высшего порядка:**

1. **Абстракция и модульность** — позволяют создавать более высокий уровень абстракции
2. **Повторное использование кода** — общая функциональность может быть выделена в отдельные функции
3. **Композиция** — позволяет комбинировать функции для создания сложного поведения
4. **Декларативность** — делают код более декларативным, фокусируясь на "что" делать, а не "как"
5. **Тестируемость** — делают код более модульным и легче тестируемым

**Потенциальные сложности:**

1. **Сложность понимания** — вложенные функции и замыкания могут быть трудны для понимания
2. **Отладка** — стек вызовов может быть сложнее анализировать
3. **Производительность** — создание замыканий и новых функций при каждом вызове может быть менее эффективным

**Функции высшего порядка в современных библиотеках и фреймворках:**

1. **React** — компоненты высшего порядка (HOC) и хуки
2. **Redux** — middleware и enhancers
3. **RxJS** — операторы для работы с Observable
4. **Lodash/Ramda** — многочисленные служебные функции для работы с коллекциями и функциями

В целом, функции высшего порядка являются одним из мощнейших механизмов в JavaScript, позволяющих писать гибкий, модульный и выразительный код.

</details>

<details>
<summary>
### 16. Что такое замыкания (Closures) и как они работают?
</summary>

Замыкание (Closure) — это комбинация функции и её лексического окружения (lexical environment), в котором эта функция была объявлена. Замыкание позволяет функции сохранять доступ к переменным из внешней области видимости даже после того, как эта внешняя функция завершила выполнение.

**Ключевые аспекты замыканий:**

1. Функция имеет доступ к переменным, определённым в месте её объявления, а не в месте вызова
2. Внутренняя функция сохраняет доступ к переменным внешней функции даже после завершения внешней функции
3. Переменные из внешней области видимости не копируются, а именно сохраняется ссылка на них

**Простой пример замыкания:**

```javascript
function createCounter() {
  let count = 0; // Переменная, которая будет захвачена замыканием

  return function () {
    return ++count; // Функция имеет доступ к переменной count
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Создаем еще один счетчик (независимый от первого)
const counter2 = createCounter();
console.log(counter2()); // 1 (независимый счетчик)
```

В этом примере внутренняя функция сохраняет ссылку на переменную `count` из внешней функции `createCounter`. Даже после того, как `createCounter` завершается, внутренняя функция всё ещё может обращаться к переменной `count` и изменять её.

**Как работают замыкания на уровне движка JavaScript:**

1. Когда функция создаётся, она сохраняет ссылку на текущее лексическое окружение (Lexical Environment)
2. Лексическое окружение содержит все локальные переменные и параметры функции
3. Когда функция обращается к переменной, JavaScript сначала ищет её в текущем лексическом окружении, а затем в сохранённых внешних окружениях
4. Сборщик мусора не удаляет переменные из внешних функций, если они всё ещё используются в замыкании

**Практические примеры использования замыканий:**

**1. Инкапсуляция данных (приватные переменные):**

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Приватная переменная

  return {
    deposit: function (amount) {
      balance += amount;
      return balance;
    },
    withdraw: function (amount) {
      if (amount > balance) {
        console.log("Недостаточно средств");
        return balance;
      }
      balance -= amount;
      return balance;
    },
    getBalance: function () {
      return balance;
    },
  };
}

const account = createBankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500
account.withdraw(200);
console.log(account.getBalance()); // 1300

// Невозможно напрямую изменить balance извне
// account.balance = 0; // Не сработает
```

**2. Создание функций-фабрик:**

```javascript
function createMultiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**3. Замыкания в обработчиках событий:**

```javascript
function setupHandlers() {
  for (let i = 0; i < 3; i++) {
    const button = document.createElement("button");
    button.textContent = `Кнопка ${i}`;

    // Создаем замыкание для каждого обработчика
    button.addEventListener("click", function () {
      console.log(`Нажата кнопка ${i}`);
    });

    document.body.appendChild(button);
  }
}

// Каждая кнопка "запоминает" свой индекс благодаря замыканию
```

**4. Мемоизация (кэширование результатов):**

```javascript
function memoize(fn) {
  const cache = {};

  return function (...args) {
    const key = JSON.stringify(args);

    if (!(key in cache)) {
      cache[key] = fn(...args);
    }

    return cache[key];
  };
}

// Дорогостоящая функция
function computeExpensive(n) {
  console.log(`Вычисление для ${n}...`);
  // Предположим, здесь сложные вычисления
  return n * n;
}

const memoizedCompute = memoize(computeExpensive);

console.log(memoizedCompute(4)); // Вычисление для 4... 16
console.log(memoizedCompute(4)); // 16 (берется из кэша, без повторного вычисления)
console.log(memoizedCompute(5)); // Вычисление для 5... 25
```

**5. Модульный паттерн (до появления модулей ES6):**

```javascript
const Module = (function () {
  // Приватные данные
  let privateData = "Я приватная информация";

  // Приватная функция
  function privateFunction() {
    return "Это приватная функция";
  }

  // Публичное API
  return {
    publicMethod: function () {
      return "Публичный метод вызывает: " + privateFunction();
    },
    getPrivateData: function () {
      return privateData;
    },
  };
})();

console.log(Module.publicMethod()); // "Публичный метод вызывает: Это приватная функция"
console.log(Module.getPrivateData()); // "Я приватная информация"
// console.log(Module.privateFunction()); // Ошибка: privateFunction не определена
```

**6. Управление асинхронными операциями:**

```javascript
function fetchDataWithRetry(url, maxRetries) {
  let retries = 0;

  return function attempt() {
    return fetch(url).catch((error) => {
      if (retries < maxRetries) {
        retries++;
        console.log(`Попытка ${retries} из ${maxRetries}`);
        return attempt();
      }
      throw error;
    });
  };
}

// Создаем функцию для конкретного URL с 3 попытками
const fetchWithRetry = fetchDataWithRetry("https://api.example.com/data", 3);

// Использование
fetchWithRetry()
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Все попытки провалились:", error));
```

**Потенциальные проблемы с замыканиями:**

**1. Утечки памяти:**

```javascript
function setupHandler() {
  const element = document.getElementById("button");
  const heavyData = new Array(10000000).fill("data"); // Большой объект

  element.addEventListener("click", function () {
    // Использование heavyData
    console.log(heavyData.length);
  });

  // heavyData остается в памяти, так как на него есть ссылка из обработчика
}
```

**Решение:** Удаление обработчика событий, когда он больше не нужен.

**2. Замыкания в циклах (историческая проблема с `var`):**

```javascript
// Проблема с var (до ES6)
function createButtons() {
  for (var i = 0; i < 3; i++) {
    var button = document.createElement("button");
    button.textContent = "Кнопка " + i;

    button.addEventListener("click", function () {
      console.log("Нажата кнопка " + i); // i всегда будет 3 в момент клика
    });

    document.body.appendChild(button);
  }
}
```

**Решения:**

```javascript
// 1. Используйте IIFE для создания отдельного замыкания для каждой итерации
for (var i = 0; i < 3; i++) {
  (function (index) {
    var button = document.createElement("button");
    button.addEventListener("click", function () {
      console.log("Нажата кнопка " + index); // Правильное значение
    });
  })(i);
}

// 2. Используйте let вместо var (современное решение)
for (let i = 0; i < 3; i++) {
  const button = document.createElement("button");
  button.addEventListener("click", function () {
    console.log("Нажата кнопка " + i); // Правильное значение
  });
}
```

**Советы по работе с замыканиями:**

1. Используйте замыкания осознанно для создания приватных переменных
2. Будьте осторожны с созданием большого количества замыканий, захватывающих большие объемы данных
3. Помните, что переменные не копируются, а сохраняется ссылка на одно и то же значение
4. В современном JavaScript используйте `let` и `const` вместо `var` для избежания проблем с замыканиями в циклах
5. При работе с асинхронным кодом учитывайте, что замыкание "захватывает" значения на момент создания, а не на момент выполнения

Понимание замыканий является фундаментальным для эффективной работы с JavaScript и функциональным программированием в целом.

</details>

<details>
<summary>
### 17. Что такое рекурсия и когда ее следует использовать?
</summary>

Рекурсия — это техника программирования, при которой функция вызывает саму себя для решения более простых подзадач того же типа. Рекурсивная функция должна иметь базовый случай (условие выхода из рекурсии) и рекурсивный случай (шаг рекурсии).

**Ключевые компоненты рекурсивной функции:**

1. **Базовый случай (Base Case)** — условие, при котором рекурсия останавливается
2. **Рекурсивный случай (Recursive Case)** — вызов функции самой себя с измененными параметрами

**Простой пример рекурсии — вычисление факториала:**

```javascript
function factorial(n) {
  // Базовый случай
  if (n <= 1) {
    return 1;
  }

  // Рекурсивный случай
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 5 * 4 * 3 * 2 * 1 = 120
```

**Как работает рекурсия:**

1. При каждом рекурсивном вызове создается новый стековый фрейм (контекст выполнения)
2. Каждый вызов хранит свой набор локальных переменных
3. При достижении базового случая начинается процесс "раскрутки" стека вызовов и вычисление результата
4. В JavaScript есть ограничение на глубину стека вызовов (обычно около 10,000-15,000 вызовов)

**Примеры использования рекурсии:**

**1. Обход древовидных структур:**

```javascript
// Объект, представляющий файловую систему
const fileSystem = {
  name: "root",
  isFolder: true,
  children: [
    {
      name: "documents",
      isFolder: true,
      children: [
        { name: "document1.txt", isFolder: false },
        { name: "document2.txt", isFolder: false },
      ],
    },
    {
      name: "pictures",
      isFolder: true,
      children: [
        { name: "pic1.jpg", isFolder: false },
        { name: "pic2.jpg", isFolder: false },
      ],
    },
    { name: "config.json", isFolder: false },
  ],
};

// Функция для поиска всех файлов
function findAllFiles(node) {
  let files = [];

  // Базовый случай — это файл
  if (!node.isFolder) {
    return [node.name];
  }

  // Рекурсивный случай — это папка
  if (node.children) {
    node.children.forEach((child) => {
      files = files.concat(findAllFiles(child));
    });
  }

  return files;
}

console.log(findAllFiles(fileSystem));
// ["document1.txt", "document2.txt", "pic1.jpg", "pic2.jpg", "config.json"]
```

**2. Обход и манипуляции с DOM:**

```javascript
function getAllTextNodes(element, results = []) {
  // Проверяем каждый дочерний узел
  for (let i = 0; i < element.childNodes.length; i++) {
    const node = element.childNodes[i];

    // Базовый случай - текстовый узел
    if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "") {
      results.push(node);
    }

    // Рекурсивный случай - элемент, который может содержать другие узлы
    if (node.nodeType === Node.ELEMENT_NODE) {
      getAllTextNodes(node, results);
    }
  }

  return results;
}

// Пример использования
const textNodes = getAllTextNodes(document.body);
console.log(`Найдено ${textNodes.length} текстовых узлов`);
```

**3. Алгоритмы "разделяй и властвуй" (divide and conquer):**

```javascript
// Быстрая сортировка (QuickSort)
function quickSort(arr) {
  // Базовый случай
  if (arr.length <= 1) {
    return arr;
  }

  // Выбираем опорный элемент
  const pivot = arr[Math.floor(arr.length / 2)];

  // Разделяем массив на три части
  const less = arr.filter((x) => x < pivot);
  const equal = arr.filter((x) => x === pivot);
  const greater = arr.filter((x) => x > pivot);

  // Рекурсивно сортируем и объединяем результаты
  return [...quickSort(less), ...equal, ...quickSort(greater)];
}

console.log(quickSort([10, 5, 2, 3, 7, 8, 1, 9, 4, 6]));
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

**4. Решение математических задач:**

```javascript
// Числа Фибоначчи (наивная рекурсия)
function fibonacci(n) {
  // Базовый случай
  if (n <= 1) {
    return n;
  }

  // Рекурсивный случай
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(10)); // 55

// Улучшенная версия с мемоизацией
function fibonacciMemo(n, memo = {}) {
  // Проверяем, есть ли результат в кэше
  if (n in memo) {
    return memo[n];
  }

  // Базовый случай
  if (n <= 1) {
    return n;
  }

  // Сохраняем результат в кэше
  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

console.log(fibonacciMemo(100)); // Быстрый расчет большого числа Фибоначчи
```

**5. Рекурсивный обход вложенных массивов:**

```javascript
// Функция для плоского представления вложенных массивов
function flatten(arr) {
  let result = [];

  for (let i = 0; i < arr.length; i++) {
    // Базовый случай — элемент не является массивом
    if (!Array.isArray(arr[i])) {
      result.push(arr[i]);
    } else {
      // Рекурсивный случай — элемент является массивом
      result = result.concat(flatten(arr[i]));
    }
  }

  return result;
}

console.log(flatten([1, [2, [3, 4], 5], 6, [7, 8]]));
// [1, 2, 3, 4, 5, 6, 7, 8]
```

**Преимущества рекурсии:**

1. **Лаконичность** — рекурсивный код часто короче и яснее итеративного аналога
2. **Естественность** — многие алгоритмы и структуры данных лучше описываются рекурсивно
3. **Модульность** — рекурсивный подход часто упрощает декомпозицию сложной проблемы

**Недостатки рекурсии:**

1. **Расход памяти** — каждый рекурсивный вызов занимает место в стеке вызовов
2. **Риск переполнения стека** — при глубокой рекурсии может произойти ошибка "stack overflow"
3. **Производительность** — на каждый вызов функции требуются дополнительные ресурсы

**Когда стоит использовать рекурсию:**

1. Проблема естественным образом разделяется на подзадачи того же типа
2. При работе с древовидными или рекурсивными структурами данных (DOM, графы, деревья)
3. Когда глубина рекурсии предсказуема и не слишком велика
4. В алгоритмах "разделяй и властвуй"

**Когда не стоит использовать рекурсию:**

1. Когда глубина рекурсии может быть очень большой (риск переполнения стека)
2. В производительно-критичном коде без оптимизаций (мемоизация, хвостовая рекурсия)
3. Когда итеративное решение очевидно и значительно эффективнее

**Оптимизация рекурсии:**

**1. Мемоизация (кэширование результатов):**

```javascript
function memoize(fn) {
  const cache = {};

  return function (...args) {
    const key = JSON.stringify(args);

    if (!(key in cache)) {
      cache[key] = fn.apply(this, args);
    }

    return cache[key];
  };
}

// Применение мемоизации к рекурсивной функции
const memoizedFibonacci = memoize(function (n) {
  if (n <= 1) return n;
  return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

console.log(memoizedFibonacci(100)); // Быстрый расчет
```

**2. Хвостовая рекурсия (Tail Call Optimization):**

```javascript
// Обычная рекурсия факториала
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Не хвостовая рекурсия: нужно умножить после возврата
}

// Хвостовая рекурсия факториала
function factorialTail(n, acc = 1) {
  if (n <= 1) return acc;
  return factorialTail(n - 1, n * acc); // Хвостовая рекурсия: результат уже вычислен
}

// Примечание: только некоторые JavaScript движки оптимизируют хвостовую рекурсию
```

**3. Преобразование рекурсии в итерацию:**

```javascript
// Рекурсивный факториал
function factorialRecursive(n) {
  if (n <= 1) return 1;
  return n * factorialRecursive(n - 1);
}

// Итеративный факториал
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// Оба дают одинаковый результат, но итеративная версия эффективнее для больших значений
console.log(factorialIterative(1000)); // Не вызовет переполнения стека
```

Рекурсия — мощный инструмент в арсенале разработчика, но его следует использовать с пониманием как преимуществ, так и ограничений.

</details>

<details>
<summary>16. Что такое частичное применение функций?</summary>

Частичное применение функций — это способ создать новую функцию на основе существующей, зафиксировав некоторые из её аргументов заранее. По сути, мы "подготавливаем" часть параметров заранее, чтобы потом вызывать функцию с меньшим количеством аргументов.

**Простыми словами:**
Представьте, что у вас есть функция умножения трёх чисел. С помощью частичного применения вы можете создать новую функцию умножения на 5, где первый аргумент уже зафиксирован как 5.

**Примеры:**

1. **Простой пример без специальных методов:**

```javascript
function multiply(a, b, c) {
  return a * b * c;
}

// Создаем новую функцию, где первый аргумент всегда 5
function multiplyBy5(b, c) {
  return multiply(5, b, c);
}

// Теперь можно вызывать с меньшим числом аргументов
console.log(multiplyBy5(2, 3)); // 30 (5 * 2 * 3)
```

2. **Использование метода `bind()`:**
   JavaScript предоставляет встроенный метод для частичного применения:

```javascript
function multiply(a, b, c) {
  return a * b * c;
}

// Здесь мы фиксируем первый аргумент как 5
const multiplyBy5 = multiply.bind(null, 5);
console.log(multiplyBy5(2, 3)); // 30 (5 * 2 * 3)

// Можно зафиксировать и два аргумента
const multiplyBy5And2 = multiply.bind(null, 5, 2);
console.log(multiplyBy5And2(3)); // 30 (5 * 2 * 3)
```

3. **Универсальная функция для частичного применения:**

```javascript
// Функция для частичного применения любой другой функции
function partial(fn, ...fixedArgs) {
  return function (...remainingArgs) {
    return fn(...fixedArgs, ...remainingArgs);
  };
}

// Пример использования
function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

// Создаем функцию приветствия, где приветствие всегда "Привет"
const sayHello = partial(greet, "Привет");
console.log(sayHello("Мария")); // "Привет, Мария!"
```

**Отличие от каррирования:**

- **Частичное применение:** фиксирует несколько аргументов сразу и возвращает функцию, ожидающую оставшиеся аргументы.
- **Каррирование:** преобразует функцию с несколькими аргументами в цепочку функций, каждая из которых принимает по одному аргументу.

**Практическая польза:**

1. Создание специализированных функций из общих (например, функция `logError` из общей функции `log`)
2. Уменьшение повторения кода, когда одни и те же аргументы используются многократно
3. Улучшение читаемости кода за счет использования функций с более понятными названиями
4. Отложенное выполнение функций с предустановленными параметрами
</details>

<details>
<summary>17. Что такое каррирование функций?</summary>

Каррирование функций — это техника преобразования функции с несколькими аргументами в последовательность вложенных функций, каждая из которых принимает только один аргумент. Название происходит от имени математика Хаскелла Карри.

**Простыми словами:**
Вместо вызова функции со всеми аргументами сразу `sum(1, 2, 3)`, при каррировании вы вызываете её последовательно по одному аргументу: `sum(1)(2)(3)`. Это позволяет создавать промежуточные функции на каждом шаге.

**Визуальное сравнение:**

Обычная функция:

```
sum(1, 2, 3) ➝ 6
```

Каррированная функция:

```
sum(1) ➝ [функция]
sum(1)(2) ➝ [функция]
sum(1)(2)(3) ➝ 6
```

**Простой пример каррирования:**

```javascript
// Обычная функция
function sum(a, b, c) {
  return a + b + c;
}

// Каррированная версия той же функции
function curriedSum(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}

// Использование
console.log(sum(1, 2, 3)); // 6
console.log(curriedSum(1)(2)(3)); // 6

// Можно сохранять промежуточные функции
const step1 = curriedSum(1); // функция, ожидающая аргумент b
const step2 = step1(2); // функция, ожидающая аргумент c
const result = step2(3); // финальный результат
console.log(result); // 6
```

**Более компактная запись с помощью стрелочных функций:**

```javascript
const curriedSum = (a) => (b) => (c) => a + b + c;
console.log(curriedSum(1)(2)(3)); // 6
```

**Универсальная функция для каррирования:**

```javascript
// Создаёт каррированную версию любой функции
function curry(fn) {
  return function curried(...args) {
    // Если передано достаточно аргументов, вызываем исходную функцию
    if (args.length >= fn.length) {
      return fn(...args);
    }
    // Иначе возвращаем функцию, ожидающую оставшиеся аргументы
    return function (...moreArgs) {
      return curried(...args, ...moreArgs);
    };
  };
}

// Использование
function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);

// Теперь можно вызывать функцию разными способами
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
console.log(curriedSum(1, 2, 3)); // 6
```

**Практическая польза каррирования:**

1. **Создание специализированных функций:**

   ```javascript
   // Функция умножения
   const multiply = (a) => (b) => a * b;

   // Создаём специализированные функции
   const double = multiply(2); // Функция удваивания
   const triple = multiply(3); // Функция утраивания

   console.log(double(5)); // 10
   console.log(triple(5)); // 15
   ```

2. **Улучшение повторного использования кода**  
   Можно создавать библиотеки функций, которые легко комбинировать.

3. **Отложенное выполнение**  
   Функция не выполняется, пока не получит все свои аргументы.

4. **Функциональное программирование**  
   Каррирование является основой для композиции функций и других техник функционального программирования.

Каррирование активно используется в функциональных библиотеках JavaScript, таких как Ramda и Lodash/FP, позволяя создавать гибкие и выразительные конструкции.

</details>

<details>
<summary>19. Как работают генераторные функции?</summary>

Генераторные функции — это особый вид функций в JavaScript, которые могут приостанавливать своё выполнение и возобновлять его позже, сохраняя все внутренние переменные и состояние между вызовами.

**Простыми словами:**
Обычная функция работает по принципу "зашёл-отработал-вышел". Генератор же умеет "делать паузу" в середине своей работы, возвращать промежуточный результат, а затем продолжать работу с того места, где остановился.

**Ключевые особенности:**

1. **Отличительный синтаксис:** звездочка `*` после слова `function`
2. **Ключевое слово `yield`:** позволяет "выдать" значение и приостановить выполнение
3. **Сохранение состояния:** все переменные и позиция выполнения сохраняются между вызовами
4. **Возвращает объект-итератор:** с методами `next()`, `return()` и `throw()`

**Базовый пример:**

```javascript
// Объявление генераторной функции (обратите внимание на звездочку *)
function* simpleGenerator() {
  console.log("Начало генератора");
  yield 1; // Первая точка остановки
  console.log("После первого yield");
  yield 2; // Вторая точка остановки
  console.log("После второго yield");
  yield 3; // Третья точка остановки
  console.log("Конец генератора");
  return "Готово"; // Финальное значение
}

// Создаём генератор (он ещё не начал работу!)
const generator = simpleGenerator();

// Запускаем генератор поэтапно
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: 'Готово', done: true }
console.log(generator.next()); // { value: undefined, done: true }
```

**Поэтапное выполнение:**

1. Первый вызов `generator.next()` запускает выполнение до первого `yield`.
2. Каждый последующий вызов `next()` возобновляет выполнение до следующего `yield`.
3. После последнего `yield` функция завершается, `done` становится `true`.

**Использование в цикле for...of:**

```javascript
function* countToFive() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
}

// Автоматически проходит по всем значениям генератора
for (const num of countToFive()) {
  console.log(num); // Выведет числа от 1 до 5
}
```

**Двусторонняя коммуникация:**
Генераторы могут не только отдавать значения, но и получать их через `next()`:

```javascript
function* communicationGenerator() {
  // Получаем значение из next() и выводим его
  const input1 = yield "Вопрос 1: Как вас зовут?";
  console.log(`Получен ответ: ${input1}`);

  const input2 = yield "Вопрос 2: Сколько вам лет?";
  console.log(`Получен ответ: ${input2}`);

  return "Опрос завершен";
}

const dialogue = communicationGenerator();

// Первый next() запускает генератор до первого yield
console.log(dialogue.next());
// { value: 'Вопрос 1: Как вас зовут?', done: false }

// Второй next() передает ответ на первый вопрос и доходит до второго yield
console.log(dialogue.next("Иван"));
// Получен ответ: Иван
// { value: 'Вопрос 2: Сколько вам лет?', done: false }

// Третий next() передает ответ на второй вопрос и завершает генератор
console.log(dialogue.next("30"));
// Получен ответ: 30
// { value: 'Опрос завершен', done: true }
```

**Практические применения:**

1. **Работа с большими наборами данных** (ленивые вычисления):

   ```javascript
   function* fibonacci() {
     let [a, b] = [0, 1];
     while (true) {
       yield a;
       [a, b] = [b, a + b];
     }
   }

   const fib = fibonacci();
   // Генерируем только нужные числа Фибоначчи, не вычисляя всю последовательность
   for (let i = 0; i < 10; i++) {
     console.log(fib.next().value); // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
   }
   ```

2. **Упрощение асинхронного кода** (до появления async/await):

   ```javascript
   function* fetchUserData() {
     try {
       const response = yield fetch("https://api.example.com/user");
       const userData = yield response.json();
       console.log(userData);
     } catch (error) {
       console.error("Ошибка:", error);
     }
   }

   // Функция для запуска генератора с поддержкой Promise
   function runGenerator(generator) {
     const iterator = generator();

     function handle(result) {
       if (result.done) return result.value;

       return Promise.resolve(result.value)
         .then((value) => handle(iterator.next(value)))
         .catch((error) => handle(iterator.throw(error)));
     }

     return handle(iterator.next());
   }

   runGenerator(fetchUserData);
   ```

3. **Обход структур данных** (деревья, графы и т.д.):

   ```javascript
   function* traverseTree(node) {
     yield node.value;

     if (node.left) {
       yield* traverseTree(node.left); // yield* делегирует выполнение другому генератору
     }

     if (node.right) {
       yield* traverseTree(node.right);
     }
   }
   ```

Генераторы особенно полезны в сценариях, где вам нужен поэтапный доступ к данным или когда необходимо контролировать порядок выполнения асинхронных операций.

</details>

<details>
<summary>20. Что такое мемоизация?</summary>

Мемоизация — это техника оптимизации, которая позволяет ускорить работу функций за счёт запоминания (кеширования) результатов их выполнения для одних и тех же входных данных.

**Простыми словами:**
Представьте, что вы решаете сложную математическую задачу. Вместо того чтобы каждый раз решать её заново при тех же исходных данных, вы можете записать ответ и в следующий раз просто посмотреть в свои записи. Это и есть мемоизация.

**Как это работает:**

1. Функция проверяет, вызывалась ли она ранее с такими же аргументами
2. Если да — возвращает сохранённый результат из кеша
3. Если нет — вычисляет результат, сохраняет его в кеш и возвращает

**Наглядный пример — вычисление чисел Фибоначчи:**

```javascript
// Обычная рекурсивная функция без мемоизации
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Та же функция с мемоизацией
function memoizedFibonacci() {
  // Кеш для хранения результатов
  const cache = {};

  // Возвращаем функцию, которая использует кеш
  return function fib(n) {
    // Проверяем, есть ли результат в кеше
    if (n in cache) {
      return cache[n];
    }

    // Вычисляем результат, если его нет в кеше
    let result;
    if (n <= 1) {
      result = n;
    } else {
      result = fib(n - 1) + fib(n - 2);
    }

    // Сохраняем результат в кеш
    cache[n] = result;
    return result;
  };
}

const fastFibonacci = memoizedFibonacci();

// Сравнение скорости выполнения
console.time("Без мемоизации");
fibonacci(35); // Займет много времени
console.timeEnd("Без мемоизации");

console.time("С мемоизацией");
fastFibonacci(35); // Выполнится гораздо быстрее
console.timeEnd("С мемоизацией");

// Повторный вызов с теми же аргументами будет мгновенным
console.time("Повторный вызов с мемоизацией");
fastFibonacci(35); // Результат берется из кеша
console.timeEnd("Повторный вызов с мемоизацией");
```

**Универсальная функция для мемоизации:**

```javascript
function memoize(fn) {
  // Создаем объект для хранения результатов
  const cache = {};

  // Возвращаем функцию-обертку
  return function (...args) {
    // Создаем уникальный ключ на основе аргументов
    const key = JSON.stringify(args);

    // Проверяем, есть ли результат в кеше
    if (!(key in cache)) {
      // Вычисляем результат, если его нет в кеше
      cache[key] = fn.apply(this, args);
    }

    // Возвращаем кешированный результат
    return cache[key];
  };
}

// Пример использования
const expensiveCalculation = (x, y) => {
  console.log("Выполняется сложное вычисление...");
  return x * y;
};

const memoizedCalculation = memoize(expensiveCalculation);

console.log(memoizedCalculation(5, 3)); // Выполняется вычисление
console.log(memoizedCalculation(5, 3)); // Результат берется из кеша
console.log(memoizedCalculation(2, 8)); // Новое вычисление
console.log(memoizedCalculation(2, 8)); // Результат берется из кеша
```

**Когда стоит использовать мемоизацию:**

1. **Ресурсоемкие вычисления** — функции, требующие значительного процессорного времени
2. **Рекурсивные функции** — особенно с перекрывающимися подзадачами (как числа Фибоначчи)
3. **Функции, часто вызываемые с одними и теми же аргументами**
4. **Чистые функции** — функции без побочных эффектов, возвращающие одинаковый результат для одинаковых входных данных

**Ограничения и потенциальные проблемы:**

1. **Расход памяти** — кеш может занимать значительный объем при большом количестве разных входных данных
2. **Сложные объекты** — могут возникнуть проблемы с использованием объектов в качестве ключей кеша
3. **Побочные эффекты** — функции с побочными эффектами не подходят для мемоизации
4. **Устаревшие данные** — если источник данных меняется, кешированные результаты могут устареть

**Использование в современном JavaScript:**

В React экосистеме есть встроенные инструменты для мемоизации:

```javascript
import React, { useMemo } from "react";

function ExpensiveComponent({ data, filter }) {
  // useMemo — встроенная функция для мемоизации результатов вычислений
  const filteredData = useMemo(() => {
    console.log("Фильтрация данных...");
    return data.filter((item) => item.includes(filter));
  }, [data, filter]); // Пересчет только при изменении этих зависимостей

  return (
    <ul>
      {filteredData.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

Мемоизация — мощный инструмент оптимизации, который следует применять обдуманно, взвешивая преимущества в скорости против увеличения потребления памяти.

</details>

<details>
<summary>108. Как создать функцию с запоминанием предыдущих результатов (мемоизация)?</summary>

Функция с запоминанием предыдущих результатов (мемоизация) позволяет значительно ускорить выполнение повторяющихся вычислений. Рассмотрим, как создать такую функцию на практике, с понятными примерами.

**Базовый шаблон мемоизации:**

```javascript
function memoize(fn) {
  // Создаем хранилище результатов — обычный объект
  const cache = {};

  // Возвращаем функцию-обертку с памятью
  return function (...args) {
    // Преобразуем аргументы в строку для использования в качестве ключа
    const key = JSON.stringify(args);

    // Проверяем, выполнялся ли уже расчет с такими аргументами
    if (key in cache) {
      console.log("🚀 Беру готовый результат из памяти!");
      return cache[key];
    }

    // Если результата нет в памяти, вычисляем его
    console.log("🔧 Выполняю вычисление...");
    const result = fn.apply(this, args);

    // Сохраняем результат в памяти
    cache[key] = result;

    return result;
  };
}
```

**Пример 1: Факториал с мемоизацией**

```javascript
// Обычная функция вычисления факториала
function factorial(n) {
  if (n === 0 || n === 1) return 1;
  return n * factorial(n - 1);
}

// Создаем версию с памятью
const memoizedFactorial = memoize(factorial);

// Сравним работу
console.log(memoizedFactorial(5)); // 🔧 Выполняю вычисление... 120
console.log(memoizedFactorial(5)); // 🚀 Беру готовый результат из памяти! 120
console.log(memoizedFactorial(6)); // 🔧 Выполняю вычисление... 720
```

**Пример 2: Функция с несколькими аргументами**

```javascript
// Функция, которая складывает два числа (просто для примера)
function add(a, b) {
  console.log("Сложение занимает время...");
  // Имитация сложной работы
  const start = Date.now();
  while (Date.now() - start < 100) {} // Ждем 100 мс
  return a + b;
}

// Создаем версию с памятью
const memoizedAdd = memoize(add);

console.log(memoizedAdd(10, 20)); // Выполняет сложение
console.log(memoizedAdd(10, 20)); // Берет из памяти
console.log(memoizedAdd(5, 15)); // Выполняет новое сложение
console.log(memoizedAdd(10, 20)); // Берет из памяти
```

**Пример 3: Ограничение размера кеша**

Для предотвращения утечек памяти можно добавить ограничение на размер кеша:

```javascript
function memoizeWithLimit(fn, limit = 10) {
  // Используем Map, чтобы отслеживать порядок добавления ключей
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      // Найдено в кеше — перемещаем ключ в конец (как недавно использованный)
      const value = cache.get(key);
      cache.delete(key);
      cache.set(key, value);
      return value;
    }

    // Вычисляем новый результат
    const result = fn.apply(this, args);

    // Если кеш достиг предела, удаляем самый старый элемент (первый в Map)
    if (cache.size >= limit) {
      const oldestKey = cache.keys().next().value;
      cache.delete(oldestKey);
    }

    // Добавляем новый результат в кеш
    cache.set(key, result);
    return result;
  };
}

// Использование
const limitedMemoize = memoizeWithLimit(add, 2);
limitedMemoize(1, 2); // Кеш: [{1,2}]
limitedMemoize(3, 4); // Кеш: [{1,2}, {3,4}]
limitedMemoize(5, 6); // Кеш: [{3,4}, {5,6}] — {1,2} удален как самый старый
limitedMemoize(3, 4); // Кеш: [{5,6}, {3,4}] — {3,4} перемещен в конец как недавно использованный
```

**Пример 4: Работа с объектами в качестве аргументов**

Для объектов можно использовать WeakMap, который позволяет сборщику мусора очищать память:

```javascript
function memoizeObjects(fn) {
  const cache = new WeakMap();

  return function (obj) {
    // Проверяем, есть ли объект в кеше
    if (!cache.has(obj)) {
      // Вычисляем результат
      const result = fn(obj);
      cache.set(obj, result);
    }

    return cache.get(obj);
  };
}

// Пример использования — расчет площади прямоугольника
const calculateArea = memoizeObjects((rect) => {
  console.log("Вычисляем площадь...");
  return rect.width * rect.height;
});

const rectangle = { width: 5, height: 3 };
console.log(calculateArea(rectangle)); // Вычисляем площадь... 15
console.log(calculateArea(rectangle)); // 15 (из кеша)
```

**Пример 5: Мемоизация для асинхронных функций**

```javascript
function memoizeAsync(fn) {
  const cache = new Map();

  return async function (...args) {
    const key = JSON.stringify(args);

    // Если запрос уже выполняется или выполнен — возвращаем промис
    if (cache.has(key)) {
      return cache.get(key);
    }

    // Создаем и сохраняем промис
    const promise = fn.apply(this, args);
    cache.set(key, promise);

    try {
      // Ожидаем выполнения
      await promise;
      return promise;
    } catch (error) {
      // В случае ошибки удаляем из кеша, чтобы можно было повторить запрос
      cache.delete(key);
      throw error;
    }
  };
}

// Пример с асинхронным запросом
const fetchUser = memoizeAsync(async (id) => {
  console.log(`Запрашиваю данные пользователя с ID ${id}...`);
  // Имитация запроса к API
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return { id, name: `Пользователь ${id}` };
});

// Использование
async function demo() {
  console.log(await fetchUser(1)); // Выполняет запрос
  console.log(await fetchUser(1)); // Возвращает данные из кеша
  console.log(await fetchUser(2)); // Выполняет новый запрос
}
demo();
```

**Советы по эффективному использованию мемоизации:**

1. **Используйте для тяжелых вычислений** — мемоизация создает накладные расходы, поэтому для очень простых операций она может не принести выгоды.

2. **Учитывайте потребление памяти** — каждый уникальный набор аргументов сохраняется в памяти. Если таких наборов много, рассмотрите возможность ограничения размера кеша.

3. **Подходит только для чистых функций** — если функция зависит от внешнего состояния или имеет побочные эффекты, мемоизация может привести к неожиданным результатам.

4. **Выбирайте подходящую стратегию кеширования:**
   - Обычный объект — для простых случаев
   - Map — когда важен порядок или нужны нестроковые ключи
   - WeakMap — для объектов, чтобы избежать утечек памяти

Правильно реализованная мемоизация может значительно ускорить работу вашего приложения, особенно при повторяющихся вычислениях.

</details>

<details>
<summary>Лексическое окружение</summary>

## Лексическое окружение в JavaScript

Лексическое окружение — это внутренний механизм JavaScript, который отвечает за хранение переменных и их значений во время выполнения кода. Проще говоря, это "контейнер", в котором хранятся все переменные, доступные в определенном месте кода.

### Как это работает — простыми словами

Представьте книгу, где каждая глава — это отдельная функция или блок кода, а переменные — это герои книги. Лексическое окружение определяет, какие "герои" (переменные) видны в каждой "главе" (функции).

Основные принципы:

1. Каждая функция или блок кода создает свое лексическое окружение
2. Внутренний блок может "видеть" переменные из внешнего блока
3. Внешний блок НЕ может "видеть" переменные из внутреннего блока
4. Когда код ищет переменную, он сначала смотрит в текущем окружении, затем в родительском и так далее

### Наглядный пример

```javascript
let userName = "Иван"; // Переменная в глобальном окружении

function greet() {
  let message = "Привет"; // Переменная в окружении функции greet

  function displayGreeting() {
    let exclamation = "!"; // Переменная в окружении функции displayGreeting

    // Здесь доступны все три переменные через цепочку окружений
    console.log(message + ", " + userName + exclamation); // "Привет, Иван!"
  }

  displayGreeting();

  // console.log(exclamation); // ❌ Ошибка: exclamation не определена
}

greet();
// console.log(message); // ❌ Ошибка: message не определена
```

В этом примере создаются три лексических окружения:

1. **Глобальное окружение**: содержит `userName` и `greet`
2. **Окружение функции `greet`**: содержит `message` и `displayGreeting`
3. **Окружение функции `displayGreeting`**: содержит `exclamation`

### Цепочка окружений и поиск переменных

Когда код внутри `displayGreeting` обращается к переменной, JavaScript:

1. Ищет ее в текущем окружении (`displayGreeting`)
2. Если не находит, ищет в родительском окружении (`greet`)
3. Если и там не находит, ищет в глобальном окружении
4. Если нигде не находит — выдает ошибку

### Замыкания (Closures) — главное следствие лексических окружений

Замыкание происходит, когда функция запоминает свое лексическое окружение даже после того, как внешняя функция завершила выполнение.

```javascript
function createCounter() {
  let count = 0; // Переменная в окружении createCounter

  return function () {
    // Возвращаем внутреннюю функцию
    return ++count; // Она имеет доступ к переменной count
  };
}

const counter = createCounter(); // Создаем счетчик

// Внешняя функция createCounter уже завершила работу,
// но внутренняя функция все еще имеет доступ к переменной count
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

**Объяснение:**

1. `createCounter` создает переменную `count` и возвращает функцию
2. Даже когда `createCounter` завершается, переменная `count` не удаляется
3. Внутренняя функция сохраняет ссылку на окружение, в котором она была создана
4. Каждый вызов `counter()` использует и изменяет ту же самую переменную `count`

### Блочная область видимости (Block Scope)

С появлением `let` и `const` в ES6, каждый блок кода `{}` также создает свое лексическое окружение:

```javascript
{
  let blockVar = "Я видна только в этом блоке";
  var oldVar = "Я игнорирую блоки (кроме функций)";

  console.log(blockVar); // ✓ Доступна
}

// console.log(blockVar);  // ❌ Ошибка: не определена
console.log(oldVar); // ✓ Доступна (var игнорирует блоки)
```

### Временная мертвая зона (Temporal Dead Zone)

Интересный эффект лексических окружений — переменные, объявленные через `let` и `const`, существуют в блоке с самого начала, но недоступны до строки объявления:

```javascript
console.log(varVariable); // undefined (из-за поднятия)
// console.log(letVariable);  // ❌ Ошибка: нельзя обращаться до объявления

var varVariable = "старый var";
let letVariable = "современный let";
```

### Практические примеры использования лексических окружений

**1. Приватные переменные через замыкания:**

```javascript
function createWallet(initialMoney) {
  // Приватная переменная, недоступная извне
  let money = initialMoney;

  return {
    getMoney() {
      return money;
    },
    addMoney(amount) {
      money += amount;
    },
    withdrawMoney(amount) {
      if (amount <= money) {
        money -= amount;
        return true;
      }
      return false;
    },
  };
}

const myWallet = createWallet(100);
console.log(myWallet.getMoney()); // 100
myWallet.addMoney(50);
console.log(myWallet.getMoney()); // 150
// console.log(myWallet.money);  // ❌ Undefined - переменная приватная
```

**2. Фабрики объектов:**

```javascript
function createUser(name, age) {
  // name и age запоминаются в замыкании
  return {
    getName() {
      return name;
    },
    getAge() {
      return age;
    },
    setAge(newAge) {
      age = newAge;
    },
  };
}

const user = createUser("Анна", 28);
console.log(user.getName()); // "Анна"
console.log(user.getAge()); // 28
user.setAge(29);
console.log(user.getAge()); // 29
```

**3. Модульный паттерн — организация кода:**

```javascript
const calculator = (function () {
  // Приватные переменные и функции
  let result = 0;

  function validate(n) {
    return typeof n === "number";
  }

  // Публичный API
  return {
    add(n) {
      if (validate(n)) {
        result += n;
      }
      return this;
    },
    subtract(n) {
      if (validate(n)) {
        result -= n;
      }
      return this;
    },
    getResult() {
      return result;
    },
  };
})();

calculator.add(5).add(10).subtract(3);
console.log(calculator.getResult()); // 12
// console.log(calculator.result);  // ❌ Undefined - приватная переменная
```

Понимание лексических окружений помогает писать более качественный код, избегать распространенных ошибок и эффективно использовать замыкания для создания приватных переменных и инкапсуляции данных.

</details>

## Объекты и прототипы

<details>
<summary>21. Как создать объект в JavaScript разными способами?</summary>

В JavaScript существует несколько способов создания объектов:

1. **Литерал объекта**:

```javascript
const obj = {
  property: "значение",
  method() {
    return "метод";
  },
};
```

2. **Конструктор Object**:

```javascript
const obj = new Object();
obj.property = "значение";
obj.method = function () {
  return "метод";
};
```

3. **Функция-конструктор**:

```javascript
function Person(name) {
  this.name = name;
  this.greet = function () {
    return `Привет, ${this.name}!`;
  };
}

const person = new Person("Иван");
```

4. **Object.create()**:

```javascript
const proto = {
  greet() {
    return `Привет, ${this.name}!`;
  },
};

const person = Object.create(proto);
person.name = "Иван";
```

5. **Классы ES6**:

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Привет, ${this.name}!`;
  }
}

const person = new Person("Иван");
```

6. **Фабричная функция**:

```javascript
function createPerson(name) {
  return {
    name,
    greet() {
      return `Привет, ${name}!`;
    },
  };
}

const person = createPerson("Иван");
```

</details>

<details>
<summary>22. Как работает прототипное наследование?</summary>

Прототипное наследование - это механизм, который позволяет объектам наследовать свойства и методы от других объектов.

Основные принципы:

1. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом
2. Когда мы пытаемся получить доступ к свойству объекта, которое не существует в самом объекте, JavaScript автоматически ищет это свойство в прототипе
3. Если свойство не найдено и в прототипе, поиск продолжается в прототипе прототипа и так далее, образуя цепочку прототипов
4. Поиск продолжается, пока не будет найдено свойство или не будет достигнут конец цепочки (null)

Пример прототипного наследования:

```javascript
// Родительский объект
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function () {
  return `${this.name} ест`;
};

// Дочерний объект
function Dog(name, breed) {
  Animal.call(this, name); // Вызываем конструктор родителя с текущим this
  this.breed = breed;
}

// Устанавливаем прототипное наследование
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // Восстанавливаем конструктор

// Добавляем собственный метод
Dog.prototype.bark = function () {
  return "Гав-гав!";
};

const dog = new Dog("Рекс", "Овчарка");
console.log(dog.eat()); // "Рекс ест" - унаследованный метод
console.log(dog.bark()); // "Гав-гав!" - собственный метод
```

В ES6 и выше то же самое можно сделать с помощью классов:

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    return `${this.name} ест`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  bark() {
    return "Гав-гав!";
  }
}

const dog = new Dog("Рекс", "Овчарка");
```

</details>

<details>
<summary>23. Что такое цепочка прототипов?</summary>

Цепочка прототипов (prototype chain) - это последовательность связанных объектов, используемая JavaScript для поиска свойств и методов.

Когда мы пытаемся получить доступ к свойству объекта, JavaScript выполняет следующие шаги:

1. Ищет свойство в самом объекте
2. Если не находит, ищет в прототипе объекта (`[[Prototype]]` или `__proto__`)
3. Если не находит, ищет в прототипе прототипа и так далее
4. Процесс продолжается, пока не найдется свойство или не будет достигнут конец цепочки (null)

Пример:

```javascript
const grandParent = {
  family: "Ивановы",
  sayHello() {
    return "Привет от прародителя!";
  },
};

const parent = Object.create(grandParent);
parent.profession = "Инженер";
parent.sayBye = function () {
  return "Пока от родителя!";
};

const child = Object.create(parent);
child.hobby = "Программирование";

console.log(child.hobby); // "Программирование" - найдено в самом объекте
console.log(child.profession); // "Инженер" - найдено в родительском объекте
console.log(child.family); // "Ивановы" - найдено в прародительском объекте
console.log(child.sayHello()); // "Привет от прародителя!" - метод из прародителя
console.log(child.sayBye()); // "Пока от родителя!" - метод из родителя

// Визуализация цепочки прототипов:
// child ---> parent ---> grandParent ---> Object.prototype ---> null
```

Функция `Object.getPrototypeOf()` позволяет получить прототип объекта:

```javascript
console.log(Object.getPrototypeOf(child) === parent); // true
console.log(Object.getPrototypeOf(parent) === grandParent); // true
```

</details>

<details>
<summary>24. Как реализовать классическое наследование в JavaScript до ES6?</summary>

До появления классов ES6, классическое наследование в JavaScript реализовывалось через функции-конструкторы и прототипы. Рассмотрим пошаговый процесс:

```javascript
// Родительский конструктор
function Parent(name) {
  this.name = name;
}

// Методы родителя добавляются в прототип
Parent.prototype.sayName = function () {
  return "Меня зовут " + this.name;
};

// Дочерний конструктор
function Child(name, age) {
  // Вызываем родительский конструктор с текущим this
  Parent.call(this, name);
  this.age = age;
}

// Наследование прототипа
Child.prototype = Object.create(Parent.prototype);

// Восстановление конструктора
Child.prototype.constructor = Child;

// Добавление собственных методов дочернего объекта
Child.prototype.sayAge = function () {
  return "Мне " + this.age + " лет";
};

// Использование
var child = new Child("Иван", 5);
console.log(child.sayName()); // "Меня зовут Иван" - метод родителя
console.log(child.sayAge()); // "Мне 5 лет" - собственный метод
```

Альтернативный способ с использованием временного конструктора:

```javascript
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function () {
  return "Меня зовут " + this.name;
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

// Наследование с использованием временного конструктора
function F() {}
F.prototype = Parent.prototype;
Child.prototype = new F();
Child.prototype.constructor = Child;

Child.prototype.sayAge = function () {
  return "Мне " + this.age + " лет";
};
```

Часто для упрощения создавали вспомогательную функцию:

```javascript
function extend(Child, Parent) {
  var F = function () {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  Child.super = Parent.prototype; // Часто добавляли для доступа к методам родителя
}

// Использование
extend(Child, Parent);
```

</details>

<details>
<summary>25. Что такое Object.create() и как это работает?</summary>

`Object.create()` — это метод, позволяющий создавать новый объект с указанным прототипом и свойствами.

**Синтаксис:**

```javascript
Object.create(proto, [propertiesObject]);
```

- `proto` — объект, который станет прототипом нового объекта
- `propertiesObject` (опционально) — объект, содержащий дескрипторы свойств для нового объекта

**Принцип работы:**

1. Создаёт новый пустой объект
2. Устанавливает переданный `proto` в качестве прототипа нового объекта
3. Если указан `propertiesObject`, добавляет свойства в новый объект

**Примеры:**

Простое создание объекта с прототипом:

```javascript
const person = {
  isHuman: true,
  printInfo() {
    return `Имя: ${this.name}, человек: ${this.isHuman}`;
  },
};

const me = Object.create(person);
me.name = "Иван"; // Свойство 'name' добавляется только в 'me'
console.log(me.printInfo()); // "Имя: Иван, человек: true"
console.log(me.isHuman); // true (унаследовано)
```

Создание объекта с определением свойств:

```javascript
const person = {
  greeting() {
    return `Привет, я ${this.name}!`;
  },
};

const john = Object.create(person, {
  name: {
    value: "Иван",
    writable: true,
    enumerable: true,
    configurable: true,
  },
  age: {
    value: 30,
    writable: true,
    enumerable: true,
  },
});

console.log(john.greeting()); // "Привет, я Иван!"
console.log(john.name); // "Иван"
console.log(john.age); // 30
```

Создание объекта без прототипа:

```javascript
const noProto = Object.create(null);
console.log(noProto.__proto__); // undefined
console.log(noProto.toString); // undefined - нет доступа к методам Object.prototype
```

`Object.create()` часто используется для реализации наследования:

```javascript
function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
};

function Rectangle() {
  Shape.call(this); // Вызов конструктора родителя
}

// Наследование прототипа через Object.create()
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;
```

</details>

<details>
<summary>26. Каковы различия между классами ES6 и функциями-конструкторами?</summary>

Различия между классами ES6 и функциями-конструкторами:

**Синтаксис и читаемость:**

- **Классы ES6** имеют более чистый и понятный синтаксис, ближе к ООП в других языках
- **Функции-конструкторы** требуют больше кода для определения методов с использованием прототипов

```javascript
// Функция-конструктор
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function () {
  return `Привет, я ${this.name}`;
};

// Класс ES6
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    return `Привет, я ${this.name}`;
  }
}
```

**Наследование:**

- **Классы ES6** используют простое ключевое слово `extends` и метод `super()`
- **Функции-конструкторы** требуют ручной настройки прототипного наследования

```javascript
// Наследование с функциями-конструкторами
function Person(name) {
  this.name = name;
}
Person.prototype.introduce = function () {
  return `Меня зовут ${this.name}`;
};

function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.getJob = function () {
  return `Я работаю как ${this.position}`;
};

// Наследование с классами ES6
class Person {
  constructor(name) {
    this.name = name;
  }

  introduce() {
    return `Меня зовут ${this.name}`;
  }
}

class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }

  getJob() {
    return `Я работаю как ${this.position}`;
  }
}
```

**Поднятие (hoisting):**

- **Классы ES6** не поднимаются (нельзя использовать до объявления)
- **Функции-конструкторы** поднимаются как обычные функции

```javascript
// Работает
const person = new Person("Иван");
function Person(name) {
  this.name = name;
}

// Ошибка: Cannot access 'Person' before initialization
const person = new Person("Иван");
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

**Вызов без new:**

- **Классы ES6** выбрасывают ошибку при вызове без `new`
- **Функции-конструкторы** могут быть вызваны без `new` (что может привести к ошибкам)

**Статические методы:**

- **Классы ES6** имеют встроенный синтаксис для статических методов (`static`)
- **Функции-конструкторы** требуют прямого присваивания методов конструктору

**Приватные поля и методы:**

- **Классы ES6** (с недавними обновлениями) поддерживают приватные поля и методы (`#fieldName`)
- **Функции-конструкторы** не имеют встроенной поддержки приватности

**Геттеры и сеттеры:**

- **Классы ES6** имеют встроенную и чистую поддержку геттеров и сеттеров
- **Функции-конструкторы** могут использовать `Object.defineProperty()` для определения геттеров и сеттеров

Несмотря на различия, важно понимать, что классы ES6 - это "синтаксический сахар" над прототипным наследованием JavaScript, а не совершенно новая модель. Под капотом они используют те же механизмы прототипов.

</details>

<details>
<summary>27. Что такое статические методы в классах?</summary>

Статические методы в классах - это методы, которые принадлежат самому классу, а не его экземплярам. Они вызываются непосредственно на классе и не могут быть вызваны на экземплярах.

**Характеристики статических методов:**

1. Определяются с ключевым словом `static`
2. Вызываются на самом классе, а не на экземплярах
3. Не имеют доступа к `this` экземпляра класса
4. Могут получить доступ к статическим свойствам и методам того же класса
5. Наследуются при использовании `extends`

**Пример статических методов:**

```javascript
class MathUtils {
  // Статический метод
  static sum(a, b) {
    return a + b;
  }

  // Статическое свойство (современный JavaScript)
  static PI = 3.14159;

  // Статический метод, использующий другой статический метод
  static calculateCircleArea(radius) {
    return MathUtils.PI * MathUtils.square(radius);
  }

  // Еще один статический метод
  static square(x) {
    return x * x;
  }

  // Обычный метод экземпляра
  multiply(x, y) {
    return x * y;
  }
}

// Вызов статических методов
console.log(MathUtils.sum(5, 10)); // 15
console.log(MathUtils.calculateCircleArea(5)); // 78.53975

// Ошибка - статический метод не доступен на экземпляре
const utils = new MathUtils();
// console.log(utils.sum(5, 10)); // TypeError: utils.sum is not a function

// Но обычные методы доступны только экземплярам
console.log(utils.multiply(5, 10)); // 50
// console.log(MathUtils.multiply(5, 10)); // TypeError: MathUtils.multiply is not a function
```

**Наследование статических методов:**

```javascript
class Animal {
  static isAnimal(obj) {
    return obj instanceof Animal;
  }
}

class Dog extends Animal {
  static isDog(obj) {
    return obj instanceof Dog;
  }

  bark() {
    return "Гав-гав!";
  }
}

const dog = new Dog();

console.log(Dog.isAnimal(dog)); // true - наследованный статический метод
console.log(Dog.isDog(dog)); // true - собственный статический метод
```

**Применение статических методов:**

1. **Служебные функции** - методы, которые связаны с классом, но не требуют создания экземпляра
2. **Фабричные методы** - методы для создания экземпляров класса особым образом
3. **Кэширование или синглтоны** - хранение данных, общих для всех экземпляров
4. **Константы и конфигурация** - хранение значений, общих для всего класса

```javascript
class User {
  constructor(name, role) {
    this.name = name;
    this.role = role;
  }

  // Фабричный метод
  static createAdmin(name) {
    return new User(name, "admin");
  }

  // Фабричный метод
  static createGuest() {
    return new User("Гость", "guest");
  }

  // Статический метод для проверки прав
  static hasAccess(user, requiredRole) {
    const roles = {
      guest: 0,
      user: 1,
      moderator: 2,
      admin: 3,
    };

    return roles[user.role] >= roles[requiredRole];
  }
}

const admin = User.createAdmin("Иван");
const guest = User.createGuest();

console.log(User.hasAccess(admin, "moderator")); // true
console.log(User.hasAccess(guest, "user")); // false
```

</details>

<details>
<summary>28. Как работают свойства-аксессоры (геттеры и сеттеры)?</summary>

Свойства-аксессоры (геттеры и сеттеры) позволяют определить методы, которые будут вызываться при чтении или записи значения свойства. Они дают возможность контролировать доступ к свойствам объекта.

**Геттер (getter)**: метод, который вызывается при чтении свойства
**Сеттер (setter)**: метод, который вызывается при записи значения в свойство

**Определение в литералах объектов:**

```javascript
const person = {
  firstName: "Иван",
  lastName: "Петров",

  // Геттер
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  // Сеттер
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  },
};

// Использование геттера
console.log(person.fullName); // "Иван Петров"

// Использование сеттера
person.fullName = "Алексей Сидоров";
console.log(person.firstName); // "Алексей"
console.log(person.lastName); // "Сидоров"
```

**Определение в классах ES6:**

```javascript
class Temperature {
  constructor(celsius) {
    this._celsius = celsius;
  }

  // Геттер для Цельсия
  get celsius() {
    return this._celsius;
  }

  // Сеттер для Цельсия
  set celsius(value) {
    if (value < -273.15) {
      throw new Error("Температура ниже абсолютного нуля");
    }
    this._celsius = value;
  }

  // Геттер для Фаренгейта
  get fahrenheit() {
    return (this._celsius * 9) / 5 + 32;
  }

  // Сеттер для Фаренгейта
  set fahrenheit(value) {
    this.celsius = ((value - 32) * 5) / 9;
  }
}

const temp = new Temperature(25);
console.log(temp.celsius); // 25
console.log(temp.fahrenheit); // 77

temp.celsius = 30;
console.log(temp.fahrenheit); // 86

temp.fahrenheit = 68;
console.log(temp.celsius); // 20

// temp.celsius = -300; // Error: Температура ниже абсолютного нуля
```

**Определение через Object.defineProperty:**

```javascript
function Person(firstName, lastName) {
  this._firstName = firstName;
  this._lastName = lastName;
}

Object.defineProperty(Person.prototype, "fullName", {
  get: function () {
    return `${this._firstName} ${this._lastName}`;
  },
  set: function (value) {
    const parts = value.split(" ");
    this._firstName = parts[0];
    this._lastName = parts[1];
  },
});

const person = new Person("Иван", "Петров");
console.log(person.fullName); // "Иван Петров"
person.fullName = "Алексей Сидоров";
console.log(person._firstName); // "Алексей"
```

**Преимущества использования геттеров и сеттеров:**

1. **Контроль доступа к данным** - валидация, форматирование при записи/чтении
2. **Вычисляемые свойства** - свойства, которые вычисляются на основе других свойств
3. **Инкапсуляция** - защита внутренних деталей реализации
4. **Отложенные вычисления** - вычисление значения только когда оно требуется
5. **Обратная совместимость** - возможность изменить внутреннюю реализацию без изменения публичного API

**Ограничения:**

1. Геттер не может принимать параметры
2. Нельзя одновременно иметь свойство и геттер/сеттер с одинаковым именем
3. Геттеры и сеттеры не работают с деструктуризацией
</details>

<details>
<summary>29. Что такое приватные поля и методы в классах?</summary>

Приватные поля и методы в классах JavaScript - это члены класса, которые доступны только внутри самого класса и недоступны снаружи, даже для наследующих классов. Они были введены в спецификации ECMAScript как часть предложения Class Fields.

**Синтаксис и особенности:**

Приватные поля и методы обозначаются префиксом `#`. Это не просто соглашение об именовании, а синтаксическая особенность языка, которая обеспечивает настоящую приватность:

```javascript
class Person {
  // Приватное поле
  #name;

  // Публичное поле
  age;

  constructor(name, age) {
    this.#name = name;
    this.age = age;
  }

  // Публичный метод
  introduce() {
    return `Меня зовут ${this.#name}, мне ${this.age} лет`;
  }

  // Приватный метод
  #formatName() {
    return this.#name.toUpperCase();
  }

  // Публичный метод, использующий приватный метод
  shout() {
    return `Я ${this.#formatName()}!`;
  }

  // Геттер для приватного поля
  get name() {
    return this.#name;
  }

  // Сеттер для приватного поля
  set name(newName) {
    if (newName.length > 0) {
      this.#name = newName;
    }
  }
}

const person = new Person("Иван", 30);
console.log(person.introduce()); // "Меня зовут Иван, мне 30 лет"
console.log(person.age); // 30 - публичное поле
console.log(person.name); // "Иван" - через геттер

person.name = "Алексей"; // Использование сеттера
console.log(person.introduce()); // "Меня зовут Алексей, мне 30 лет"

// Ошибки доступа:
// console.log(person.#name); // SyntaxError: Private field '#name' must be declared in an enclosing class
// console.log(person.#formatName()); // SyntaxError: Private field '#formatName' must be declared in an enclosing class
```

**Правила использования приватных полей и методов:**

1. Приватные поля должны быть объявлены в теле класса
2. Могут быть объявлены перед конструктором или внутри класса, но не внутри методов
3. Доступны только внутри методов класса, включая конструктор
4. Не могут быть добавлены или удалены динамически после создания экземпляра
5. Нельзя получить доступ к приватным полям другого экземпляра того же класса без специальных методов

**Наследование и приватные поля:**

Приватные поля и методы не наследуются подклассами:

```javascript
class Person {
  #privateField = "приватное поле";

  getPrivate() {
    return this.#privateField;
  }
}

class Employee extends Person {
  testAccess() {
    // Ошибка - #privateField не доступно в подклассе
    // return this.#privateField;

    // Но можно получить через унаследованный метод
    return this.getPrivate();
  }
}

const employee = new Employee();
console.log(employee.testAccess()); // "приватное поле"
```

**Статические приватные поля и методы:**

```javascript
class Counter {
  // Статическое приватное поле
  static #count = 0;

  // Статический приватный метод
  static #increment() {
    this.#count++;
  }

  // Публичный статический метод
  static incrementAndGet() {
    this.#increment();
    return this.#count;
  }

  static get count() {
    return this.#count;
  }
}

console.log(Counter.incrementAndGet()); // 1
console.log(Counter.incrementAndGet()); // 2
console.log(Counter.count); // 2
// console.log(Counter.#count); // Ошибка - приватное поле
```

**Сравнение с другими подходами к приватности:**

До появления приватных полей использовались другие техники:

1. **Соглашение об именовании** (префикс `_`): не обеспечивает настоящую приватность
2. **Замыкания**: защищают данные, но не связывают их с прототипом
3. **WeakMap**: обеспечивает приватность, но требует более сложного кода
4. **Symbol**: обеспечивает некоторую степень скрытности, но не приватности

Приватные поля и методы обеспечивают настоящую приватность и являются стандартным способом для современного JavaScript.

</details>

<details>
<summary>30. Как работает оператор instanceof?</summary>

Оператор `instanceof` проверяет, принадлежит ли объект к определенному классу или цепочке прототипов, и возвращает логическое значение (`true`/`false`).

**Синтаксис:**

```javascript
object instanceof constructor;
```

**Принцип работы:**

1. Оператор проверяет, присутствует ли `constructor.prototype` в цепочке прототипов объекта `object`
2. Проверка идет по всей цепочке прототипов (включая унаследованные)
3. Возвращает `true`, если найдено совпадение, иначе `false`

**Примеры использования:**

Базовая проверка типа:

```javascript
// Встроенные типы
const arr = [];
const date = new Date();
const regex = /abc/;

console.log(arr instanceof Array); // true
console.log(date instanceof Date); // true
console.log(regex instanceof RegExp); // true
console.log(arr instanceof Object); // true - Array наследуется от Object
console.log({} instanceof Array); // false
```

Проверка с пользовательскими классами:

```javascript
class Animal {}
class Dog extends Animal {}

const dog = new Dog();

console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true - наследование
console.log(dog instanceof Object); // true - все объекты наследуются от Object
console.log(new Animal() instanceof Dog); // false - родитель не является экземпляром потомка
```

С функциями-конструкторами:

```javascript
function Person(name) {
  this.name = name;
}

function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}

// Установка прототипного наследования
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

const employee = new Employee("Иван", "Разработчик");

console.log(employee instanceof Employee); // true
console.log(employee instanceof Person); // true
console.log(employee instanceof Object); // true
```

**Особенности и ограничения:**

1. **Примитивные типы** не работают с `instanceof`:

```javascript
console.log(5 instanceof Number); // false - примитив не является объектом
console.log(new Number(5) instanceof Number); // true - обертка является объектом
```

2. **Разные контексты выполнения** (например, разные фреймы в браузере) могут давать неожиданные результаты:

```javascript
// Если объект создан в одном фрейме, а конструктор из другого фрейма
const iframe = document.createElement("iframe");
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
const arr = new iframeArray();

console.log(arr instanceof Array); // false - разные конструкторы Array
console.log(arr instanceof iframeArray); // true
console.log(arr.constructor === Array); // false
```

3. **Ручная настройка прототипов** может повлиять на результат:

```javascript
function A() {}
function B() {}

const a = new A();
console.log(a instanceof A); // true
console.log(a instanceof B); // false

// Изменение прототипа
Object.setPrototypeOf(a, B.prototype);
console.log(a instanceof A); // false - прототип изменен
console.log(a instanceof B); // true
```

4. **Настройка Symbol.hasInstance** (ES6+) позволяет настроить поведение `instanceof`:

```javascript
class CustomArray {
  static [Symbol.hasInstance](instance) {
    return Array.isArray(instance);
  }
}

console.log([] instanceof CustomArray); // true - благодаря Symbol.hasInstance
console.log({} instanceof CustomArray); // false
```

**Альтернативы:**

1. **Object.prototype.isPrototypeOf()** - проверяет, находится ли объект в цепочке прототипов другого объекта:

```javascript
console.log(Array.prototype.isPrototypeOf([])); // true
```

2. **constructor свойство** - проверяет конструктор напрямую:

```javascript
console.log([].constructor === Array); // true
```

3. **Array.isArray()**, **typeof** и другие специализированные проверки для конкретных типов:

```javascript
console.log(Array.isArray([])); // true
console.log(typeof 5 === "number"); // true
```

</details>

<details>
<summary>109. Как глубоко клонировать объект в JavaScript?</summary>

Глубокое клонирование объекта означает создание полной копии объекта со всеми вложенными объектами и массивами. Существует несколько способов глубокого клонирования:

**1. JSON.parse() + JSON.stringify():**

Самый простой способ, но с ограничениями:

```javascript
const original = {
  name: "Иван",
  age: 30,
  address: {
    city: "Москва",
    street: "Ленина",
  },
  hobbies: ["чтение", "программирование"],
};

const clone = JSON.parse(JSON.stringify(original));
clone.address.city = "Санкт-Петербург";
clone.hobbies.push("путешествия");

console.log(original.address.city); // 'Москва' - не изменилось
console.log(original.hobbies); // ['чтение', 'программирование'] - не изменилось
```

**Ограничения метода JSON:**

- Не клонирует функции
- Не клонирует undefined значения
- Не клонирует символы (Symbol)
- Не работает с циклическими ссылками
- Теряет прототипы объектов
- Проблемы с Date (преобразует в строки)
- Проблемы с Map, Set, RegExp и другими специальными объектами

**2. Структурное клонирование через structuredClone() (современные браузеры):**

```javascript
const original = {
  name: "Иван",
  date: new Date(),
  address: { city: "Москва" },
  hobbies: ["чтение", "программирование"],
  regex: /test/,
};

const clone = structuredClone(original);
```

**Преимущества structuredClone():**

- Корректно клонирует Date, RegExp, Map, Set и другие встроенные типы
- Обрабатывает циклические ссылки
- Отличная производительность

**Ограничения structuredClone():**

- Не клонирует функции
- Не клонирует DOM-узлы
- Не сохраняет прототипы
- Не поддерживает символы (Symbol) как ключи

**3. Рекурсивная реализация глубокого клонирования:**

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // Проверка на null/undefined и примитивы
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  // Обработка Date
  if (obj instanceof Date) {
    return new Date(obj);
  }

  // Обработка RegExp
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }

  // Обработка циклических ссылок
  if (hash.has(obj)) {
    return hash.get(obj);
  }

  // Обработка Map
  if (obj instanceof Map) {
    const mapClone = new Map();
    hash.set(obj, mapClone);

    obj.forEach((value, key) => {
      mapClone.set(deepClone(key, hash), deepClone(value, hash));
    });

    return mapClone;
  }

  // Обработка Set
  if (obj instanceof Set) {
    const setClone = new Set();
    hash.set(obj, setClone);

    obj.forEach((value) => {
      setClone.add(deepClone(value, hash));
    });

    return setClone;
  }

  // Создание нового объекта/массива
  const clone = Array.isArray(obj) ? [] : {};

  // Сохранение ссылки для обработки циклических ссылок
  hash.set(obj, clone);

  // Рекурсивное копирование всех свойств
  Object.keys(obj).forEach((key) => {
    clone[key] = deepClone(obj[key], hash);
  });

  return clone;
}

// Пример использования
const original = {
  name: "Иван",
  address: { city: "Москва" },
  dates: [new Date()],
  reg: /test/,
  sayHi() {
    return "Привет";
  },
  map: new Map([["key", "value"]]),
};

// Создание циклической ссылки
original.self = original;

const clone = deepClone(original);
console.log(clone.address === original.address); // false
console.log(clone.self === clone); // true - циклическая ссылка сохранена
```

**4. Использование библиотек:**

Для сложных случаев лучше использовать проверенные библиотеки:

- lodash: `_.cloneDeep(obj)`
- ramda: `R.clone(obj)`

```javascript
// С использованием lodash
const clone = _.cloneDeep(original);
```

**Выбор метода клонирования:**

1. Для простых объектов без функций и специальных типов: `JSON.parse(JSON.stringify(obj))`
2. Для современных браузеров с поддержкой: `structuredClone(obj)`
3. Для наибольшей гибкости: собственная рекурсивная функция или библиотека
</details>

<details>
<summary>110. Как работает сравнение объектов в JavaScript?</summary>

В JavaScript сравнение объектов основано на сравнении ссылок, а не на сравнении содержимого или структуры объектов. Понимание этой особенности критически важно для правильной работы с объектами.

**Сравнение по ссылке:**

```javascript
const obj1 = { name: "Иван" };
const obj2 = { name: "Иван" };
const obj3 = obj1;

console.log(obj1 === obj2); // false - разные объекты, разные ссылки
console.log(obj1 === obj3); // true - один и тот же объект, одинаковые ссылки

// То же самое с оператором ==
console.log(obj1 == obj2); // false
console.log(obj1 == obj3); // true
```

Это справедливо для всех составных типов данных - объектов, массивов, функций:

```javascript
console.log([1, 2, 3] === [1, 2, 3]); // false
console.log([] === []); // false
console.log(() => {} === () => {}); // false
```

**Методы сравнения содержимого объектов:**

1. **Ручное сравнение свойств:**

```javascript
function shallowEqual(obj1, obj2) {
  // Проверка идентичности
  if (obj1 === obj2) return true;

  // Проверка, что оба объекта существуют
  if (!obj1 || !obj2) return false;

  // Проверка количества ключей
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) return false;

  // Сравнение всех свойств
  for (const key of keys1) {
    if (obj1[key] !== obj2[key]) return false;
  }

  return true;
}

const a = { name: "Иван", age: 30 };
const b = { name: "Иван", age: 30 };
const c = { name: "Иван", age: 25 };

console.log(shallowEqual(a, b)); // true
console.log(shallowEqual(a, c)); // false
```

2. **Глубокое сравнение:**

```javascript
function deepEqual(obj1, obj2) {
  // Проверка идентичности
  if (obj1 === obj2) return true;

  // Проверка типов
  if (
    typeof obj1 !== "object" ||
    obj1 === null ||
    typeof obj2 !== "object" ||
    obj2 === null
  ) {
    return false;
  }

  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) return false;

  // Рекурсивное сравнение вложенных объектов
  for (const key of keys1) {
    if (!keys2.includes(key)) return false;

    if (typeof obj1[key] === "object" && obj1[key] !== null) {
      if (!deepEqual(obj1[key], obj2[key])) return false;
    } else if (obj1[key] !== obj2[key]) {
      return false;
    }
  }

  return true;
}

const a = {
  name: "Иван",
  address: { city: "Москва", street: "Ленина" },
  hobbies: ["чтение", "спорт"],
};

const b = {
  name: "Иван",
  address: { city: "Москва", street: "Ленина" },
  hobbies: ["чтение", "спорт"],
};

const c = {
  name: "Иван",
  address: { city: "Москва", street: "Пушкина" },
  hobbies: ["чтение", "спорт"],
};

console.log(deepEqual(a, b)); // true
console.log(deepEqual(a, c)); // false
```

3. **Сравнение с помощью JSON:**

```javascript
function jsonEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

const a = { name: "Иван", items: [1, 2, 3] };
const b = { name: "Иван", items: [1, 2, 3] };
const c = { items: [1, 2, 3], name: "Иван" }; // Порядок свойств отличается

console.log(jsonEqual(a, b)); // true
console.log(jsonEqual(a, c)); // false - порядок свойств важен для JSON.stringify
```

**Ограничения JSON-сравнения:**

- Порядок свойств влияет на результат
- Не работает с функциями, undefined, Symbol
- Проблемы с циклическими ссылками

4. **Библиотеки для сравнения:**

```javascript
// Lodash
const isEqual = _.isEqual(obj1, obj2);

// Underscore
const isEqual = _.isEqual(obj1, obj2);

// fast-deep-equal
const isEqual = require("fast-deep-equal")(obj1, obj2);
```

**Практические рекомендации:**

1. Для примитивного сравнения простых объектов: `JSON.stringify(obj1) === JSON.stringify(obj2)`
2. Для объектов с вложенной структурой: глубокое рекурсивное сравнение
3. Для сложных объектов с функциями, циклическими ссылками: библиотеки
4. Рассмотрите возможность использования иммутабельных структур данных и библиотек (Immutable.js, Immer), которые предоставляют эффективные методы сравнения

Понимание того, что объекты сравниваются по ссылке, помогает избежать многих распространенных ошибок в JavaScript-коде.

</details>

<details>
<summary>111. Что такое Object.freeze(), Object.seal() и Object.preventExtensions()?</summary>

JavaScript предоставляет три метода для ограничения модификации объектов: `Object.freeze()`, `Object.seal()` и `Object.preventExtensions()`. Они позволяют контролировать степень изменяемости объектов.

### 1. Object.preventExtensions()

Предотвращает добавление новых свойств в объект, но позволяет изменять и удалять существующие свойства.

```javascript
const user = {
  name: "Иван",
  age: 30,
};

Object.preventExtensions(user);

// Изменение существующих свойств - работает
user.name = "Алексей";
console.log(user.name); // "Алексей"

// Удаление существующих свойств - работает
delete user.age;
console.log(user.age); // undefined

// Добавление новых свойств - не работает
user.email = "ivan@example.com";
console.log(user.email); // undefined

// Проверка
console.log(Object.isExtensible(user)); // false
```

### 2. Object.seal()

Предотвращает добавление новых свойств и удаление существующих, но позволяет изменять существующие свойства.

```javascript
const user = {
  name: "Иван",
  age: 30,
};

Object.seal(user);

// Изменение существующих свойств - работает
user.name = "Алексей";
console.log(user.name); // "Алексей"

// Удаление существующих свойств - не работает
delete user.age;
console.log(user.age); // 30 (не удалено)

// Добавление новых свойств - не работает
user.email = "ivan@example.com";
console.log(user.email); // undefined

// Проверка
console.log(Object.isSealed(user)); // true
console.log(Object.isExtensible(user)); // false
```

### 3. Object.freeze()

Наиболее строгий метод. Предотвращает добавление новых свойств, удаление и изменение существующих свойств - объект становится полностью неизменяемым (только на верхнем уровне).

```javascript
const user = {
  name: "Иван",
  age: 30,
  address: {
    city: "Москва",
    street: "Ленина",
  },
};

Object.freeze(user);

// Изменение существующих свойств - не работает
user.name = "Алексей";
console.log(user.name); // "Иван" (не изменено)

// Удаление существующих свойств - не работает
delete user.age;
console.log(user.age); // 30 (не удалено)

// Добавление новых свойств - не работает
user.email = "ivan@example.com";
console.log(user.email); // undefined

// Проверка
console.log(Object.isFrozen(user)); // true
console.log(Object.isSealed(user)); // true (замороженный объект также запечатан)
console.log(Object.isExtensible(user)); // false

// НО! Вложенные объекты не замораживаются автоматически
user.address.city = "Санкт-Петербург";
console.log(user.address.city); // "Санкт-Петербург" (изменено!)
```

### Сравнение методов

| Метод                        | Добавление свойств | Удаление свойств | Изменение свойств |
| ---------------------------- | ------------------ | ---------------- | ----------------- |
| `Object.preventExtensions()` | ❌                 | ✅               | ✅                |
| `Object.seal()`              | ❌                 | ❌               | ✅                |
| `Object.freeze()`            | ❌                 | ❌               | ❌                |

### Глубокая заморозка

Для рекурсивной заморозки вложенных объектов можно использовать:

```javascript
function deepFreeze(obj) {
  // Получаем все собственные свойства объекта
  const propNames = Object.getOwnPropertyNames(obj);

  // Замораживаем все вложенные объекты, прежде чем заморозить родительский
  for (const name of propNames) {
    const value = obj[name];

    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  }

  return Object.freeze(obj);
}

const user = {
  name: "Иван",
  address: {
    city: "Москва",
    coords: {
      lat: 55.7558,
      lng: 37.6173,
    },
  },
};

deepFreeze(user);

// Теперь изменения невозможны даже во вложенных объектах
user.address.city = "Санкт-Петербург";
console.log(user.address.city); // "Москва" (не изменено)
```

### Ограничения

1. В strict mode попытки изменить замороженные или запечатанные объекты вызывают TypeError
2. В нестрогом режиме такие попытки молча игнорируются
3. Эти методы неглубокие - они действуют только на верхний уровень объекта
4. Нельзя "разморозить" или "распечатать" объект после применения этих методов

### Применение

1. **Константы и конфигурационные объекты**

   ```javascript
   const CONFIG = Object.freeze({
     API_URL: "https://api.example.com",
     MAX_RETRIES: 3,
     TIMEOUT: 5000,
   });
   ```

2. **Предотвращение случайного изменения объектов**

   ```javascript
   function processOrder(order) {
     // Замораживаем объект заказа, чтобы предотвратить его изменение
     Object.freeze(order);
     // ... обработка заказа
   }
   ```

3. **Иммутабельные структуры данных**
   ```javascript
   function addItem(collection, item) {
     // Создаем новую копию, а не изменяем оригинал
     return Object.freeze([...collection, item]);
   }
   ```
   </details>

<details>
<summary>112. Как работают дескрипторы свойств (writable, enumerable, configurable)?</summary>

Дескрипторы свойств в JavaScript позволяют более точно контролировать поведение свойств объектов. Они определяют, как свойство может быть использовано и изменено.

### Основные дескрипторы свойств:

1. **writable** - можно ли изменять значение свойства
2. **enumerable** - будет ли свойство перечисляться в циклах
3. **configurable** - можно ли удалять свойство и изменять его дескрипторы
4. **value** - значение свойства
5. **get** - функция-геттер для свойства
6. **set** - функция-сеттер для свойства

### Работа с дескрипторами:

**Object.defineProperty()** - определяет новое свойство или изменяет существующее с заданными дескрипторами:

```javascript
const person = {};

Object.defineProperty(person, "name", {
  value: "Иван",
  writable: true, // можно изменять
  enumerable: true, // видно в циклах
  configurable: true, // можно удалять и переопределять
});

// Эквивалентно
// person.name = 'Иван';

Object.defineProperty(person, "age", {
  value: 30,
  writable: false, // нельзя изменять
  enumerable: true, // видно в циклах
  configurable: true, // можно удалять и переопределять
});

person.name = "Алексей"; // Работает, т.к. writable: true
console.log(person.name); // "Алексей"

person.age = 40; // Не сработает, т.к. writable: false
console.log(person.age); // 30

// В строгом режиме попытка изменить неизменяемое свойство вызывает ошибку
// 'use strict';
// person.age = 40; // TypeError: Cannot assign to read only property 'age'
```

**Object.defineProperties()** - определяет несколько свойств одновременно:

```javascript
const product = {};

Object.defineProperties(product, {
  name: {
    value: "Телефон",
    writable: true,
    enumerable: true,
    configurable: true,
  },
  price: {
    value: 1000,
    writable: true,
    enumerable: true,
    configurable: false, // нельзя удалять и изменять дескрипторы
  },
  _discount: {
    value: 0,
    writable: true,
    enumerable: false, // не будет видно в циклах
    configurable: true,
  },
});
```

**Object.getOwnPropertyDescriptor()** - получает дескриптор свойства:

```javascript
const descriptor = Object.getOwnPropertyDescriptor(person, "age");
console.log(descriptor);
// {
//   value: 30,
//   writable: false,
//   enumerable: true,
//   configurable: true
// }
```

### Как работает каждый дескриптор:

#### 1. writable

Определяет, можно ли изменять значение свойства:

```javascript
const user = {};

Object.defineProperty(user, "role", {
  value: "user",
  writable: false,
  enumerable: true,
  configurable: true,
});

user.role = "admin"; // В нестрогом режиме изменение игнорируется
console.log(user.role); // "user"
```

#### 2. enumerable

Определяет, будет ли свойство перечисляться в циклах и появляться в результатах некоторых методов:

```javascript
const user = {};

Object.defineProperty(user, "name", {
  value: "Иван",
  writable: true,
  enumerable: true,
  configurable: true,
});

Object.defineProperty(user, "password", {
  value: "12345",
  writable: true,
  enumerable: false, // Скрытое свойство
  configurable: true,
});

console.log(Object.keys(user)); // ["name"] - password не перечисляется
console.log(user.password); // "12345" - но доступно напрямую

for (const key in user) {
  console.log(key); // Только "name"
}

console.log(JSON.stringify(user)); // {"name":"Иван"} - password исключен
```

#### 3. configurable

Определяет, можно ли удалять свойство и изменять его дескрипторы (кроме превращения writable из true в false):

```javascript
const settings = {};

Object.defineProperty(settings, "theme", {
  value: "light",
  writable: true,
  enumerable: true,
  configurable: false, // Нельзя удалять и переопределять дескрипторы
});

// Нельзя удалить
delete settings.theme;
console.log(settings.theme); // "light"

// Нельзя изменить enumerable или configurable
Object.defineProperty(settings, "theme", {
  enumerable: false,
}); // TypeError: Cannot redefine property: theme

// Но можно изменить значение (т.к. writable: true)
settings.theme = "dark";
console.log(settings.theme); // "dark"

// И можно изменить writable с true на false
Object.defineProperty(settings, "theme", {
  writable: false,
}); // Это работает

// Но нельзя изменить writable обратно с false на true
settings.theme = "light"; // Не изменится
console.log(settings.theme); // "dark"
```

### Геттеры и сеттеры

Вместо прямого значения (value) можно определить геттер и сеттер:

```javascript
const person = {
  firstName: "Иван",
  lastName: "Петров",
};

Object.defineProperty(person, "fullName", {
  get() {
    return `${this.firstName} ${this.lastName}`;
  },
  set(value) {
    [this.firstName, this.lastName] = value.split(" ");
  },
  enumerable: true,
  configurable: true,
});

console.log(person.fullName); // "Иван Петров"
person.fullName = "Алексей Сидоров";
console.log(person.firstName); // "Алексей"
console.log(person.lastName); // "Сидоров"
```

Важно: нельзя одновременно использовать `value`/`writable` и `get`/`set`.

### Значения по умолчанию

Если не указать дескрипторы при создании свойства через `Object.defineProperty()`, они принимают следующие значения по умолчанию:

```javascript
{
  value: undefined,
  writable: false,
  enumerable: false,
  configurable: false
}
```

При обычном определении свойства все дескрипторы имеют значение `true`:

```javascript
// person.name = 'Иван' эквивалентно:
Object.defineProperty(person, "name", {
  value: "Иван",
  writable: true,
  enumerable: true,
  configurable: true,
});
```

### Практическое применение

1. **Константы:**

```javascript
Object.defineProperty(Math, "PI", {
  value: 3.141592653589793,
  writable: false,
  enumerable: false,
  configurable: false,
});
```

2. **Приватные свойства (до появления `#` в классах):**

```javascript
function User(name, password) {
  this.name = name;
  Object.defineProperty(this, "_password", {
    value: password,
    enumerable: false, // Скрыто при перечислении
  });
}
```

3. **Вычисляемые свойства:**

```javascript
Object.defineProperty(product, "finalPrice", {
  get() {
    return this.price * (1 - this.discount / 100);
  },
  enumerable: true,
  configurable: true,
});
```

4. **Валидация:**

```javascript
Object.defineProperty(user, "email", {
  get() {
    return this._email;
  },
  set(value) {
    if (!value.includes("@")) {
      throw new Error("Invalid email format");
    }
    this._email = value;
  },
  enumerable: true,
  configurable: true,
});
```

</details>

## Promise и асинхронная работа

<details>
<summary>
### 31. Что такое Promise и как с ними работать?
</summary>

Promise — объект, представляющий результат асинхронной операции. Имеет три состояния:

- **pending** — начальное состояние
- **fulfilled** — операция завершена успешно
- **rejected** — операция завершена с ошибкой

Основные методы:

```typescript
// Создание Promise
const promise = new Promise((resolve, reject) => {
  // Асинхронный код
  if (успех) {
    resolve(результат);
  } else {
    reject(ошибка);
  }
});

// Использование Promise
promise
  .then((результат) => {
    /* обработка результата */
  })
  .catch((ошибка) => {
    /* обработка ошибки */
  })
  .finally(() => {
    /* выполняется всегда */
  });
```

</details>

<details>
<summary>
### 32. Как работает async/await?
</summary>

`async/await` — синтаксический сахар над Promise, делающий асинхронный код похожим на синхронный.

- **async** — функция всегда возвращает Promise
- **await** — приостанавливает выполнение функции до разрешения Promise

```typescript
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Ошибка:", error);
  }
}
```

</details>

<details>
<summary>
### 33. Что такое callback-функции и проблемы, связанные с ними?
</summary>

Callback-функция — функция, переданная в другую функцию в качестве аргумента для выполнения после завершения операции.

Проблемы:

- **Callback hell** (пирамида вложенности) — ухудшение читаемости кода при множественных вложенных callback-функциях
- **Инверсия контроля** — передача контроля выполнения внешнему коду
- **Сложность обработки ошибок** — требуется обрабатывать ошибки на каждом уровне
- **Сложность параллельного выполнения** — трудно организовать параллельное выполнение нескольких асинхронных операций

</details>

<details>
<summary>
### 34. В чем разница между Promise.all(), Promise.race(), Promise.allSettled() и Promise.any()?
</summary>

- **Promise.all(iterable)** — возвращает Promise, который выполняется, когда все Promise из iterable выполнены, или отклоняется, если хотя бы один отклонен
- **Promise.race(iterable)** — возвращает Promise, который выполняется или отклоняется, как только любой из Promise из iterable выполнится или отклонится
- **Promise.allSettled(iterable)** — возвращает Promise, который выполняется, когда все Promise из iterable завершены (выполнены или отклонены)
- **Promise.any(iterable)** — возвращает Promise, который выполняется, как только любой из Promise из iterable выполнится. Отклоняется только если все Promise отклонены

</details>

<details>
<summary>
### 35. Как обрабатывать ошибки в асинхронном коде?
</summary>

1. В Promise-цепочках:

```typescript
fetchData()
  .then((data) => processData(data))
  .catch((error) => handleError(error));
```

2. В async/await:

```typescript
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Ошибка:", error);
    // Можно перебросить ошибку дальше
    throw new Error("Не удалось загрузить данные");
  }
}
```

</details>

<details>
<summary>
### 36. Что такое микрозадачи и макрозадачи в контексте event loop?
</summary>

**Event Loop** — механизм обработки асинхронных операций в JavaScript.

- **Макрозадачи (tasks)**: setTimeout, setInterval, requestAnimationFrame, I/O, UI-события
- **Микрозадачи (microtasks)**: Promise, queueMicrotask, MutationObserver

Порядок выполнения:

1. Выполнить один макротаск из очереди макрозадач
2. Выполнить все микротаски из очереди микрозадач
3. Отрисовка (если необходимо)
4. Перейти к шагу 1

Микрозадачи имеют приоритет над макрозадачами и выполняются сразу после текущей задачи.

</details>

<details>
<summary>
### 37. Как сделать отмену fetch-запроса?
</summary>

Используем AbortController:

```typescript
const controller = new AbortController();
const signal = controller.signal;

fetch("/api/data", { signal })
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("Запрос был отменен");
    } else {
      console.error("Ошибка:", error);
    }
  });

// Отмена запроса
controller.abort();
```

</details>

<details>
<summary>
### 38. Как работает WebSocket?
</summary>

WebSocket — протокол, обеспечивающий полнодуплексную связь между клиентом и сервером через TCP-соединение.

Основные особенности:

- Постоянное соединение
- Двусторонний обмен данными в реальном времени
- Низкие накладные расходы по сравнению с HTTP

```typescript
const socket = new WebSocket("ws://example.com/socket");

socket.onopen = (event) => {
  console.log("Соединение установлено");
  socket.send("Привет, сервер!");
};

socket.onmessage = (event) => {
  console.log("Получено сообщение:", event.data);
};

socket.onclose = (event) => {
  console.log("Соединение закрыто, код:", event.code);
};

socket.onerror = (error) => {
  console.error("Ошибка WebSocket:", error);
};
```

</details>

<details>
<summary>
### 39. Что такое AbortController?
</summary>

AbortController — API для отмены асинхронных операций, таких как fetch-запросы.

```typescript
const controller = new AbortController();
const signal = controller.signal;

// Использование с fetch
fetch("/api/data", { signal })
  .then((response) => response.json())
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("Запрос был отменен");
    } else {
      console.error("Ошибка:", error);
    }
  });

// Отмена операции
controller.abort();

// Проверка статуса
if (signal.aborted) {
  console.log("Операция была отменена");
}
```

Также можно использовать с EventListener и другими API, поддерживающими сигналы отмены.

</details>

<details>
<summary>
### 40. Чем отличается async/await от генераторов с co/yield?
</summary>

1. **async/await**:

   - Встроенная языковая конструкция
   - Всегда возвращает Promise
   - Более лаконичный синтаксис
   - Лучшая поддержка обработки ошибок (try/catch)

2. **генераторы с co/yield**:
   - Генераторы — более общий механизм, не предназначенный только для асинхронности
   - Требуют библиотеки-обёртки (например, co) для имитации async/await
   - Более гибкие, позволяют реализовать более сложные сценарии (ленивые вычисления, бесконечные последовательности)
   - Сложнее в использовании и понимании

</details>

<details>
<summary>
### 113. Как работают таймеры setTimeout и setInterval?
</summary>

**setTimeout(callback, delay, ...args)** — выполняет callback один раз после задержки delay (в мс).

```typescript
const timerId = setTimeout(() => {
  console.log("Выполнено через 2 секунды");
}, 2000);

// Отмена таймера
clearTimeout(timerId);
```

**setInterval(callback, interval, ...args)** — выполняет callback повторно с интервалом interval (в мс).

```typescript
const intervalId = setInterval(() => {
  console.log("Выполняется каждые 3 секунды");
}, 3000);

// Отмена интервала
clearInterval(intervalId);
```

Особенности:

- Минимальная задержка может быть больше указанной (обычно ~4мс)
- Таймеры ставятся в очередь макрозадач
- Точность зависит от загруженности главного потока и других факторов

</details>

<details>
<summary>
### 114. Как реализовать задержку (sleep) с использованием Promise?
</summary>

```typescript
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Использование
async function demo() {
  console.log("Начало");
  await sleep(2000); // Пауза на 2 секунды
  console.log("После паузы");
}
```

</details>

<details>
<summary>
### 115. Что такое callback hell и как его избежать?
</summary>

**Callback hell** (ад колбэков) — ситуация, когда код становится сложно читаемым из-за большого количества вложенных callback-функций.

Пример:

```typescript
getData(function (a) {
  getMoreData(a, function (b) {
    getMoreData(b, function (c) {
      getMoreData(c, function (d) {
        // ...и так далее
      });
    });
  });
});
```

Решения:

1. **Использование Promise:**

```typescript
getData()
  .then((a) => getMoreData(a))
  .then((b) => getMoreData(b))
  .then((c) => getMoreData(c))
  .then((d) => console.log(d))
  .catch((error) => console.error(error));
```

2. **Использование async/await:**

```typescript
async function processData() {
  try {
    const a = await getData();
    const b = await getMoreData(a);
    const c = await getMoreData(b);
    const d = await getMoreData(c);
    console.log(d);
  } catch (error) {
    console.error(error);
  }
}
```

3. **Модульность** — разбивка сложной логики на функции с понятными именами
4. **Использование функциональных инструментов** — compose, pipe и т.д.

## Обработка ошибок

</details>

<details>
<summary>
### Что такое try-catch?
</summary>

`try-catch` — конструкция для перехвата и обработки исключений (ошибок).

```typescript
try {
  // Код, который может вызвать ошибку
  const data = JSON.parse(invalidJson);
} catch (error) {
  // Обработка ошибки
  console.error("Ошибка парсинга JSON:", error.message);
} finally {
  // Выполняется всегда, независимо от наличия ошибки
  console.log("Завершение операции");
}
```

В асинхронном коде:

- В функциях с async/await: можно использовать try-catch как в синхронном коде
- С Promise: используется метод .catch()

Важно: try-catch не перехватывает ошибки в асинхронном коде, если он не обернут в async/await.

</details>

# ES6+ возможности в JavaScript:

<details>
<summary>
## 41. Что такое деструктуризация в ES6?
</summary>

Деструктуризация — это синтаксическая конструкция, которая позволяет извлекать значения из массивов или свойства из объектов в отдельные переменные.

```javascript
// Деструктуризация объекта
const user = { name: "Иван", age: 30 };
const { name, age } = user;

// Деструктуризация массива
const colors = ["красный", "зеленый", "синий"];
const [primary, secondary] = colors;

// С значениями по умолчанию
const { role = "пользователь" } = user;

// Переименование переменных
const { name: userName } = user;
```

</details>

<details>
<summary>
## 42. Как работают шаблонные строки?
</summary>

Шаблонные строки (template literals) — это строки, которые позволяют использовать многострочную запись и встраивать выражения с помощью синтаксиса `${выражение}`. Они определяются с помощью обратных кавычек (backticks).

```javascript
const name = "Анна";
const greeting = `Привет, ${name}!
Как твои дела?`; // многострочная строка с интерполяцией

// Теги шаблонов
function highlight(strings, ...values) {
  return strings.reduce(
    (result, str, i) =>
      `${result}${str}${values[i] ? `<strong>${values[i]}</strong>` : ""}`,
    ""
  );
}

const user = "Админ";
const html = highlight`Пользователь ${user} имеет доступ`;
// "Пользователь <strong>Админ</strong> имеет доступ"
```

</details>

<details>
<summary>
## 43. Что такое операторы расширения (spread) и сбора (rest)?
</summary>

**Spread-оператор (`...`)** позволяет разворачивать (распаковывать) массивы, объекты или строки в местах, где ожидается ноль или более аргументов или элементов.

**Rest-оператор (`...`)** собирает оставшиеся элементы в массив.

```javascript
// Spread для массивов
const numbers = [1, 2, 3];
const moreNumbers = [...numbers, 4, 5]; // [1, 2, 3, 4, 5]

// Spread для объектов
const person = { name: "Иван" };
const employee = { ...person, position: "разработчик" };

// Rest в функциях
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

// Rest в деструктуризации
const [first, ...rest] = [1, 2, 3, 4];
const { name, ...details } = { name: "Анна", age: 28, city: "Москва" };
```

</details>

<details>
<summary>
## 44. Как работают Map, Set, WeakMap и WeakSet?
</summary>

**Map** — коллекция пар ключ-значение, где ключи могут быть любого типа.

**Set** — коллекция уникальных значений любого типа.

**WeakMap** — версия Map, где ключи являются объектами и не препятствуют сборке мусора.

**WeakSet** — версия Set, где элементы могут быть только объектами и не препятствуют сборке мусора.

```javascript
// Map
const userRoles = new Map();
userRoles.set(user1, "admin");
userRoles.get(user1); // 'admin'

// Set
const uniqueIds = new Set([1, 2, 3, 1]); // {1, 2, 3}
uniqueIds.add(4);
uniqueIds.has(1); // true

// WeakMap
const userMetadata = new WeakMap();
userMetadata.set(user, { lastLogin: Date.now() });
// Когда user станет недоступен, запись в WeakMap будет удалена автоматически

// WeakSet
const loggedInUsers = new WeakSet();
loggedInUsers.add(user);
// Когда user станет недоступен, он будет удалён из WeakSet
```

</details>

<details>
<summary>
## 45. Что такое модули в JavaScript и как они работают?
</summary>

Модули — это механизм для разделения JavaScript-кода на независимые, повторно используемые файлы. ES6 представил стандартизированную систему модулей с ключевыми словами `import` и `export`.

```javascript
// math.js
export const PI = 3.14159;
export function sum(a, b) {
  return a + b;
}
export default class Calculator {}

// app.js
import Calculator, { PI, sum as add } from "./math.js";
import * as math from "./math.js";

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
console.log(math.sum(2, 3)); // 5
```

Модули:

- Исполняются в строгом режиме по умолчанию
- Имеют свою область видимости
- Загружаются один раз, даже если импортируются в нескольких местах
- Поддерживают статический анализ зависимостей

</details>

<details>
<summary>
## 46. Что такое символы в JavaScript?
</summary>

Символы (Symbol) — это примитивный тип данных, представляющий уникальный идентификатор. Каждый символ, созданный с помощью функции `Symbol()`, является уникальным и не равен другим символам.

```javascript
const id = Symbol("id");
const user = {
  name: "Иван",
  [id]: 12345,
};

// Символы невидимы в циклах for...in
for (let key in user) {
  console.log(key); // только 'name'
}

// Глобальный реестр символов
const globalId = Symbol.for("userId");
const sameId = Symbol.for("userId");
console.log(globalId === sameId); // true

// Встроенные символы (well-known symbols)
class Collection {
  *[Symbol.iterator]() {
    // Позволяет использовать объект в for...of
  }
}
```

</details>

<details>
<summary>
## 47. Как работают генераторы?
</summary>

Генераторы — это функции, которые могут приостанавливать своё выполнение и позже возобновлять его. Они создаются с помощью синтаксиса `function*` и используют ключевое слово `yield` для возврата значений и приостановки выполнения.

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = numberGenerator();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }

// Передача значений в генератор
function* dialogue() {
  const response = yield "Как вас зовут?";
  yield `Привет, ${response}!`;
}

const conv = dialogue();
console.log(conv.next().value); // 'Как вас зовут?'
console.log(conv.next("Иван").value); // 'Привет, Иван!'
```

</details>

<details>
<summary>
## 48. Что такое прокси-объекты?
</summary>

Proxy — это объект, который оборачивает другой объект (target) и может перехватывать основные операции с ним (получение свойств, присваивание, вызов методов и т.д.) через специальные обработчики (handlers).

```javascript
const user = { name: "Иван" };

const userProxy = new Proxy(user, {
  get(target, property) {
    console.log(`Получение свойства ${property}`);
    return property in target ? target[property] : "Н/Д";
  },
  set(target, property, value) {
    console.log(`Установка ${property} = ${value}`);
    target[property] = value;
    return true;
  },
});

console.log(userProxy.name); // "Получение свойства name", затем "Иван"
userProxy.age = 30; // "Установка age = 30"
```

Прокси используются для:

- Валидации
- Логирования
- Ленивой загрузки свойств
- Реактивности (Vue.js)
- Автоматического связывания методов

</details>

<details>
<summary>
## 49. Что такое Reflect API?
</summary>

Reflect — это встроенный объект, предоставляющий методы для перехватываемых JavaScript-операций. Эти методы идентичны обработчикам Proxy и часто используются вместе с ними.

```javascript
// Без Reflect
const value = target[property];
// С Reflect
const value = Reflect.get(target, property);

// Пример с Proxy
const user = { name: "Иван" };
const userProxy = new Proxy(user, {
  get(target, property, receiver) {
    console.log(`Получение ${property}`);
    return Reflect.get(target, property, receiver);
  },
});

// Проверка существования свойства
Reflect.has(user, "name"); // true, аналог 'name' in user

// Вызов метода с заданным this
Reflect.apply(func, thisArg, args);
```

Преимущества Reflect:

- Более функциональный API для объектных операций
- Все перехватываемые Proxy операции доступны как методы
- Возвращает более предсказуемые значения

</details>

<details>
<summary>
## 50. Что нового появилось в ES2022/ES2023?
</summary>

**ES2022**:

- Приватные поля и методы классов (#property)
- Top-level await
- Error cause (new Error('Message', { cause: originalError }))
- Object.hasOwn() (замена Object.prototype.hasOwnProperty)
- Array.at() для отрицательных индексов
- RegExp match indices (/d флаг)
- Class static initialization blocks

**ES2023**:

- Array findLast() и findLastIndex()
- Hashbang комментарии для исполняемых скриптов (#!/usr/bin/env node)
- Символы как ключи в WeakMap
- Array.prototype.toSorted(), toReversed(), toSpliced() (не модифицирующие методы)
- Новые методы Object.groupBy() и Map.groupBy()

</details>

<details>
<summary>
## 117. Что такое опциональная цепочка (?.) и оператор нулевого слияния (??)?
</summary>

**Опциональная цепочка (?.)** позволяет безопасно обращаться к свойствам вложенных объектов, которые могут быть null или undefined, без вызова ошибки.

**Оператор нулевого слияния (??)** возвращает правый операнд, если левый равен null или undefined, иначе возвращает левый.

```javascript
// Опциональная цепочка
const user = {
  address: null,
};

// Раньше
const city = user && user.address && user.address.city;

// С опциональной цепочкой
const city = user?.address?.city; // undefined без ошибки

// Работает с методами и свойствами
user.printAddress?.(); // не вызовет ошибку, если метод не существует
const firstItem = array?.[0]; // не вызовет ошибку, если array === null/undefined

// Оператор нулевого слияния
const name = user.name ?? "Гость"; // 'Гость', если user.name === null/undefined
// Отличие от || в том, что || возвращает правый операнд для любых falsy значений
// включая пустую строку, 0, false, а ?? только для null и undefined
```

</details>

<details>
<summary>
## 118. Как использовать динамический импорт модулей?
</summary>

Динамический импорт позволяет загружать модули по требованию (асинхронно) с помощью функции `import()`, которая возвращает Promise.

```javascript
// Обычный статический импорт
import { sum } from "./math.js";

// Динамический импорт
button.addEventListener("click", async () => {
  try {
    // Загружаем модуль только при необходимости
    const { sum } = await import("./math.js");
    console.log(sum(2, 3));
  } catch (error) {
    console.error("Не удалось загрузить модуль", error);
  }
});

// Условный импорт
if (условие) {
  import("./moduleA.js").then((moduleA) => {
    moduleA.init();
  });
} else {
  import("./moduleB.js").then((moduleB) => {
    moduleB.init();
  });
}

// Импорт всех модулей из списка
Promise.all(["./module1.js", "./module2.js"].map((path) => import(path))).then(
  (modules) => {
    // Используем загруженные модули
  }
);
```

Основные преимущества:

- Ленивая загрузка
- Уменьшение начального размера бандла
- Условный импорт
- Использование в не-модульных контекстах

</details>

<details>
<summary>
## 119. Что такое top-level await и где его можно использовать?
</summary>

**Top-level await** позволяет использовать ключевое слово `await` на верхнем уровне модуля, вне асинхронной функции. Модуль с top-level await приостанавливает выполнение всех модулей, которые его импортируют, до завершения выполнения ожидания.

```javascript
// config.js
export const config = await fetch("/api/config").then((r) => r.json());

// database.js
import { MongoClient } from "mongodb";
const client = new MongoClient(uri);
await client.connect(); // Top-level await
export const db = client.db("myDatabase");

// app.js
import { db } from "./database.js"; // Будет ждать завершения подключения
import { config } from "./config.js"; // Будет ждать загрузки конфигурации

// Использование
console.log(db, config); // Гарантированно инициализированы
```

Ограничения:

- Работает только внутри ES модулей (не в CommonJS)
- Модули, использующие top-level await, заставляют ждать все импортирующие их модули
- Может влиять на производительность загрузки

</details>

<details>
<summary>
## 120. Как работают приватные методы и свойства классов?
</summary>

Приватные методы и свойства классов обозначаются префиксом `#` и доступны только внутри класса, в котором они определены.

```javascript
class User {
  #password; // Приватное свойство

  constructor(username, password) {
    this.username = username; // Публичное свойство
    this.#password = password;
  }

  #hashPassword() {
    // Приватный метод
    return this.#password + "_hashed";
  }

  validatePassword(input) {
    return this.#hashPassword() === input + "_hashed";
  }

  // Статические приватные элементы
  static #count = 0;

  static #incrementCount() {
    this.#count++;
  }

  static getCount() {
    return this.#count;
  }
}

const user = new User("admin", "12345");
console.log(user.username); // 'admin'
// console.log(user.#password); // Ошибка: приватное поле
// user.#hashPassword(); // Ошибка: приватный метод
```

Особенности:

- Строго ограничивают доступ только внутри класса
- Не могут быть доступны из наследуемых классов
- Защищены на уровне языка (в отличие от соглашения с \_underscore)
- Работают как в экземплярах, так и в статических членах класса
  </details>

# Вопросы по производительности и оптимизации

<details>
<summary>
## 71. Что такое ленивая загрузка (lazy loading)?
</summary>

Техника оптимизации, при которой ресурсы (изображения, скрипты, компоненты) загружаются не сразу, а только когда они нужны или видны пользователю. Реализуется через:

- Атрибуты `loading="lazy"` для изображений
- `IntersectionObserver` для отслеживания видимости
- Динамический импорт (`import()`) для JavaScript-модулей
- React.lazy с Suspense для компонентов React

</details>

<details>
<summary>
## 72. Как улучшить производительность JavaScript-кода?
</summary>

- Избегать блокировки основного потока (длинных операций)
- Оптимизировать циклы и алгоритмы
- Использовать дебаунс и тротлинг для событий
- Минимизировать манипуляции с DOM
- Использовать Web Workers для тяжелых вычислений
- Применять подходящие структуры данных
- Использовать кэширование и меморизацию
- Убирать неиспользуемый код (tree shaking)

</details>

<details>
<summary>
## 73. Что такое виртуальный DOM и как он работает?
</summary>

Абстракция над реальным DOM:

1. Создается копия DOM в памяти (виртуальное дерево)
2. При изменении состояния создается новое виртуальное дерево
3. Выполняется сравнение (диффинг) старого и нового дерева
4. Определяются минимальные изменения для реального DOM
5. Применяются только необходимые изменения в реальном DOM
   Это уменьшает количество манипуляций с DOM и повышает производительность.

</details>

<details>
<summary>
## 74. Что такое дебаунс (debounce) и тротлинг (throttling)?
</summary>

Методы ограничения частоты вызова функций:

- **Debounce**: отложенное выполнение функции после серии событий (выполняется только раз после заданного периода бездействия)
- **Throttling**: ограничение частоты выполнения функции (выполняется не чаще чем раз в заданный период)

Применение:

- Debounce: поиск, автосохранение, изменение размера окна
- Throttling: скролл, drag-and-drop, анимации

</details>

<details>
<summary>
## 75. Как избежать блокировки UI при выполнении тяжелых операций?
</summary>

- Разбивать сложные задачи на подзадачи с помощью `setTimeout`/`requestAnimationFrame`
- Использовать Web Workers для параллельного выполнения кода
- Применять асинхронное программирование (Promise, async/await)
- Использовать виртуализацию для больших списков
- Обрабатывать данные частями (chunking) вместо всего массива

</details>

<details>
<summary>
## 76. Что такое Web Workers?
</summary>

API для запуска JavaScript в фоновых потоках, отдельных от основного потока:

- Работают параллельно, не блокируя UI
- Общение с основным потоком через сообщения
- Не имеют доступа к DOM, Window, Parent Objects
- Идеальны для тяжелых вычислений, работы с большими массивами данных
- Типы: Dedicated Workers, Shared Workers, Service Workers

</details>

<details>
<summary>
## 77. Как работает JIT-компиляция в JavaScript?
</summary>

Just-In-Time компиляция — метод исполнения кода в современных JS-движках:

1. Сначала код интерпретируется для быстрого запуска
2. Профилирование кода во время выполнения
3. Часто используемые участки (горячий код) компилируются в машинный код
4. Оптимизация и переоптимизация на основе типов данных
5. Деоптимизация при изменении условий выполнения
   Повышает производительность за счет баланса между временем запуска и скоростью выполнения.

</details>

<details>
<summary>
## 78. Что такое tree shaking?
</summary>

Техника удаления неиспользуемого кода при сборке:

- Основана на статическом анализе модулей ES
- Работает с `import`/`export` (но не с CommonJS)
- Удаляет неиспользуемые функции и переменные из бандла
- Уменьшает размер итогового JavaScript-файла
- Требует настройки сборщика (Webpack, Rollup)

</details>

<details>
<summary>
## 79. Как оптимизировать рекурсивные функции?
</summary>

- Хвостовая рекурсия (когда рекурсивный вызов — последняя операция)
- Меморизация (кэширование результатов для одинаковых входных данных)
- Преобразование рекурсии в итерацию для избежания переполнения стека
- Использование трамплинов (генераторов) для контролируемого выполнения
- Динамическое программирование для задач с перекрывающимися подзадачами

</details>

<details>
<summary>
## 80. Что такое меморизация и когда её стоит использовать?
</summary>

Техника оптимизации, при которой результаты выполнения функции кэшируются:

- Сохраняет результаты вызовов функции для повторного использования
- Идеальна для чистых функций с одинаковыми аргументами
- Полезна для вычислительно сложных операций
- Можно реализовать с помощью замыканий или библиотек (lodash.memoize)
- Компромисс между скоростью и памятью
- Применение: рекурсивные функции, сложные вычисления, рендеринг компонентов

</details>

<details>
<summary>
## 129. Как оптимизировать работу с DOM?
</summary>

- Минимизировать количество доступов к DOM
- Обновлять элементы вне потока (display: none, DocumentFragment)
- Использовать batch-обновления (один reflow вместо множества)
- Избегать forced reflow (запроса свойств, вызывающих синхронный reflow)
- Использовать CSS-классы вместо инлайн-стилей
- Делегировать события вместо множества обработчиков
- Виртуализировать большие списки (отображать только видимые элементы)

</details>

<details>
<summary>
## 130. Какие существуют способы оптимизации производительности рендеринга?
</summary>

- Уменьшение количества ресурсов (критический CSS, минификация)
- Оптимизация изображений (WebP, сжатие, lazy loading)
- Использование CSS-анимаций вместо JavaScript где возможно
- Избегание сложных CSS-селекторов
- Применение `will-change` для элементов, которые будут анимироваться
- Использование `requestAnimationFrame` для синхронизации с циклом отрисовки
- Virtual DOM для минимизации изменений в DOM
- Рендеринг на стороне сервера (SSR) для быстрой первой отрисовки

</details>

<details>
<summary>
## 131. Как работает Event Loop и какое влияние он оказывает на производительность?
</summary>

Event Loop — механизм обработки асинхронных операций в JavaScript:

1. Выполнение синхронного кода из стека вызовов
2. Проверка очереди микрозадач (Promise, queueMicrotask)
3. Проверка очереди задач (setTimeout, события DOM)
4. Выполнение задач рендеринга и requestAnimationFrame
5. Возврат к шагу 1

Влияние на производительность:

- Длинные синхронные операции блокируют UI
- Микрозадачи имеют приоритет над рендерингом
- Неправильная организация асинхронного кода может привести к задержкам рендеринга
- Тяжелые операции стоит разбивать на части или выполнять в Web Worker

</details>

<details>
<summary>
## 132. Что такое Service Workers и как их использовать для оффлайн-работы?
</summary>

JavaScript-воркеры, работающие как прокси между браузером и сетью:

- Действуют как программируемый сетевой кэш
- Работают в фоне, отдельно от страницы
- Остаются активными после закрытия вкладки
- Могут перехватывать сетевые запросы через событие `fetch`
- Жизненный цикл: регистрация → установка → активация

Для оффлайн-работы:

1. Кэширование ресурсов при установке
2. Перехват запросов и обслуживание из кэша
3. Обновление кэша при доступе к сети
4. Хранение данных в IndexedDB для последующей синхронизации
5. Стратегии кэширования: cache-first, network-first, stale-while-revalidate

</details>

# Вопросы по AJAX и сетевым взаимодействиям

<details>
<summary>
## 61. Что такое AJAX?
</summary>

AJAX (Asynchronous JavaScript and XML) — технология асинхронного обмена данными с сервером без перезагрузки страницы, используя объекты XMLHttpRequest или Fetch API.

</details>

<details>
<summary>
## 62. В чем разница между Fetch API и XMLHttpRequest?
</summary>

- `XMLHttpRequest` — старый API, более многословный, имеет события для отслеживания прогресса
- `Fetch API` — современный API, основан на Promise, имеет более чистый синтаксис, требует явной обработки ошибок статуса HTTP
- Fetch не отменяет запросы автоматически при покидании страницы (нужен AbortController)

</details>

<details>
<summary>
## 63. Как работать с CORS?
</summary>

Cross-Origin Resource Sharing — механизм, позволяющий запрашивать ресурсы с других доменов:

- Сервер должен отправлять заголовок `Access-Control-Allow-Origin`
- Для запросов с кредами нужен `Access-Control-Allow-Credentials: true`
- Сложные запросы (с кастомными заголовками, не GET/POST) сначала отправляют preflight OPTIONS-запрос

</details>

<details>
<summary>
## 64. Что такое Same-Origin Policy?
</summary>

Политика безопасности, ограничивающая доступ скриптов к ресурсам другого источника (домена, протокола или порта). Защищает от XSS и CSRF атак.

</details>

<details>
<summary>
## 65. Как работать с FormData?
</summary>

- API для создания наборов пар ключ/значение для отправки на сервер
- Удобен для отправки форм и файлов
- Создание: `new FormData(formElement)` или программно с `append()`
- Используется с `fetch()` или `XMLHttpRequest`

</details>

<details>
<summary>
## Что такое идемпотентность HTTP методов?
</summary>

Идемпотентность — свойство операции, при котором многократное выполнение даёт тот же результат, что и однократное:

- Идемпотентные методы: GET, HEAD, PUT, DELETE, OPTIONS, TRACE
- Не идемпотентные: POST
- PATCH технически не обязан быть идемпотентным, но часто реализуется как идемпотентный

Идемпотентность важна для надёжности систем: при повторной отправке запроса из-за ошибки сети идемпотентные операции не вызовут нежелательных побочных эффектов.

</details>

<details>
<summary>
## 66. Какие HTTP методы вы знаете?
</summary>

- `GET` — получение данных
- `POST` — отправка данных для создания ресурса
- `PUT` — обновление ресурса полностью
- `PATCH` — частичное обновление ресурса
- `DELETE` — удаление ресурса
- `OPTIONS` — информация о возможностях соединения
- `HEAD` — получение заголовков без тела ответа

</details>

<details>
<summary>
## 67. Что такое JWT?
</summary>

JSON Web Token — компактный, самодостаточный способ безопасной передачи информации в формате JSON. Состоит из:

- Header (алгоритм шифрования)
- Payload (данные)
- Signature (подпись для проверки целостности)
  Используется для аутентификации и безопасной передачи информации.

</details>

<details>
<summary>
## 68. Как обрабатывать загрузку файлов в JavaScript?
</summary>

- Через `<input type="file">` и обработку события `change`
- Использование `FormData` для отправки файлов
- Использование `FileReader` для чтения содержимого файла
- Drag-and-drop API для перетаскивания файлов
- Обработка через `fetch()` или `XMLHttpRequest`

</details>

<details>
<summary>
## 69. Как отслеживать прогресс загрузки/скачивания файлов?
</summary>

- В `XMLHttpRequest` через события `progress`, `load`, `error`
- В `Fetch API` через `Response.body` как ReadableStream и чтение чанками
- С библиотекой Axios через обработчик `onUploadProgress`/`onDownloadProgress`

</details>

<details>
<summary>
## 70. Как работает WebRTC?
</summary>

Web Real-Time Communication — технология для передачи аудио/видео/данных напрямую между браузерами (P2P):

- Использует STUN/TURN серверы для обхода NAT
- Сигнальный сервер для обмена SDP-сообщениями
- Компоненты: getUserMedia(), RTCPeerConnection, RTCDataChannel
- Применяется для видеоконференций, чатов, файлообмена

</details>

<details>
<summary>
## 125. Что такое Server-Sent Events?
</summary>

API для получения автоматических обновлений с сервера через HTTP-соединение:

- Однонаправленная связь (только сервер → клиент)
- Автоматическое переподключение при обрыве
- Проще WebSocket для односторонних обновлений
- Создание: `new EventSource(url)`

</details>

<details>
<summary>
## 126. Как реализовать поллинг и длинные опросы (long polling)?
</summary>

- **Обычный поллинг**: регулярные запросы через `setInterval(fetch, interval)`
- **Long polling**:
  1. Клиент делает запрос
  2. Сервер держит соединение открытым до появления данных
  3. После получения ответа клиент сразу делает новый запрос
  4. Меньше запросов, чем при обычном поллинге, но нагружает сервер

</details>

<details>
<summary>
## 127. Что такое JSON Web Token и как его использовать для аутентификации?
</summary>

JWT для аутентификации:

- После успешной авторизации сервер генерирует токен
- Токен сохраняется клиентом (localStorage, cookie)
- Клиент отправляет токен с каждым запросом (обычно в заголовке Authorization)
- Сервер валидирует подпись токена без обращения к БД
- Плюсы: stateless, масштабируемость, децентрализация

</details>

<details>
<summary>
## 128. Как эффективно кэшировать запросы на клиенте?
</summary>

- HTTP-заголовки кэширования (Cache-Control, ETag)
- Service Workers для перехвата и кэширования запросов
- Локальное кэширование ответов в localStorage/IndexedDB
- Библиотеки с встроенным кэшированием (SWR, React Query)
- Стратегии кэширования: stale-while-revalidate, кэш-первый, сеть-первый
</details>

# Вопросы по DOM и браузерному API

<details>
<summary>
## 51. Что такое DOM?
</summary>

DOM (Document Object Model) — объектная модель документа, представляющая HTML-страницу в виде дерева объектов, с которыми можно взаимодействовать через JavaScript.

</details>

<details>
<summary>
## 52. Какие методы поиска элементов в DOM вы знаете?
</summary>

- `getElementById()` — поиск по ID
- `getElementsByClassName()` — поиск по классу
- `getElementsByTagName()` — поиск по тегу
- `querySelector()` — поиск первого элемента по CSS-селектору
- `querySelectorAll()` — поиск всех элементов по CSS-селектору

</details>

<details>
<summary>
## 53. Чем отличается innerHTML от textContent?
</summary>

- `innerHTML` — возвращает/изменяет содержимое элемента вместе с HTML-разметкой
- `textContent` — возвращает/изменяет только текстовое содержимое элемента без парсинга HTML

</details>

<details>
<summary>
## 54. Что такое делегирование событий?
</summary>

Техника, при которой обработчик события назначается родительскому элементу вместо каждого дочернего. Основана на всплытии событий и позволяет обрабатывать события для динамически добавляемых элементов.

</details>

<details>
<summary>
## 55. Как работает всплытие и погружение событий?
</summary>

- Всплытие (bubbling) — событие сначала срабатывает на целевом элементе, затем поднимается вверх по дереву DOM
- Погружение (capturing) — событие сначала срабатывает на корневом элементе, затем спускается до целевого элемента
- Порядок: погружение → целевой элемент → всплытие
- Третий параметр в `addEventListener(event, handler, useCapture)` определяет фазу

</details>

<details>
<summary>
## 56. Что такое BOM (Browser Object Model)?
</summary>

BOM — объектная модель браузера, представляющая объекты для взаимодействия с браузером: `window`, `navigator`, `location`, `history`, `screen`.

</details>

<details>
<summary>
## 57. Как работают localStorage и sessionStorage?
</summary>

- Оба являются Web Storage API для хранения данных на стороне клиента
- `localStorage` — сохраняет данные без срока истечения
- `sessionStorage` — данные сохраняются только на время сессии (до закрытия вкладки)
- Методы: `setItem()`, `getItem()`, `removeItem()`, `clear()`
- Ограничение ~5MB на домен

</details>

<details>
<summary>
## 58. Как работают Cookie?
</summary>

- Небольшие текстовые файлы, хранящиеся в браузере
- Имеют срок действия (expires/max-age)
- Отправляются с каждым HTTP-запросом к домену
- Могут иметь флаги (HttpOnly, Secure, SameSite)
- Ограничение ~4KB

</details>

<details>
<summary>
## 59. Что такое Shadow DOM?
</summary>

Инкапсулированное DOM-дерево, прикрепленное к элементу, но отделенное от основного DOM. Позволяет изолировать стили и структуру компонента.

</details>

<details>
<summary>
## 60. Что такое Web Components?
</summary>

Набор стандартов для создания переиспользуемых компонентов:

- Custom Elements — API для создания пользовательских HTML-элементов
- Shadow DOM — изоляция DOM и стилей
- HTML Templates — `<template>` для определения шаблонов
- ES Modules — импорт/экспорт компонентов

</details>

<details>
<summary>
## 121. Как работает событие click и почему иногда требуется preventDefault()?
</summary>

- `click` срабатывает при щелчке мыши по элементу
- `preventDefault()` предотвращает действия браузера по умолчанию (отправку формы, переход по ссылке)
- Используется, когда нужно заменить стандартное поведение собственной логикой

</details>

<details>
<summary>
## 122. Что такое MutationObserver и IntersectionObserver?
</summary>

- `MutationObserver` — отслеживает изменения в DOM-дереве
- `IntersectionObserver` — асинхронно отслеживает пересечение элемента с его родителем или viewport (для ленивой загрузки, бесконечной прокрутки)

</details>

<details>
<summary>
## 123. Как работать с мультимедийными элементами (audio, video) через JavaScript?
</summary>

- Доступ через DOM: `document.querySelector('video')`
- Методы: `play()`, `pause()`, `load()`
- Свойства: `currentTime`, `volume`, `playbackRate`
- События: `play`, `pause`, `ended`, `timeupdate`

</details>

<details>
<summary>
## 124. Что такое requestAnimationFrame и когда его использовать?
</summary>

- Метод планирования анимаций, синхронизированный с циклом обновления браузера (~60 FPS)
- Используется для плавных анимаций вместо `setTimeout/setInterval`
- Приостанавливается в неактивных вкладках
- Оптимизирует производительность и расход батареи
</details>

# Управление памятью в JavaScript

<details>
<summary>81. Как происходит сборка мусора в JavaScript?</summary>

JavaScript использует автоматическую сборку мусора через алгоритм "mark-and-sweep":

- **Marking**: Движок отмечает достижимые объекты (корневые и ссылающиеся)
- **Sweeping**: Недостижимые объекты удаляются из памяти
- Современные движки используют дополнительные оптимизации: инкрементальную сборку, поколенческую сборку и параллельную/конкурентную сборку

</details>

<details>
<summary>82. Что такое утечки памяти и как их избежать?</summary>

Утечки памяти — когда неиспользуемые объекты остаются в памяти из-за сохраненных ссылок.

Основные причины и решения:

- Случайные глобальные переменные — избегайте использования неявных глобальных переменных
- Забытые таймеры и слушатели — всегда очищайте с clearTimeout/clearInterval и removeEventListener
- Замыкания, удерживающие большие объекты — следите за контекстом и явно удаляйте ссылки
- Отсоединенные DOM элементы с активными ссылками в коде — обнуляйте ссылки на удаляемые DOM-элементы

</details>

<details>
<summary>83. Как работает стек и хип в JavaScript?</summary>

- **Стек**: Хранит примитивные значения и ссылки на объекты. Ограниченного размера, автоматически освобождается
- **Хип**: Место для хранения объектов и функций. Динамически выделяется, очищается сборщиком мусора
- Примитивы (number, string, boolean) хранятся в стеке
- Объекты (включая массивы, функции) хранятся в хипе, а ссылки на них — в стеке

</details>

<details>
<summary>84. Какие инструменты существуют для отладки утечек памяти?</summary>

- **Chrome DevTools**:
  - Вкладка Memory (Memory Snapshots, Allocation Timeline)
  - Performance Monitor и Performance Profiles
  - Heap profiling
- **Firefox DevTools** Memory Tool
- **Node.js** — модули heap-snapshot, memwatch-next
- **Lighthouse** — для аудита производительности
- **Инструменты третьих сторон**: Sentry, Datadog, New Relic

</details>

<details>
<summary>85. Что такое WeakRef и FinalizationRegistry?</summary>

- **WeakRef** создает слабую ссылку на объект, которая не препятствует сборке мусора. Полезно когда нужно кэшировать данные, не блокируя их удаление

```javascript
const cache = new Map();
const weakRef = new WeakRef(объект);
const объектИлиUndefined = weakRef.deref();
```

- **FinalizationRegistry** позволяет регистрировать callback, который вызывается после сборки мусора объекта. Используется для очистки ресурсов, связанных с удаленным объектом

```javascript
const registry = new FinalizationRegistry((heldValue) => {
  // Выполнить очистку при удалении объекта
});
registry.register(объект, "метаданные для очистки");
```

</details>

<details>
<summary>86. Как обрабатывать большие объемы данных без нагрузки на память?</summary>

- **Разделение на чанки**: обрабатывать данные частями вместо целиком
- **Виртуализация списков**: рендерить только видимые элементы (react-window, react-virtualized)
- **Пагинация**: загружать только необходимые страницы данных
- **Web Workers**: перенос тяжелых вычислений в отдельные потоки
- **Потоковая обработка**: использование Streams API
- **Сжатие данных**: хранение в оптимизированном формате
- **Освобождение ресурсов**: явное удаление ссылок на ненужные данные

</details>

<details>
<summary>87. Какие существуют паттерны для эффективного управления памятью?</summary>

- **Пул объектов**: переиспользование созданных объектов вместо создания новых
- **Разделяемые ресурсы**: использование единого экземпляра для общих данных
- **Ленивая инициализация**: создание объектов только при первом обращении
- **Композиция вместо наследования**: снижает взаимосвязанность объектов
- **Прокси и заместители**: для отложенной загрузки тяжелых ресурсов
- **Использование примитивов**: где возможно, использовать примитивы вместо объектов
- **Освобождение ссылок**: явное присвоение null неиспользуемым объектам

</details>

<details>
<summary>88. Как использование замыканий влияет на память?</summary>

Замыкания сохраняют доступ к переменным из внешних функций и могут:

- **Увеличивать расход памяти**: замыкания хранят ссылки на все переменные из области видимости родительской функции
- **Вызывать утечки памяти**: если объекты в замыкании остаются досягаемыми дольше чем нужно
- **Оптимизация**: модули с замыканиями должны хранить только необходимые данные
- **Осторожно** с замыканиями в циклах и обработчиках событий

```javascript
// Потенциальная утечка
function createButtons() {
  let heavyData = new Array(10000).fill("data");

  document.querySelector("button").addEventListener("click", function () {
    console.log(heavyData.length); // Захват всего массива в замыкании
  });
}
```

</details>

<details>
<summary>89. Как происходит выделение памяти в JavaScript?</summary>

- **Автоматическое выделение**: JavaScript сам выделяет память при создании объектов/значений
- **Примитивы**: выделяется фиксированный объем памяти
- **Объекты**: выделяется память для структуры и свойств
- **Динамическое выделение**: размер массивов/объектов может меняться в runtime
- **Пул строк**: идентичные строковые литералы могут использовать одну область памяти
- **JIT-компиляция**: может оптимизировать выделение памяти в рантайме

</details>

<details>
<summary>90. Какие антипаттерны ведут к утечкам памяти?</summary>

- **Забытые слушатели событий**: неудаленные обработчики препятствуют сборке мусора
- **Циклические ссылки между DOM и JS объектами**
- **Таймеры без очистки**: необработанные setInterval/setTimeout
- **Замыкания, ссылающиеся на большие структуры данных**
- **Кэширование без ограничений**: неконтролируемый рост кэшей
- **Глобальные переменные и объекты**: задерживаются в памяти на протяжении работы приложения
- **Неправильное использование WeakMap/WeakSet**: использование обычных Map/Set для хранения DOM-элементов

</details>

<details>
<summary>133. Как избежать утечек памяти при работе с DOM?</summary>

- **Удаляйте обработчики событий** перед удалением элементов
- **Используйте делегирование событий** вместо назначения множества обработчиков
- **Применяйте WeakMap/WeakSet** для связывания данных с DOM-элементами
- **Очищайте ссылки на DOM** в JS коде при удалении элементов
- **Избегайте замыканий**, захватывающих DOM-элементы
- **Используйте MutationObserver** для отслеживания изменений DOM
- **Анализируйте DOM-утечки** с помощью DevTools (detached DOM elements)

</details>

<details>
<summary>134. Как оптимизировать JavaScript-код для минимального использования памяти?</summary>

- **Переиспользуйте объекты** вместо создания новых
- **Освобождайте ресурсы** явно (null для крупных объектов)
- **Используйте примитивы** вместо объектов где возможно
- **Закрывайте неиспользуемые соединения** (WebSockets, fetch)
- **Минимизируйте использование замыканий** для больших структур
- **Используйте структурированные данные** (TypedArray, ArrayBuffer)
- **Избегайте глубоких цепочек прототипов**
- **Оптимизируйте работу с DOM** (DocumentFragment, виртуализация)

</details>

<details>
<summary>135. Каковы признаки утечки памяти в web-приложении?</summary>

- **Постоянно растущее потребление памяти** в инструментах разработчика
- **Замедление производительности** со временем работы приложения
- **Сбои браузера** или вкладок при длительном использовании
- **Высокая активность GC** (частые паузы при сборке мусора)
- **Увеличение графика памяти** в Timeline/Performance
- **Растущее количество detached DOM nodes** в Memory snapshots
- **Снижение отзывчивости интерфейса** при длительной работе

</details>

<details>
<summary>136. Как и когда следует использовать объекты WeakMap и WeakSet?</summary>

**WeakMap и WeakSet** создают слабые ссылки, которые не препятствуют сборке мусора объектов-ключей.

**Когда использовать WeakMap:**

- Для связывания данных с DOM-элементами
- Для приватных данных объектов
- Для кэшей и мемоизации, где ключи могут быть удалены
- В качестве хранилища метаданных для внешних объектов

**Когда использовать WeakSet:**

- Для маркировки объектов (проверки "был ли объект обработан")
- Отслеживания посещенных объектов без блокировки их сборки
- Регистрации объектов для слабой связи

**Ограничения:**

- Ключами могут быть только объекты (не примитивы)
- Нельзя итерировать (нет методов keys(), entries())
- Нельзя получить размер (нет свойства size)

```javascript
// Пример WeakMap для DOM-данных
const elementData = new WeakMap();

const element = document.getElementById("test");
elementData.set(element, { clicks: 0, data: largeObject });

// Когда element удаляется из DOM, данные в WeakMap
// автоматически становятся доступными для сборки мусора
```

</details>

# Прочие вопросы по JavaScript

<details>
<summary>91. Что такое TypeScript и какие преимущества он дает?</summary>

TypeScript — это надмножество JavaScript, добавляющее статическую типизацию:

- **Раннее обнаружение ошибок**: выявление ошибок на этапе компиляции
- **Улучшенная IDE-поддержка**: автодополнение, рефакторинг, навигация
- **Типобезопасность**: явное объявление типов переменных, параметров, возвращаемых значений
- **Улучшенная читаемость кода**: типы как документация
- **Интерфейсы и дженерики**: мощные инструменты для моделирования данных
- **Совместимость с JS**: работает с существующим JavaScript кодом

</details>

<details>
<summary>92. Какие паттерны проектирования вы применяете в JavaScript?</summary>

**Порождающие паттерны**:

- **Синглтон**: единственный экземпляр класса (хранилища состояния)
- **Фабрика**: создание объектов без указания конкретного класса
- **Модульный паттерн**: инкапсуляция кода в модули

**Структурные паттерны**:

- **Декоратор**: динамическое добавление функциональности объектам (HOC в React)
- **Фасад**: упрощение сложного API через простой интерфейс
- **Адаптер**: согласование интерфейсов разных классов

**Поведенческие паттерны**:

- **Наблюдатель**: система подписок/уведомлений (EventEmitter, Rx.js)
- **Стратегия**: выбор алгоритма "на лету"
- **Цепочка ответственности**: передача запроса по цепочке обработчиков
- **Команда**: инкапсуляция действия в объект

</details>

<details>
<summary>93. Как работает система модулей (CommonJS, ES modules, AMD)?</summary>

**CommonJS** (Node.js):

- Синхронная загрузка модулей
- `require()` для импорта, `module.exports` для экспорта
- Исполнение в момент импорта

```javascript
// импорт
const module = require("./module");
// экспорт
module.exports = { func };
```

**ES Modules** (стандарт ECMAScript):

- Асинхронная загрузка
- Статический анализ зависимостей на этапе сборки
- `import`/`export` операторы

```javascript
// импорт
import { func } from "./module";
// экспорт
export const func = () => {};
```

**AMD** (Asynchronous Module Definition):

- Асинхронная загрузка для браузеров
- Функция `define` для определения модулей
- Популярна в старых проектах (RequireJS)

```javascript
define(["dependency"], function (dependency) {
  return { method: function () {} };
});
```

**UMD** (Universal Module Definition):

- Универсальный формат, совместимый с CommonJS и AMD
- Часто используется в библиотеках

</details>

<details>
<summary>94. Что такое функциональное программирование в JavaScript?</summary>

Парадигма программирования, основанная на использовании функций с минимальными побочными эффектами:

**Основные принципы**:

- **Чистые функции**: результат зависит только от входных данных без побочных эффектов
- **Иммутабельность**: данные не изменяются, создаются новые копии
- **Функции высшего порядка**: функции, принимающие или возвращающие другие функции
- **Композиция функций**: создание новых функций путем комбинирования существующих

**Преимущества**:

- Предсказуемость и отсутствие побочных эффектов
- Лучшая тестируемость кода
- Параллельное выполнение
- Декларативный код

**Примеры в JS**:

```javascript
// Чистая функция
const add = (a, b) => a + b;

// Функции высшего порядка
const double = (x) => x * 2;
const map = (fn, arr) => arr.map(fn);
map(double, [1, 2, 3]); // [2, 4, 6]

// Композиция
const compose = (f, g) => (x) => f(g(x));
const addThenDouble = compose(double, add);
```

</details>

<details>
<summary>95. Как работает интернационализация в JavaScript?</summary>

Интернационализация (i18n) в JavaScript реализуется через:

**Intl API** (нативный API для интернационализации):

- **Intl.DateTimeFormat**: форматирование даты и времени
- **Intl.NumberFormat**: форматирование чисел
- **Intl.Collator**: сравнение строк с учетом языка
- **Intl.PluralRules**: работа с формами множественного числа
- **Intl.RelativeTimeFormat**: форматирование относительного времени
- **Intl.Segmenter**: сегментация текста

```javascript
// Форматирование даты
new Intl.DateTimeFormat("ru-RU").format(new Date()); // "01.02.2023"

// Форматирование чисел
new Intl.NumberFormat("ru-RU").format(1234567.89); // "1 234 567,89"
```

**Библиотеки для локализации**:

- **i18next**: полный стек для интернационализации
- **React-intl/Vue-i18n**: интеграция i18n с фреймворками
- **FormatJS**: набор библиотек для интернационализации

**Практики**:

- Отделение текстов от кода в файлы локализации
- Поддержка плюрализации и переменных в переводах
- Учет направления текста (LTR/RTL)
- Адаптация форматов даты, времени и чисел

</details>

<details>
<summary>96. Что такое итераторы и итерируемые объекты?</summary>

**Итерируемый объект** — объект, который может быть перебран в цикле `for...of`. Должен иметь метод `Symbol.iterator`, возвращающий **итератор**.

**Итератор** — объект, реализующий метод `next()`, который возвращает объект с двумя свойствами:

- `value`: текущее значение
- `done`: флаг завершения итерации (true/false)

```javascript
// Создание итерируемого объекта
const range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      next() {
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
};

// Использование в for...of
for (let num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}

// Встроенные итерируемые объекты:
// - Arrays, Strings, Maps, Sets, NodeList
// - arguments, FileList
```

**Генераторы** — специальные функции, упрощающие создание итераторов:

```javascript
function* generateRange(from, to) {
  for (let i = from; i <= to; i++) {
    yield i;
  }
}

const genRange = generateRange(1, 5);
for (let num of genRange) {
  console.log(num); // 1, 2, 3, 4, 5
}
```

</details>

<details>
<summary>97. Как тестировать JavaScript-код?</summary>

**Уровни тестирования**:

- **Модульные тесты**: проверка отдельных функций/компонентов
- **Интеграционные тесты**: проверка взаимодействия модулей
- **E2E тесты**: сквозное тестирование всего приложения

**Фреймворки для тестирования**:

- **Jest**: универсальный фреймворк с моками, снапшотами и покрытием
- **Mocha**: гибкий фреймворк (требует chai/sinon для ассертов)
- **Jasmine**: включает все необходимое для TDD/BDD
- **Vitest**: быстрый фреймворк для Vite-проектов

**Инструменты для E2E-тестирования**:

- **Cypress**: E2E и компонентное тестирование
- **Playwright**: мультибраузерная автоматизация тестирования
- **Puppeteer**: управление Chrome/Chromium через API
- **WebdriverIO**: реализация WebDriver протокола

**Подходы к тестированию**:

- **TDD**: сначала тесты, потом код
- **BDD**: поведенческий подход с описанием бизнес-требований
- **Snapshot Testing**: проверка соответствия с сохраненными снапшотами

**Пример модульного теста с Jest**:

```javascript
test("sum adds numbers", () => {
  expect(sum(1, 2)).toBe(3);
  expect(sum(-1, 1)).toBe(0);
});
```

</details>

<details>
<summary>98. Что такое JSDoc и зачем он нужен?</summary>

**JSDoc** — система документирования кода JavaScript в формате комментариев:

**Назначение**:

- Документирование типов в JavaScript (особенно для нетипизированного кода)
- Генерация HTML-документации
- Помощь IDE в понимании типов и автодополнении
- Улучшение читаемости кода для разработчиков

**Основные теги**:

- `@param {тип} имя - описание` — параметр функции
- `@returns {тип} описание` — возвращаемое значение
- `@type {тип}` — тип переменной/свойства
- `@typedef {тип} имя` — определение пользовательского типа
- `@callback имя` — описание функции обратного вызова
- `@throws {тип}` — описание исключений
- `@example` — пример использования

```javascript
/**
 * Функция сложения двух чисел
 * @param {number} a - Первое слагаемое
 * @param {number} b - Второе слагаемое
 * @returns {number} Сумма чисел
 * @example
 * // Возвращает 3
 * add(1, 2);
 */
function add(a, b) {
  return a + b;
}
```

**Инструменты**:

- **jsdoc** — генератор документации
- **better-docs** — улучшенные темы для jsdoc
- **typescript** — проверка типов JSDoc с помощью компилятора TS

</details>

<details>
<summary>99. Как работает событийная модель в JavaScript?</summary>

**Основные принципы событийной модели**:

- События представляют действия пользователя или системы
- События могут быть перехвачены обработчиками
- События обычно "всплывают" (bubble) от дочерних элементов к родительским

**Основные компоненты**:

- **EventTarget** — объект, способный генерировать события
- **Event** — объект, представляющий произошедшее событие
- **EventListener** — функция, обрабатывающая событие

**Регистрация обработчиков**:

```javascript
// DOM API
element.addEventListener("click", handler, options);
element.removeEventListener("click", handler);

// Свойства on*
element.onclick = function () {};

// Делегирование событий
container.addEventListener("click", function (e) {
  if (e.target.matches(".button")) {
    // Обработка клика по кнопке
  }
});
```

**Фазы события DOM**:

1. **Перехват (capturing)**: от `window` к целевому элементу
2. **Цель (target)**: обработка на целевом элементе
3. **Всплытие (bubbling)**: от целевого элемента к `window`

**Методы Event**:

- `event.preventDefault()` — отмена стандартного поведения
- `event.stopPropagation()` — остановка всплытия
- `event.stopImmediatePropagation()` — остановка всплытия и других обработчиков

**Custom Events**:

```javascript
const event = new CustomEvent("myEvent", {
  detail: { data: "value" },
  bubbles: true,
});
element.dispatchEvent(event);
```

</details>

<details>
<summary>100. Какие нововведения из последних версий ECMAScript вы считаете самыми полезными?</summary>

**ES2022 (ES13)**:

- Top-level await
- Private fields и методы в классах
- Static блоки в классах
- `.at()` для индексированных коллекций
- RegExp match indices

**ES2021 (ES12)**:

- String.prototype.replaceAll
- Promise.any и AggregateError
- Логические операторы присваивания (&&=, ||=, ??=)
- Числовые разделители (\_): `1_000_000`

**ES2020 (ES11)**:

- Оператор опциональной цепочки (?.)
- Оператор нулевого слияния (??)
- BigInt для работы с большими числами
- Dynamic import
- Promise.allSettled
- globalThis

**ES2019 (ES10)**:

- Array.prototype.flat и flatMap
- Object.fromEntries
- String.prototype.trimStart/trimEnd
- Optional catch binding

**ES2018 (ES9)**:

- Асинхронные итераторы и for-await-of
- Object spread/rest операторы
- Promise.prototype.finally

</details>

<details>
<summary>137. Что такое PWA (Progressive Web Apps) и какие технологии JavaScript в них используются?</summary>

**PWA (Progressive Web Apps)** — веб-приложения, использующие современные технологии для обеспечения опыта, близкого к нативным приложениям:

**Ключевые характеристики**:

- **Прогрессивность**: работа для всех пользователей независимо от браузера
- **Адаптивность**: подходит для любых устройств
- **Офлайн-работа**: функционирует при плохом соединении или его отсутствии
- **Установка на устройство**: возможность добавления на домашний экран
- **Обновляемость**: всегда актуальная версия
- **Безопасность**: HTTPS

**Основные технологии**:

- **Service Workers**: скрипты, работающие в фоне для кэширования и офлайн-функциональности
- **Web App Manifest**: JSON-файл, определяющий внешний вид при установке
- **Push API**: позволяет отправлять уведомления даже когда приложение закрыто
- **Cache API**: программное управление кэшем ресурсов
- **IndexedDB**: хранение данных на клиенте
- **Background Sync**: синхронизация данных в фоне при восстановлении соединения

**Пример регистрации Service Worker**:

```javascript
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/sw.js")
    .then((registration) => console.log("SW registered:", registration))
    .catch((error) => console.log("SW registration failed:", error));
}
```

</details>

<details>
<summary>138. Как работает сборка мусора и управление памятью в JavaScript?</summary>

**Сборка мусора**:

- Автоматический процесс освобождения памяти от недоступных объектов
- Основной алгоритм: "mark-and-sweep" (пометка и удаление)
- Объект помечается как мусор, когда становится недоступным
- Оптимизации: инкрементальная, поколенческая, параллельная сборка

**Жизненный цикл объекта**:

1. Выделение памяти при создании
2. Использование памяти
3. Освобождение памяти, когда объект становится недоступным

**Причины утечек памяти**:

- Глобальные переменные (случайные или намеренные)
- Незакрытые слушатели событий
- Замыкания, удерживающие большие объекты
- Циклические ссылки между DOM и JavaScript объектами

**Предотвращение утечек**:

- Явно удалять обработчики событий
- Использовать WeakMap/WeakSet для хранения DOM-элементов
- Ограничивать размер кэшей
- Осторожно работать с замыканиями

**Инструменты отладки памяти**:

- Chrome DevTools Memory panel
- Performance monitoring
- Heap snapshots сравнение

</details>

<details>
<summary>139. Что такое WebAssembly и как он взаимодействует с JavaScript?</summary>

**WebAssembly (WASM)** — бинарный формат низкого уровня, предназначенный для выполнения в браузере с почти нативной производительностью:

**Ключевые особенности**:

- Компактный бинарный формат
- Выполнение на скорости, близкой к нативной
- Поддержка языков C, C++, Rust и др.
- Работа в защищенной среде (песочнице) браузера

**Взаимодействие с JavaScript**:

- JS может создавать модули WASM и вызывать их функции
- WASM может вызывать функции JavaScript
- Обмен данными через общую память (SharedArrayBuffer)
- WASM не имеет прямого доступа к DOM (только через JS)

**Типичные сценарии использования**:

- Вычислительно-интенсивные задачи (обработка медиа, физика, 3D)
- Игры и графические приложения
- Портирование существующих приложений в веб
- Криптография и шифрование

**Пример загрузки и использования**:

```javascript
// Загрузка модуля WebAssembly
const importObject = { imports: { imported_func: (arg) => console.log(arg) } };

WebAssembly.instantiateStreaming(fetch("module.wasm"), importObject).then(
  (obj) => {
    // Вызов функции из WASM
    obj.instance.exports.exported_func();
  }
);
```

**Инструменты и компиляторы**:

- Emscripten: компиляция C/C++ в WASM
- wasm-bindgen: интеграция Rust и JavaScript
- AssemblyScript: TypeScript-подобный язык для WASM

</details>

<details>
<summary>140. Как обеспечить безопасность JavaScript-приложений?</summary>

**Основные угрозы**:

- **XSS (Cross-Site Scripting)**: внедрение вредоносного кода
- **CSRF (Cross-Site Request Forgery)**: выполнение действий от имени пользователя
- **Инъекции**: внедрение кода в JSON, SQL и т.д.
- **Небезопасное использование eval()** и динамического кода
- **Утечки информации** через хранилища и cookies

**Защита от XSS**:

- Экранирование пользовательского ввода
- Использование Content Security Policy (CSP)
- Применение HttpOnly и Secure флагов для cookies
- Использование DOMPurify для очистки HTML

**Защита от CSRF**:

- CSRF-токены для аутентификации запросов
- SameSite cookie атрибут
- Проверка заголовка Origin/Referer
- Подтверждение важных действий

**Другие практики безопасности**:

- Минимизация поверхности атаки (минимальные привилегии)
- Регулярные обновления зависимостей (npm audit)
- Статический анализ кода
- Проверка библиотек на уязвимости
- Правильная обработка ошибок без утечки информации

**Инструменты безопасности**:

- ESLint с правилами безопасности
- OWASP ZAP для сканирования уязвимостей
- Snyk для аудита зависимостей
- Content Security Policy для ограничения выполнения кода

```javascript
// Пример настройки CSP заголовка
// Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com;
```

</details>

<details>
<summary>141. Как устроена отладка JavaScript-кода и какие инструменты используются?</summary>

**Основные инструменты отладки**:

- **Chrome DevTools / Firefox DevTools**: встроенные инструменты браузера
- **VS Code Debugger**: отладка прямо в редакторе
- **node --inspect**: отладка Node.js приложений
- **Логгирование**: console.log и специализированные логгеры

**Возможности браузерных DevTools**:

- **Sources**: установка breakpoints, пошаговое выполнение, просмотр стека вызовов
- **Console**: логирование и выполнение выражений
- **Network**: анализ HTTP запросов
- **Performance**: профилирование производительности
- **Memory**: анализ памяти и утечек
- **Application**: работа с хранилищами и Service Workers

**Техники отладки**:

- **Breakpoints**: остановка выполнения для проверки состояния
- **Watch Expressions**: отслеживание выражений
- **Call Stack**: анализ стека вызовов
- **Conditional Breakpoints**: остановка по условию
- **logpoints/tracepoints**: логирование без изменения кода

**Отладка асинхронного кода**:

- **Async call stack**: трассировка асинхронных вызовов
- **Promise debugging**: отладка цепочек промисов
- **async/await breakpoints**: остановка на асинхронных операциях

**Примеры команд console**:

```javascript
console.log("Данные:", data); // Базовое логирование
console.table(arrayOfObjects); // Вывод в табличном формате
console.time("label");
/* код */ console.timeEnd("label"); // Замер времени выполнения
console.trace(); // Вывод стека вызовов
console.assert(condition, "сообщение"); // Условное логирование
```

</details>

<details>
<summary>142. Что такое TDD (Test-Driven Development) в контексте JavaScript?</summary>

**TDD (Test-Driven Development)** — методология разработки, при которой сначала пишутся тесты, а затем код, удовлетворяющий этим тестам:

**Цикл TDD**:

1. **Red**: Написать тест, который не проходит
2. **Green**: Написать минимальный код для прохождения теста
3. **Refactor**: Улучшить код без изменения его поведения

**Преимущества TDD**:

- Более надежный код с меньшим количеством багов
- Автоматическая проверка регрессий
- Улучшенный дизайн (тесты заставляют создавать модульный код)
- Документация через тесты (примеры использования)
- Уверенность при рефакторинге

**Инструменты для TDD в JavaScript**:

- **Jest**: полный набор для TDD (матчеры, моки, покрытие)
- **Mocha + Chai**: гибкая комбинация тестового фреймворка и библиотеки утверждений
- **Vitest**: быстрый тестовый фреймворк для Vite
- **Cypress/Playwright** для TDD на уровне компонентов/E2E

**Пример TDD с Jest**:

```javascript
// 1. Red: сначала пишем тест, который падает
test("sum adds two numbers correctly", () => {
  expect(sum(2, 3)).toBe(5);
  expect(sum(-1, 1)).toBe(0);
});

// 2. Green: пишем код, чтобы тест прошел
function sum(a, b) {
  return a + b;
}

// 3. Refactor: улучшаем код при необходимости
// (в данном случае код уже оптимален)
```

**Практики TDD в реальных проектах**:

- Начинать с тестирования API и интерфейсов
- Писать тесты для новых фич перед реализацией
- Добавлять тесты при исправлении багов
- Использовать TDD для рефакторинга сложного кода

</details>

<details>
<summary>143. Как использовать генераторы и итераторы для работы с большими наборами данных?</summary>

**Генераторы** позволяют эффективно работать с большими или бесконечными наборами данных без загрузки всех данных в память:

**Преимущества**:

- Ленивые вычисления (значения вычисляются по требованию)
- Низкое потребление памяти (данные загружаются частями)
- Возможность создания бесконечных последовательностей
- Простой интерфейс (yield для выдачи значений)

**Примеры использования**:

```javascript
// Функция-генератор для обработки больших файлов по строкам
function* readFileLines(filename) {
  // Предположим, это асинхронное чтение файла по частям
  const chunks = readFileInChunks(filename);
  let remainder = "";

  for (const chunk of chunks) {
    const lines = (remainder + chunk).split("\n");
    remainder = lines.pop(); // Неполная последняя строка

    for (const line of lines) {
      yield line;
    }
  }

  if (remainder) yield remainder;
}

// Использование генератора
for (const line of readFileLines("large-file.txt")) {
  processLine(line); // Обработка каждой строки по отдельности
}
```

**Пагинация и ленивая загрузка данных**:

```javascript
async function* fetchPaginatedData(url, pageSize = 100) {
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    const response = await fetch(`${url}?page=${page}&pageSize=${pageSize}`);
    const data = await response.json();

    if (data.items.length === 0) {
      hasMore = false;
    } else {
      for (const item of data.items) {
        yield item;
      }
      page++;
    }
  }
}

// Использование с for-await-of
(async () => {
  for await (const item of fetchPaginatedData("/api/items")) {
    processItem(item); // Обработка каждого элемента
  }
})();
```

**Комбинирование и трансформация данных**:

```javascript
function* map(iterable, mapFn) {
  for (const item of iterable) {
    yield mapFn(item);
  }
}

function* filter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) {
      yield item;
    }
  }
}

// Использование цепочки трансформаций
const numbers = [1, 2, 3, 4, 5];
const evenSquares = filter(
  map(numbers, (x) => x * x),
  (x) => x % 2 === 0
);

for (const num of evenSquares) {
  console.log(num); // 4, 16
}
```

</details>

<details>
<summary>144. В чем отличие между монолитной и микрофронтенд архитектурой?</summary>

**Монолитная архитектура**:

- Единое приложение с общей кодовой базой и зависимостями
- Все компоненты тесно связаны и развертываются вместе
- Простота начальной разработки и отладки
- Более низкий overhead для небольших и средних приложений

**Микрофронтенд архитектура**:

- Разделение фронтенда на независимые приложения/сервисы
- Каждый микрофронтенд может разрабатываться, тестироваться и развертываться отдельно
- Разные команды могут работать над разными частями независимо
- Возможность использования различных технологий/фреймворков

**Ключевые отличия**:

| **Аспект**                 | **Монолит**       | **Микрофронтенды**            |
| -------------------------- | ----------------- | ----------------------------- |
| **Сложность**              | Проще для начала  | Сложнее в настройке           |
| **Масштабирование команд** | Ограничено        | Эффективное распараллеливание |
| **Технологический стек**   | Единый            | Может различаться             |
| **Развертывание**          | Все сразу         | Независимо                    |
| **Производительность**     | Потенциально выше | Overhead при интеграции       |
| **Независимость команд**   | Ниже              | Выше                          |

**Методы композиции микрофронтендов**:

- **iFrame**: изоляция через фреймы (старый подход)
- **Web Components**: нативная инкапсуляция компонентов
- **JavaScript-интеграция**: Федерация модулей (Module Federation)
- **Серверная композиция**: сборка страницы на сервере
- **Прокси на уровне маршрутизации**: разные URL обслуживаются разными приложениями

**Примеры инструментов для микрофронтендов**:

- **Single SPA**: фреймворк для интеграции различных фронтенд-фреймворков
- **Webpack Module Federation**: динамическая загрузка кода между приложениями
- **Luigi**: фреймворк для микрофронтендов от SAP
- **Podium**: фреймворк для серверной композиции
- **Nx**: монорепозиторий для управления зависимостями

</details>
