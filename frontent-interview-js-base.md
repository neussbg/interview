\*JavaScript\*\*:

<details>
<summary>Какие типы данных существуют в JavaScript?</summary>
<div>
  <ul>
    <li>
      Число <b>«number»</b> - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
    </li>
    <li>
      Строка <b>«string»</b>
    </li>
    <li>
      Булевый (логический) тип <b>«boolean»</b>
    </li>
    <li>
      Специальное значение <b>«null»</b> - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
    </li>
    <li>
       Специальное значение <b>«undefined»</b> - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
    </li>
    <li>
       Символы <b>«symbol»</b> - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
    </li>
     <li>
      Тип «number» не может содержать числа больше, чем (2<sup>53</sup>-1), или меньше, чем -(2<sup>53</sup>-1). Тип <b>«bigint»</b> даёт возможность работать с целыми числами произвольной длины.
    </li>
    <li>
      Объекты <b>«object»</b> - Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
    </li>
  </ul>
  <p><i>Источник: <a href ="https://learn.javascript.ru/types">learn.javascript.ru</a></i></p>
</div>
</details>

<details>
<summary>Что такое цикл событий (event loop) и как он работает?</summary>
<div>
  <p>Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.</p>
  <p>Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.</p>
  <p>Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.</p>
   <img src="https://cdn-images-1.medium.com/max/1600/1*quyTIOs2hioCx1jRQ7-ojw.png" alt="EventLoop"/>
   <p><i>Источник: <a href ="https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242">Pavel Bely, medium.com</a></i></p>
</div>
</details>

<details>
<summary>Что такое замыкание?</summary>
<div>
  <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.</p>
  <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures">developer.mozilla.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое прототип объекта в JavaScript?</summary>
<div>
  <p>Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__</p>
  <p>Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.</p>
  <p>К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.</p>
  <p>Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.</p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/prototype">learn.javascript.ru</a></i></p>
</div>
</details>

<details>
<summary>Как работает ключевое слово this?</summary>
<div>
  <p>В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.</p>
  <p>В пределах функции значение this зависит от того, каким образом вызвана функция:</p>
  <ul>
  <li>Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply</li>
  <li>В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект. </li>
  <li>Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.</li>
  </ul>
  <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this">developer.mozilla.org</a></i></p>
</div>
</details>

<details>
<summary>Как работают методы apply(), call() и bind()?</summary>
<div>
  <p>Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.</p>
  <p>Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this  - методы bind, call и apply.</p>
  <ul>
    <li>
      <p>Синтаксис метода call: func.call(context, arg1, arg2, ...)</p>
      <p>При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).</p>
    </li>
    <li>
      <p>Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.</p>
      <p>
        func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);
      </p>
    </li>
    <li>
      <p>Синтаксис встроенного bind: var wrapper = func.bind(context, [arg1, arg2...])</p>
      <p>Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.</p>
    </li>
  </ul>
  <p>
    <i>Источник:
      <br/>
      <a href ="https://learn.javascript.ru/call-apply#metod-apply">javascript.ru - call и apply</a>
      <br/>
      <a href ="https://learn.javascript.ru/bind#bind">javascript.ru - bind</a>
    </i>
  </p>
</div>
</details>

<details>
<summary>Что такое Promise (Промис)?</summary>
<div>
  <br/>
  <p>Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).</p>
  <p>
    Синтаксис создания Promise:

    var promise = new Promise(function(resolve, reject) {
      // Эта функция будет вызвана автоматически

      // В ней можно делать любые асинхронные операции,
      // А когда они завершатся — нужно вызвать одно из:
      // resolve(результат) при успешном выполнении
      // reject(ошибка) при ошибке
    })

  </p>
  <p>
    Универсальный метод для навешивания обработчиков:

    promise.then(onFulfilled, onRejected)

  <ul>
    <li>onFulfilled – функция, которая будет вызвана с результатом при resolve.</li>
    <li>onRejected – функция, которая будет вызвана с ошибкой при reject.</li>
  </ul>
    Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
  <p>
    Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:

    // Создаётся объект promise
    let promise = new Promise((resolve, reject) => {

      setTimeout(() => {
        // переведёт промис в состояние fulfilled с результатом "result"
        resolve("result");
      }, 1000);

    });

    // promise.then навешивает обработчики на успешный результат или ошибку
    promise
      .then(
        result => {
          // первая функция-обработчик - запустится при вызове resolve
          alert("Fulfilled: " + result); // result - аргумент resolve
        },
        error => {
          // вторая функция - запустится при вызове reject
          alert("Rejected: " + error); // error - аргумент reject
        }
      );

В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».

  </p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/promise">javascript.ru</a></i></p>
</div>
</details>

<details>
  <summary>Что такое статический метод класса (static)?</summary>
  <div>
    <p>
      Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.

      class Repo {
        static getName() {
          return "Repo name is modern-js-cheatsheet"
        }
      }

      // нам не нужно создавать объект класса Repo
      console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

      let r = new Repo();
      console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией

   </p>
    <p>
      Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
    </p>
    <p>
    </p>
    <p>
      <i>Источник: <a href="https://tproger.ru/translations/javascript-cheatsheet/#sttcmthds">tproger.ru</a>
      </i>
    </p>
  </div>
</details>

<details>
<summary>Что такое Set, Map, WeakSet и WeakMap?</summary>
<div>
  <br/>
  <p>В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.</p>
  <p>Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:</p>
  <p>

    'use strict';

    let map = new Map();

    map.set('1', 'str1');   // ключ-строка
    map.set(1, 'num1');     // число
    map.set(true, 'bool1'); // булевое значение

    // в обычном объекте это было бы одно и то же,
    // map сохраняет тип ключа
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3

  </p>
  <p>
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
  </p>
  <p>

    'use strict';

    let set = new Set();

    let vasya = {name: "Вася"};
    let petya = {name: "Петя"};
    let dasha = {name: "Даша"};

    // посещения, некоторые пользователи заходят много раз
    set.add(vasya);
    set.add(petya);
    set.add(dasha);
    set.add(vasya);
    set.add(petya);

    // set сохраняет только уникальные значения
    alert( set.size ); // 3

    set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша

  </p>
  <p>
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. 
    То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
  </p>
  <p>

    // текущие активные пользователи
    let activeUsers = [
      {name: "Вася"},
      {name: "Петя"},
      {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент

  </p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/set-map">javascript.ru</a></i></p>
</div>
</details>

<br/>

# Память в JavaScript: ключевые концепции для собеседования

## Хип-память (Heap Memory) и Стек-память (Stack Memory)

### Хип-память (Heap Memory)

**Определение**: Область динамически распределяемой памяти, которая используется для хранения объектов и других сложных структур данных. Не имеет четкой организационной структуры, напоминая "кучу".

**Ключевые характеристики**:

- Хранит объекты, массивы, функции и другие ссылочные типы данных
- Память выделяется и освобождается в произвольном порядке
- Управляется сборщиком мусора (garbage collector)
- Доступ к данным осуществляется по ссылкам
- Объем ограничен только доступной физической памятью устройства
- Относительно медленный доступ (по сравнению со стеком)

### Стек-память (Stack Memory)

**Определение**: Структурированная область памяти, организованная как стек (структура данных LIFO - Last In, First Out), которая хранит локальные переменные и информацию о вызовах функций.

**Ключевые характеристики**:

- Хранит примитивные типы данных (числа, строки, булевы значения)
- Хранит ссылки (указатели) на объекты в хипе
- Организована как последовательность фреймов
- Каждый вызов функции создает новый фрейм стека
- Автоматически освобождается при завершении функции
- Ограниченный фиксированный размер (может вызвать ошибку Stack Overflow)
- Быстрый доступ

### Разница между Хип и Стек памятью

| Характеристика      | Хип (Heap)                   | Стек (Stack)                                   |
| ------------------- | ---------------------------- | ---------------------------------------------- |
| Структура           | Неструктурированная "куча"   | Структурированный LIFO-стек                    |
| Тип хранимых данных | Объекты, массивы, функции    | Примитивы и ссылки на объекты                  |
| Управление памятью  | Сборщик мусора               | Автоматическое при выходе из области видимости |
| Размер              | Динамический, ограничен RAM  | Фиксированный, ограниченный                    |
| Скорость доступа    | Медленнее                    | Быстрее                                        |
| Время жизни данных  | До тех пор, пока есть ссылки | Ограничено жизненным циклом функции            |
| Фрагментация        | Возможна                     | Отсутствует                                    |

### Пример ответа на собеседовании

**Вопрос**: В чем разница между хип-памятью и стек-памятью в JavaScript?

**Ответ**:
"JavaScript использует две основные области памяти: хип (heap) и стек (stack).

Стек-память хранит примитивные типы данных и ссылки на объекты, а также отслеживает порядок выполнения кода через фреймы стека. Стек имеет фиксированный размер, работает по принципу LIFO (последним пришел, первым ушел), и память освобождается автоматически при выходе из функции. Доступ к данным в стеке очень быстрый.

Хип-память, напротив, используется для хранения объектов, массивов, функций и других сложных структур данных. Это динамически распределяемая область памяти без строгой организационной структуры. Хип управляется сборщиком мусора, который автоматически освобождает память, когда на объект больше нет ссылок. Размер хипа ограничен только доступной оперативной памятью, но доступ к данным в хипе медленнее, чем в стеке.

Когда мы создаем переменную с примитивным типом данных (например, число или строку), она хранится в стеке. Когда мы создаем объект, сам объект хранится в хипе, а в стеке хранится только ссылка на этот объект."

## Утечки памяти (Memory Leaks) в JavaScript

**Определение**: Утечка памяти происходит, когда программа неправильно управляет распределением памяти, в результате чего неиспользуемые объекты не освобождаются сборщиком мусора и продолжают занимать память.

### Основные причины утечек памяти

1. **Ненужные ссылки**: Сборщик мусора не может освободить объект, если на него все еще есть хотя бы одна ссылка.

2. **Замыкания (Closures)**: Функции, которые продолжают ссылаться на переменные из внешней области видимости, предотвращая их сборку мусором.

3. **Обработчики событий**: Неудаленные обработчики событий, особенно при динамическом создании и удалении DOM-элементов.

4. **Циклические ссылки**: Объекты, которые ссылаются друг на друга, образуя замкнутый цикл.

5. **Таймеры и интервалы**: Незавершенные вызовы `setTimeout` или `setInterval`, которые ссылаются на объекты.

6. **Глобальные переменные**: Объекты, хранящиеся в глобальной области видимости, не собираются мусором до закрытия страницы.

### Пример утечки памяти и ее решения

**Утечка через обработчики событий**:

```javascript
function setupButton() {
  const button = document.createElement("button");
  const heavyData = new Array(10000000).fill("x"); // Большой массив данных

  button.addEventListener("click", function () {
    // Использование heavyData внутри обработчика создает замыкание
    console.log("Button clicked, data length:", heavyData.length);
  });

  document.body.appendChild(button);

  // Позже удаляем кнопку
  document.body.removeChild(button);
  // Утечка: обработчик события все еще ссылается на heavyData!
}
```

**Решение**:

```javascript
function setupButton() {
  const button = document.createElement("button");
  const heavyData = new Array(10000000).fill("x");

  const clickHandler = function () {
    console.log("Button clicked, data length:", heavyData.length);
  };

  button.addEventListener("click", clickHandler);

  document.body.appendChild(button);

  // Правильное удаление:
  button.removeEventListener("click", clickHandler); // Удаляем обработчик
  document.body.removeChild(button); // Удаляем элемент
  // heavyData теперь может быть собран мусором
}
```

### Как предотвратить утечки памяти

1. **Своевременно удаляйте обработчики событий**, особенно перед удалением DOM-элементов
2. **Используйте слабые ссылки** (`WeakMap`, `WeakSet`) для хранения объектов
3. **Не злоупотребляйте замыканиями**, особенно с большими объемами данных
4. **Избегайте глобальных переменных** или явно присваивайте им `null`, когда они больше не нужны
5. **Контролируйте таймеры** с помощью `clearTimeout` и `clearInterval`
6. **Используйте инструменты разработчика** для профилирования памяти и выявления утечек

<details>
<summary>Что такое БЭМ и какие проблемы он решает?</summary>
<div>
  <p>БЭМ (Блок-Элемент-Модификатор) – это методология разработки интерфейсов, предложенная Яндексом, основанная на принципах декомпозиции веб-интерфейса на независимые блоки.</p>
  
  <p><b>Решаемые проблемы</b>:</p>
  <ul>
    <li>Упорядочивает структуру CSS-правил и устраняет конфликты имен классов</li>
    <li>Улучшает повторное использование компонентов интерфейса</li>
    <li>Облегчает масштабирование и поддержку кода</li>
    <li>Создает общую терминологию и структуру для команды</li>
    <li>Снижает специфичность селекторов и уменьшает каскадность</li>
  </ul>
  
  <p><b>Синтаксис</b>:</p>
  <ul>
    <li><b>Блок</b>: Функционально независимый компонент (<code>.header</code>, <code>.button</code>)</li>
    <li><b>Элемент</b>: Часть блока, не имеющая самостоятельного значения (<code>header__logo</code>, <code>button__text</code>)</li>
    <li><b>Модификатор</b>: Вариация блока или элемента (<code>button--large</code>, <code>header--fixed</code>)</li>
  </ul>
</div>
</details>

<details>
<summary>Что такое вес селектора (специфичность) и как он высчитывается?</summary>
<div>
  <p>Специфичность – это механизм CSS, определяющий, какие правила стилей будут применены к элементу в случае конфликта.</p>
  
  <p><b>Вычисление специфичности</b>:</p>
  <ol>
    <li>Инлайн-стили: a = 1000</li>
    <li>Идентификаторы (ID): b = 100 за каждый</li>
    <li>Классы, псевдоклассы, атрибуты: c = 10 за каждый</li>
    <li>Элементы и псевдоэлементы: d = 1 за каждый</li>
  </ol>
  
  <p><b>Пример расчета специфичности</b> для селектора <code>html body header#header nav.nav ul[data-list-role="navigation"] li:first-child</code>:</p>
  <ul>
    <li>Идентификаторы: 1 (<code>#header</code>) = 100</li>
    <li>Классы/атрибуты: 2 (<code>.nav</code>, <code>[data-list-role="navigation"]</code>) = 20</li>
    <li>Элементы/псевдоэлементы: 6 (<code>html</code>, <code>body</code>, <code>header</code>, <code>nav</code>, <code>ul</code>, <code>li</code>) = 6</li>
    <li>Псевдоклассы: 1 (<code>:first-child</code>) = 10</li>
  </ul>
  
  <p><b>Итоговый вес</b>: 0,1,3,6 или 136</p>
  
  <p>Такой сложный селектор усложняет переопределение стилей и делает CSS менее гибким, поэтому в современной разработке мы стремимся к более плоской структуре селекторов.</p>
</div>
</details>

<details>
<summary>Какие способы центрирования элемента по горизонтали и вертикали вы знаете?</summary>
<div>
  <p>Существует несколько способов центрировать элемент по горизонтали и вертикали:</p>
  
  <p><b>1. Flex</b>:</p>
  <pre>
.parent {
  display: flex;
  justify-content: center; /* горизонтально */
  align-items: center; /* вертикально */
}
  </pre>
  
  <p><b>2. Grid</b>:</p>
  <pre>
.parent {
  display: grid;
  place-items: center; /* и горизонтально, и вертикально */
}
  </pre>
  
  <p><b>3. Абсолютное позиционирование</b>:</p>
  <pre>
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
  </pre>
  
  <p><b>4. Таблицы</b>:</p>
  <pre>
.parent {
  display: table-cell;
  text-align: center; /* горизонтально */
  vertical-align: middle; /* вертикально */
}
  </pre>
  
  <p><b>5. Margin auto с известными размерами</b>:</p>
  <pre>
.child {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  width: 200px; /* требуются фиксированные размеры */
  height: 100px;
}
  </pre>
</div>
</details>

<details>
<summary>Чем принципиально Grid отличается от Flexbox? Когда удобнее использовать каждый из них?</summary>
<div>
  <p><b>Flexbox</b>:</p>
  <ul>
    <li><b>Одномерная система</b> - работает в одном направлении (строка или колонка)</li>
    <li>Лучше для выравнивания элементов внутри контейнера</li>
    <li>Идеален для компонентов пользовательского интерфейса (кнопки, навигация, карточки)</li>
    <li>Проще в освоении и использовании</li>
  </ul>
  
  <p><b>Grid</b>:</p>
  <ul>
    <li><b>Двумерная система</b> - работает одновременно с строками и колонками</li>
    <li>Лучше для определения макета всей страницы</li>
    <li>Идеален для сложных, многострочных/многоколоночных дизайнов</li>
    <li>Позволяет точно размещать элементы в любом месте сетки</li>
  </ul>
  
  <p><b>Когда использовать</b>:</p>
  <ul>
    <li><b>Flex</b>: для компонентов с линейным распределением (меню, списки, группы кнопок)</li>
    <li><b>Grid</b>: для макетов страниц, структурных сеток, сложных выравниваний</li>
  </ul>
</div>
</details>

<details>
<summary>Чем отличаются форматы изображений: JPG, PNG, SVG?</summary>
<div>
  <p><b>JPG/JPEG</b>:</p>
  <ul>
    <li>Формат с потерями качества (lossy)</li>
    <li>Хорошо подходит для фотографий и изображений с градиентами</li>
    <li>Не поддерживает прозрачность</li>
    <li>Меньший размер файла за счет потери качества</li>
  </ul>
  
  <p><b>PNG</b>:</p>
  <ul>
    <li>Формат без потерь (lossless)</li>
    <li>Поддерживает прозрачность</li>
    <li>Лучше для изображений с текстом, элементами интерфейса, контрастными границами</li>
    <li>Больший размер файла по сравнению с JPEG</li>
  </ul>
  
  <p><b>SVG</b>:</p>
  <ul>
    <li>Векторный формат (масштабируется без потери качества)</li>
    <li>Основан на XML, может редактироваться в текстовом редакторе</li>
    <li>Доступ к отдельным элементам через CSS/JavaScript</li>
    <li>Идеален для иконок, логотипов, иллюстраций</li>
    <li>Очень маленький размер для простых изображений</li>
  </ul>
</div>
</details>

<details>
<summary>Как сделать, чтобы футер всегда прижимался к низу страницы даже при малом количестве контента?</summary>
<div>
  <p>Есть несколько способов прижать футер к низу страницы при малом количестве контента:</p>
  
  <p><b>Решение с использованием Flexbox</b>:</p>
  <pre>
body {
  display: flex;
  flex-direction: column;
  min-height: 100vh; /* важно */
}

main {
flex-grow: 1; /_ растягивание основного контента _/
}

  </pre>
  
  <p><b>Решение с использованием Grid</b>:</p>
  <pre>
body {
  display: grid;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
}
  </pre>
  
  <p>В обоих случаях важно установить минимальную высоту body равной 100vh (100% высоты viewport), чтобы даже при малом количестве контента страница занимала всю высоту экрана.</p>
</div>
</details>

<details>
<summary>JavaScript синхронный или асинхронный? Однопоточный или многопоточный?</summary>
<div>
  <p>JavaScript:</p>
  <ul>
    <li><b>Синхронный</b> язык (выполняет код последовательно)</li>
    <li><b>Однопоточный</b> (выполняет одну операцию в один момент времени)</li>
  </ul>
  
  <p>Однако JavaScript может выполнять асинхронные операции благодаря механизмам, предоставляемым средой выполнения (браузером или Node.js).</p>
</div>
</details>

<details>
<summary>За счет чего достигается асинхронность в JavaScript?</summary>
<div>
  <p><b>Асинхронность</b> в JavaScript достигается через:</p>
  <ul>
    <li><b>Event Loop</b> (цикл событий) - фундаментальный механизм для обработки асинхронных операций</li>
    <li><b>Web APIs</b>, предоставляемые браузером (setTimeout, AJAX, DOM Events)</li>
    <li><b>Callback-функции</b>, обрабатываемые после завершения синхронного кода</li>
    <li><b>Promise API</b> и <b>async/await</b>, упрощающие работу с асинхронным кодом</li>
    <li><b>Микрозадачи</b> (микротаски) и <b>макрозадачи</b> (таски)</li>
  </ul>
  
  <p>При этом сам JavaScript-код всегда выполняется в одном потоке, а асинхронность достигается за счет передачи долгих операций в API окружения и постановки колбэков в очередь для будущего выполнения.</p>
</div>
</details>

<details>
<summary>Какие стадии рендеринга в браузере вы знаете?</summary>
<div>
  <p>Основные стадии рендеринга веб-страницы в браузере:</p>
  <ol>
    <li><b>Парсинг HTML и построение DOM</b> - создание объектной модели документа</li>
    <li><b>Парсинг CSS и построение CSSOM</b> - создание объектной модели стилей</li>
    <li><b>Формирование Render Tree</b> - объединение DOM и CSSOM в дерево рендеринга</li>
    <li><b>Layout (Reflow)</b> - вычисление размеров и позиций всех элементов</li>
    <li><b>Paint</b> - отрисовка пикселей на экране</li>
    <li><b>Compositing</b> - компоновка слоев для финальной отрисовки</li>
  </ol>
  
  <p>Этот процесс может повторяться при изменении DOM или стилей, причем браузер старается оптимизировать его, перерисовывая только те части страницы, которые изменились.</p>
</div>
</details>

<details>
<summary>Зачем нужны методы call, apply, bind? В чем их принципиальная роль для функций?</summary>
<div>
  <p><b>Назначение</b>: Методы управления контекстом выполнения функции (<code>this</code>)</p>
  
  <p><b>Call</b>:</p>
  <ul>
    <li>Вызывает функцию с указанным контекстом</li>
    <li>Принимает аргументы списком через запятую</li>
    <li><code>function.call(context, arg1, arg2)</code></li>
  </ul>
  
  <p><b>Apply</b>:</p>
  <ul>
    <li>Вызывает функцию с указанным контекстом</li>
    <li>Принимает аргументы массивом</li>
    <li><code>function.apply(context, [arg1, arg2])</code></li>
  </ul>
  
  <p><b>Bind</b>:</p>
  <ul>
    <li>Создает новую функцию с привязанным контекстом</li>
    <li>Не вызывает функцию сразу</li>
    <li><code>const newFunction = function.bind(context, arg1, arg2)</code></li>
  </ul>
  
  <p>Эти методы особенно полезны, когда нужно управлять значением <code>this</code> внутри функций, например, при работе с событиями, коллбэками или когда нужно "одолжить" метод одного объекта для использования с другим объектом.</p>
</div>
</details>

<details>
<summary>Что такое контекст в JavaScript? Чем стрелочные функции отличаются в этом плане?</summary>
<div>
  <p><b>Контекст</b> в JavaScript - это значение ключевого слова <code>this</code> внутри функции или метода.</p>
  
  <p>Значение <code>this</code> определяется в момент вызова функции и может быть:</p>
  <ul>
    <li>В глобальном контексте: <code>window</code> (браузер) или <code>global</code> (Node.js)</li>
    <li>В методе объекта: сам объект</li>
    <li>В обработчике события: элемент, вызвавший событие</li>
    <li>В конструкторе класса: создаваемый экземпляр</li>
    <li>В стрелочных функциях: контекст родительской функции (лексический контекст)</li>
  </ul>
  
  <p><b>Стрелочные функции</b>:</p>
  <ul>
    <li>Не имеют собственного <code>this</code></li>
    <li>Наследуют <code>this</code> из внешнего лексического окружения</li>
    <li>Нельзя изменить их контекст через <code>bind/call/apply</code></li>
  </ul>
  
  <p>Например, в обычной функции:</p>
  <pre>
const obj = {
  name: 'Объект',
  regularMethod: function() {
    console.log(this.name); // "Объект"
  },
  arrowMethod: () => {
    console.log(this.name); // undefined или значение из внешнего контекста
  }
};
  </pre>
  
  <p>И нельзя привязать контекст к стрелочной функции с помощью bind:</p>
  <pre>
const arrow = () => { console.log(this); };
const boundArrow = arrow.bind({x: 42});
// boundArrow() все равно использует исходный this, а не {x: 42}
  </pre>
</div>
</details>

<details>
<summary>Зачем нужен виртуальный DOM? Какие проблемы он решает?</summary>
<div>
  <p><b>Виртуальный DOM</b> - это абстракция, представляющая настоящий DOM в виде легковесных JavaScript-объектов.</p>
  
  <p><b>Решаемые проблемы</b>:</p>
  <ul>
    <li>Повышает производительность за счет минимизации обращений к реальному DOM</li>
    <li>Группирует несколько изменений в одну операцию с DOM</li>
    <li>Оптимизирует обновления, определяя только необходимые изменения</li>
    <li>Предоставляет декларативный API для описания интерфейса</li>
    <li>Абстрагирует различия браузерных реализаций DOM API</li>
  </ul>
  
  <p><b>Принцип работы</b>:</p>
  <ol>
    <li>Создание виртуального представления DOM</li>
    <li>При изменениях создается новое виртуальное дерево</li>
    <li>Выполняется алгоритм сравнения (diffing) старого и нового деревьев</li>
    <li>Создается минимальный набор изменений для DOM (patching)</li>
    <li>Применяется только необходимые изменения к реальному DOM</li>
  </ol>
  
  <p>Виртуальный DOM широко используется в современных фреймворках и библиотеках, таких как React, Vue.js и других.</p>
</div>
</details>

<details>

<summary>Что такое BOM (Browser Object Model) и какое место он занимает?</summary>
<div>
  <p><b>Browser Object Model (BOM)</b> - это объектная модель браузера, которая предоставляет интерфейс для взаимодействия с браузером. В отличие от DOM (который регламентирован и стандартизирован W3C), BOM не имеет формального стандарта и может различаться в разных браузерах.</p>
  
  <p><b>Основные объекты BOM</b>:</p>
  <ul>
    <li><b>window</b> - глобальный объект, представляющий окно браузера, родительский объект для всех объектов BOM и DOM</li>
    <li><b>navigator</b> - содержит информацию о браузере (версия, плагины, пользовательский агент и т.д.)</li>
    <li><b>location</b> - предоставляет информацию о текущем URL и методы для перенаправления</li>
    <li><b>history</b> - позволяет управлять историей браузера (навигация вперед/назад)</li>
    <li><b>screen</b> - предоставляет информацию об экране пользователя (размеры, глубина цвета)</li>
    <li><b>document</b> - входит в BOM, но также является точкой входа в DOM</li>
  </ul>
  
  <p><b>Пример использования объектов BOM</b>:</p>
  <pre>
// Доступ к информации о браузере
console.log(navigator.userAgent);
console.log(navigator.language);

// Манипуляции с URL
console.log(location.href); // получение текущего URL
location.href = 'https://example.com'; // перенаправление

// Работа с историей
history.back(); // назад
history.forward(); // вперед

// Информация об окне и экране
console.log(window.innerWidth); // ширина области просмотра
console.log(screen.width); // ширина экрана

  </pre>
  
  <p><b>Место BOM в веб-разработке</b>:</p>
  <ul>
    <li>BOM является неотъемлемой частью клиентского JavaScript</li>
    <li>Предоставляет API для взаимодействия с браузером, отличные от манипуляций с содержимым страницы</li>
    <li>Позволяет реализовать функциональность, зависящую от характеристик браузера (обнаружение возможностей, адаптация к размеру экрана и т.д.)</li>
    <li>Дает возможность управлять навигацией, временем (setTimeout, setInterval), хранением данных (localStorage, sessionStorage)</li>
    <li>Формирует основу для многих APIs браузера (Geolocation API, Fetch API и другие)</li>
  </ul>
  
  <p><i>Отношение к другим концепциям</i>:</p>
  <ul>
    <li>DOM является частью более широкой концепции BOM</li>
    <li>JavaScript в браузере использует window как глобальный объект, через который доступны все глобальные переменные и функции</li>
    <li>WebAPIs обычно доступны через объекты BOM (например, navigator.geolocation)</li>
  </ul>
  
  <p><i>Источник: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">MDN Web Docs - Window</a></i></p>
</div>
</details>

<br/>
